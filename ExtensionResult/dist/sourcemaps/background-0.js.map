{"version":3,"sources":["shared/constants/metametrics.js","app/scripts/first-time-state.js","app/scripts/lib/getObjStructure.js","node_modules/debounce-stream/index.js","app/scripts/lib/local-store.js","app/scripts/lib/get-first-preferred-lang-code.js","app/scripts/lib/createStreamSink.js","app/scripts/lib/network-store.js","app/scripts/lib/notification-manager.js","node_modules/@metamask/obs-store/dist/index.js","app/scripts/lib/migrator/index.js","app/scripts/migrations/index.js","app/scripts/lib/ens-ipfs/setup.js","app/scripts/metamask-controller.js","node_modules/debounce/index.js","node_modules/through/index.js","node_modules/duplexer/index.js","node_modules/@metamask/obs-store/dist/asStream.js","node_modules/@metamask/obs-store/dist/MergedStore.js","node_modules/@metamask/obs-store/dist/ComposedStore.js","node_modules/@metamask/obs-store/dist/LocalStorageStore.js","node_modules/@metamask/obs-store/dist/ObservableStore.js","node_modules/@metamask/obs-store/dist/transform.js","app/scripts/migrations/003.js","app/scripts/migrations/002.js","app/scripts/migrations/010.js","app/scripts/migrations/009.js","app/scripts/migrations/017.js","app/scripts/migrations/015.js","app/scripts/migrations/026.js","app/scripts/migrations/013.js","app/scripts/migrations/014.js","app/scripts/migrations/028.js","app/scripts/migrations/027.js","app/scripts/migrations/024.js","app/scripts/migrations/036.js","app/scripts/migrations/039.js","app/scripts/migrations/052.js","app/scripts/migrations/032.js","app/scripts/migrations/044.js","app/scripts/migrations/016.js","app/scripts/migrations/041.js","app/scripts/migrations/045.js","app/scripts/migrations/022.js","app/scripts/migrations/042.js","app/scripts/migrations/033.js","app/scripts/migrations/034.js","app/scripts/migrations/047.js","app/scripts/migrations/058.js","app/scripts/migrations/031.js","app/scripts/migrations/059.js","app/scripts/migrations/056.js","app/scripts/migrations/050.js","app/scripts/migrations/046.js","app/scripts/migrations/040.js","app/scripts/migrations/051.js","app/scripts/migrations/061.js","app/scripts/migrations/030.js","app/scripts/migrations/023.js","app/scripts/migrations/025.js","app/scripts/migrations/019.js","app/scripts/migrations/055.js","app/scripts/migrations/062.js","app/scripts/migrations/054.js","app/scripts/migrations/049.js","app/scripts/migrations/060.js","app/scripts/migrations/064.js","app/scripts/migrations/043.js","app/scripts/migrations/011.js","app/scripts/migrations/004.js","app/scripts/migrations/035.js","app/scripts/migrations/069.js","app/scripts/migrations/021.js","app/scripts/migrations/065.js","app/scripts/migrations/012.js","app/scripts/migrations/020.js","app/scripts/migrations/037.js","app/scripts/migrations/038.js","app/scripts/migrations/029.js","app/scripts/migrations/057.js","app/scripts/migrations/005.js","app/scripts/migrations/007.js","app/scripts/migrations/048.js","app/scripts/migrations/063.js","app/scripts/migrations/008.js","app/scripts/migrations/066.js","app/scripts/migrations/068.js","app/scripts/migrations/053.js","app/scripts/migrations/067.js","app/scripts/migrations/006.js","app/scripts/migrations/018.js","node_modules/base32-encode/index.js","app/scripts/lib/ens-ipfs/resolver.js","app/scripts/lib/createTabIdMiddleware.js","app/scripts/lib/createOriginMiddleware.js","node_modules/nanoid/index.browser.js","app/scripts/lib/createMetaRPCHandler.js","node_modules/json-rpc-middleware-stream/engineStream.js","node_modules/json-rpc-engine/dist/index.js","app/scripts/lib/createOnboardingMiddleware.js","app/scripts/lib/ComposableObservableStore.js","app/scripts/lib/message-manager.js","app/scripts/controllers/onboarding.js","app/scripts/lib/personal-message-manager.js","app/scripts/lib/seed-phrase-verifier.js","app/scripts/controllers/detect-tokens.js","app/scripts/controllers/cached-balances.js","app/scripts/lib/createLoggerMiddleware.js","app/scripts/controllers/metametrics.js","app/scripts/lib/decrypt-message-manager.js","app/scripts/controllers/alert.js","app/scripts/controllers/incoming-transactions.js","app/scripts/lib/encryption-public-key-manager.js","app/scripts/controllers/app-state.js","app/scripts/lib/typed-message-manager.js","app/scripts/controllers/ens/index.js","app/scripts/controllers/permissions/index.js","app/scripts/controllers/transactions/index.js","app/scripts/lib/segment.js","app/scripts/account-import-strategies/index.js","app/scripts/controllers/network/index.js","app/scripts/controllers/swaps.js","node_modules/@metamask/eth-ledger-bridge-keyring/index.js","node_modules/eth-json-rpc-middleware/dist/index.js","node_modules/eth-lattice-keyring/index.js","node_modules/@metamask/smart-transactions-controller/dist/index.js","app/scripts/controllers/preferences.js","app/scripts/lib/account-tracker.js","node_modules/eth-trezor-keyring/index.js","node_modules/@metamask/snap-controllers/dist/index.js","app/scripts/lib/rpc-method-middleware/index.js","node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.js","app/scripts/controllers/threebox.js","node_modules/@metamask/safe-event-emitter/index.js","node_modules/@metamask/obs-store/node_modules/through2/through2.js","app/scripts/migrations/fail-tx.js","app/scripts/controllers/transactions/lib/tx-state-history-helpers.js","node_modules/to-data-view/index.js"],"names":["path","title","url","config","PreferencesController","frequentRpcListDetail","rpcUrl","chainId","ticker","nickname","rpcPrefs","obj","deepMap","_lodash","cloneDeep","value","require","target","visit","Object","entries","forEach","key","through","duplexer","debounce","module","exports","_ms","immediate","input","data","output","queue","_extensionizer","_interopRequireDefault","_loglevel","_util","constructor","this","isSupported","Boolean","default","storage","local","error","async","undefined","result","_get","keys","length","state","_set","Promise","resolve","reject","get","err","checkForError","set","userPreferredLocaleCodes","getPreferredLocales","e","firstPreferredLangCode","map","code","toLowerCase","replace","find","existingLocaleCodes","split","_pify","_index","i18n","getAcceptLanguages","errorFirst","locale","asyncWriteFn","_opts","AsyncWritableStream","_readableStream","_promiseToCallback","Writable","opts","_objectSpread","objectMode","super","_asyncWriteFn","_write","chunk","encoding","callback","_time","fetchWithTimeout","SECOND","_defineProperty2","_initialized","_initializing","_init","_state","response","ok","json","debug","message","_safeEventEmitter","_extension","NOTIFICATION_MANAGER_EVENTS","POPUP_CLOSED","NotificationManager","platform","addOnRemovedListener","_onWindowClosed","bind","markAsAutomaticallyClosed","_popupAutomaticallyClosed","popup","_getPopup","focusWindow","id","left","top","lastFocused","getLastFocusedWindow","width","_","screenX","screenY","outerWidth","window","Math","max","popupWindow","openWindow","type","height","updateWindowPosition","_popupId","windowId","emit","automaticallyClosed","windows","getAllWindows","_getPopupIn","win","__createBinding","create","o","m","k","k2","defineProperty","enumerable","__exportStar","p","prototype","hasOwnProperty","call","_events","Migrator","migrations","sort","a","b","version","lastMigration","slice","defaultVersion","versionedData","generateInitialState","pendingMigrations","filter","migration","meta","migratedData","migrate","Error","originalErrorMessage","_2","_3","_4","_5","_6","_7","_8","_9","_10","_11","_12","_13","_14","_15","_16","_17","_18","_19","_20","_21","_22","_23","_24","_25","_26","_27","_28","_29","_30","_31","_32","_33","_34","_35","_36","_37","_38","_39","_40","_41","_42","_43","_44","_45","_46","_47","_48","_49","_50","_51","_52","_53","_54","_55","_56","_57","_58","_59","_60","_61","_62","_63","_64","_65","_66","_67","_68","provider","urlPatterns","supportedTopLevelDomains","tld","webRequest","onErrorOccurred","addListener","webRequestDidFail","urls","types","remove","removeListener","details","tabId","getCurrentChainId","URL","domainParts","name","topLevelDomain","includes","ipfsGateway","getIpfsGateway","tabs","update","_resolver","resolvedUrl","hash","pathname","search","fragment","method","status","console","warn","padded","padEnd","decoded","_base64Js","toByteArray","options","padding","_base32Encode","attemptResolve","_fetchWithTimeout","_pump","_obsStore","_asStream","_jsonRpcEngine","_engineStream","_ethJsonRpcFilters","_subscriptionManager","_ethJsonRpcMiddleware","_ethKeyringController","_ethRpcErrors","_awaitSemaphore","_ethereumjsUtil","_ethTrezorKeyring","_ethLedgerBridgeKeyring","_ethLatticeKeyring","_metamaskAirgappedKeyring","_ethQuery","_nanoid","_browser","_controllers","_smartTransactionsController","_snapControllers","_transaction","_swaps","_network","_hardwareWallets","_permissions","_notifications","_hexstringUtils","_app","_conversions","_tokenUtil","_transactions","_ComposableObservableStore","_accountTracker","_createLoggerMiddleware","_rpcMethodMiddleware","_createOriginMiddleware","_createTabIdMiddleware","_createOnboardingMiddleware","_streamUtils","_ens","_network2","_interopRequireWildcard","_preferences","_appState","_cachedBalances","_alert","_onboarding","_threebox","_incomingTransactions","_messageManager","_decryptMessageManager","_encryptionPublicKeyManager","_personalMessageManager","_typedMessageManager","_transactions2","_detectTokens","_swaps2","_accountImportStrategies","_seedPhraseVerifier","_metametrics","_segment","_createMetaRPCHandler","_permissions2","UPDATE_BADGE","APPROVAL_STATE_CHANGE","MetamaskController","_process$env$CONF","defaultMaxListeners","sendUpdate","privateSendUpdate","MILLISECOND","extension","notificationManager","initState","getVersion","recordFirstTimeInfo","activeControllerConnections","getRequestAccountTabIds","getOpenMetamaskTabsIds","controllerMessenger","ControllerMessenger","store","persist","connections","createVaultMutex","Mutex","runtime","onInstalled","reason","openExtensionInBrowser","approvalController","ApprovalController","messenger","getRestricted","showApprovalRequest","showUserConfirmation","networkController","NetworkController","setInfuraProjectId","infuraProjectId","initializeProvider","getProviderAndBlockTracker","blockTracker","preferencesController","initLangCode","openPopup","network","migrateAddressBookState","tokensController","TokensController","onPreferencesStateChange","subscribe","onNetworkStateChange","assetsContractController","AssetsContractController","collectiblesController","CollectiblesController","getERC721AssetName","getERC721AssetSymbol","getERC721TokenURI","getERC721OwnerOf","getERC1155BalanceOf","getERC1155TokenURI","setApiKey","process","env","OPENSEA_KEY","collectibleDetectionController","CollectibleDetectionController","onCollectiblesStateChange","listener","getOpenSeaApiKey","openSeaApiKey","getBalancesInSingleCall","addCollectible","getCollectiblesState","metaMetricsController","segment","preferencesStore","onNetworkDidChange","on","NETWORK_EVENTS","NETWORK_DID_CHANGE","getNetworkIdentifier","environment","MetaMetricsController","captureException","gasFeeMessenger","gasApiBaseUrl","GAS_API_BASE_URL","gasFeeController","GasFeeController","interval","clientId","SWAPS_CLIENT_ID","getProvider","getCurrentNetworkEIP1559Compatibility","getEIP1559Compatibility","getCurrentAccountEIP1559Compatibility","legacyAPIEndpoint","EIP1559APIEndpoint","getCurrentNetworkLegacyGasAPICompatibility","IN_TEST","MAINNET_CHAIN_ID","getChainId","qrHardwareKeyring","MetaMaskKeyring","appStateController","addUnlockListener","isUnlocked","AppStateController","onInactiveTimeout","setLocked","showUnlockRequest","qrHardwareStore","getMemStore","currencyRateMessenger","currencyRateController","CurrencyRateController","includeUSDRate","CurrencyController","tokenListMessenger","tokenListController","TokenListController","hexToDecimal","useStaticTokenList","getState","useTokenDetection","cb","networkState","modifiedNetworkState","preferencesState","modifiedPreferencesState","phishingController","PhishingController","notificationController","NotificationController","allNotifications","UI_NOTIFICATIONS","tokenRatesController","TokenRatesController","onTokensStateChange","onCurrencyRateStateChange","ensController","incomingTransactionsController","IncomingTransactionsController","accountTracker","start","stop","cachedBalancesController","CachedBalancesController","onboardingController","OnboardingController","hub","additionalKeyrings","keyringController","keyringTypes","KeyringController","encryptor","memStore","_onKeyringControllerUpdate","_onUnlock","_onLock","getIdentities","identities","permissionController","PermissionController","allowedActions","caveatSpecifications","getCaveatSpecifications","permissionSpecifications","getPermissionSpecifications","getAllAccounts","getAccounts","captureKeyringTypesWithMissingIdentities","accounts","keyringTypesWithMissingIdentities","address","_this$keyringControll","getKeyringForAccount","identitiesCount","accountTrackerCount","unrestrictedMethods","permissionLogController","PermissionLogController","restrictedMethods","Set","RestrictedMethods","subjectMetadataController","SubjectMetadataController","subjectCacheLimit","detectTokensController","preferences","keyringMemStore","tokenList","addressBookController","AddressBookController","alertController","AlertController","threeBoxController","ThreeBoxController","getKeyringControllerState","trackMetaMetricsEvent","trackEvent","txController","TransactionController","TransactionManager","getPermittedAccounts","getProviderConfig","networkStore","txHistoryLimit","signTransaction","createEventFragment","updateEventFragment","finalizeEventFragment","getEventFragmentById","getParticipateInMetrics","participateInMetaMetrics","getEIP1559GasFeeEstimates","fetchGasFeeEstimates","getExternalPendingTransactions","txId","TRANSACTION_STATUSES","CONFIRMED","FAILED","txMeta","txStateManager","getTransaction","getFrequentRpcListDetail","_rpcSettings$rpcPrefs","rpcSettings","rpc","showTransactionNotification","txReceipt","TRANSACTION_TYPES","TOKEN_METHOD_TRANSFER_FROM","txParams","_allCollectibles$user","transactionData","getTransactionData","tokenAmountOrTokenId","getTokenValueParam","allCollectibles","knownCollectible","userAddress","isEqualCaseInsensitive","contractAddress","tokenId","checkAndUpdateSingleCollectibleOwnershipStatus","metamaskState","_txMeta$simulationFai","event","category","properties","action","errorMessage","simulationFails","numberOfTokens","tokens","numberOfAccounts","matomoEvent","setNativeCurrency","lookupNetwork","messageManager","metricsEvent","personalMessageManager","decryptMessageManager","encryptionPublicKeyManager","typedMessageManager","swapsController","getBufferedGasLimit","txGasUtil","getTokenRatesState","smartTransactionsController","getNetwork","getNetworkState","getNonceLock","nonceTracker","confirmExternalTransaction","SmartTransactionsController","_updateAccounts","NETWORK_WILL_CHANGE","clearUnapprovedTxs","clearUnapproved","memState","_onStateUpdate","updateStructure","AccountTracker","TxController","MessageManager","PersonalMessageManager","DecryptMessageManager","EncryptionPublicKeyManager","TypesMessageManager","SwapsController","EnsController","password","PASSWORD","completedOnboarding","submitPassword","getPlatformInfo","setBrowserEnvironment","os","getBrowserInfo","setupControllerEventSubscriptions","publicConfigStore","createPublicConfigStore","handleAccountsChange","origin","newAccounts","notifyConnections","NOTIFICATION_NAMES","accountsChanged","params","updateAccountsHistory","lastSelectedAddress","selectedAddress","permittedAccountsMap","getPermittedAccountsByOrigin","currentValue","previousValue","changedAccounts","getChangedAccounts","providerOpts","static","eth_syncing","web3_clientVersion","getSelectedAddress","processTransaction","newUnapprovedTransaction","processEthSignMessage","newUnsignedMessage","processTypedMessage","newUnsignedTypedMessage","processTypedMessageV3","processTypedMessageV4","processPersonalMessage","newUnsignedPersonalMessage","processDecryptMessage","newRequestDecryptMessage","processEncryptionPublicKey","newRequestEncryptionPublicKey","getPendingNonce","getPendingTransactionByHash","getTransactions","searchCriteria","SUBMITTED","ObservableStore","updatePublicConfigStore","putState","networkVersion","selectPublicState","getProviderNetworkState","vault","isInitialized","getFlatState","getApi","setCurrentCurrency","setUseBlockie","setUseNonceField","setUsePhishDetect","setUseTokenDetection","setUseCollectibleDetection","setOpenSeaEnabled","setIpfsGateway","setParticipateInMetaMetrics","setCurrentLocale","markPasswordForgotten","unMarkPasswordForgotten","safelistPhishingDomain","markNotificationPopupAsAutomaticallyClosed","addNewAccount","verifySeedPhrase","resetAccount","removeAccount","importAccountWithStrategy","connectHardware","forgetDevice","checkHardwareStatus","unlockHardwareWalletAccount","setLedgerTransportPreference","attemptLedgerTransportCreation","establishLedgerTransportPreference","submitQRHardwareCryptoHDKey","submitCryptoHDKey","submitQRHardwareCryptoAccount","submitCryptoAccount","cancelSyncQRHardware","cancelSync","submitQRHardwareSignature","submitSignature","cancelQRHardwareSignRequest","cancelSignRequest","fetchInfoToSync","verifyPassword","setProviderType","rollbackToPreviousProvider","setCustomRpc","updateAndSetCustomRpc","delCustomRpc","setSelectedAddress","addToken","rejectWatchAsset","acceptWatchAsset","updateTokenType","removeToken","removeAndIgnoreToken","setAccountLabel","setFeatureFlag","setPreference","addKnownMethodData","setDismissSeedBackUpReminder","setAdvancedGasFee","setEIP1559V2Enabled","getTokenStandardAndDetails","addCollectibleVerifyOwnership","removeAndIgnoreCollectible","removeCollectible","checkAndUpdateAllCollectiblesOwnershipStatus","isCollectibleOwner","setAddressBook","removeFromAddressBook","delete","setLastActiveTime","setDefaultHomeActiveTabName","setConnectedStatusPopoverHasBeenShown","setRecoveryPhraseReminderHasBeenShown","setRecoveryPhraseReminderLastShown","setShowTestnetMessageInDropdown","setCollectiblesDetectionNoticeDismissed","setEnableEIP1559V2NoticeDismissed","updateCollectibleDropDownState","tryReverseResolveAddress","reverseResolveAddress","createNewVaultAndKeychain","createNewVaultAndRestore","exportAccount","cancelTransaction","updateTransaction","updateAndApproveTransaction","approveTransactionsWithSameNonce","createCancelTransaction","createSpeedUpTransaction","estimateGas","getNextNonce","addUnapprovedTransaction","createTransactionEventFragment","signMessage","cancelMessage","signPersonalMessage","cancelPersonalMessage","signTypedMessage","cancelTypedMessage","decryptMessage","decryptMessageInline","cancelDecryptMessage","encryptionPublicKey","cancelEncryptionPublicKey","setSeedPhraseBackedUp","completeOnboarding","setFirstTimeFlowType","setAlertEnabledness","setUnconnectedAccountAlertShown","setWeb3ShimUsageAlertDismissed","setThreeBoxSyncingPermission","restoreFromThreeBox","setShowRestorePromptToFalse","getThreeBoxLastUpdated","getLastUpdated","turnThreeBoxSyncingOn","initializeThreeBox","removePermissionsFor","revokePermissions","approvePermissionsRequest","acceptPermissionsRequest","rejectPermissionsRequest","getPermissionBackgroundApiMethods","fetchAndSetQuotes","setSelectedQuoteAggId","resetSwapsState","setSwapsTokens","clearSwapsQuotes","setApproveTxId","setTradeTxId","setSwapsTxGasPrice","setSwapsTxGasLimit","setSwapsTxMaxFeePerGas","setSwapsTxMaxFeePriorityPerGas","safeRefetchQuotes","stopPollingForQuotes","setBackgroundSwapRouteState","resetPostFetchState","setSwapsErrorKey","setInitialGasEstimate","setCustomApproveTxData","setSwapsLiveness","setSwapsFeatureFlags","setSwapsUserFeeLevel","setSwapsQuotesPollingLimitEnabled","setSmartTransactionsOptInStatus","setOptInState","fetchSmartTransactionFees","getFees","estimateSmartTransactionsGas","submitSignedTransactions","cancelSmartTransaction","fetchSmartTransactionsLiveness","fetchLiveness","updateSmartTransaction","setStatusRefreshInterval","trackMetaMetricsPage","trackPage","resolvePendingApproval","accept","rejectPendingApproval","updateViewedNotifications","updateViewed","getGasFeeEstimatesAndStartPolling","disconnectGasFeeEstimatePoller","disconnectPoller","getGasFeeTimeEstimate","getTimeEstimate","addPollingTokenToAppState","addPollingToken","removePollingTokenFromAppState","removePollingToken","detectNewTokens","detectCollectibles","releaseLock","acquire","fullUpdate","addresses","setAddresses","selectFirstIdentity","encodedSeedPhrase","lastBalance","seedPhraseAsBuffer","Buffer","from","clearState","clearAccounts","clearCachedBalances","ethQuery","getBalance","primaryKeyring","getKeyringsByType","transportPreference","getLedgerTransportPreference","cached","balance","currentLocale","frequentRpcList","allTokens","allERC20Tokens","accountAddress","checksummedAccountAddress","toChecksumHexAddress","asset","isERC721","hdKeyring","simpleKeyPairKeyrings","hdAccounts","simpleKeyPairAccounts","all","keyring","reduce","acc","hd","item","pos","indexOf","simpleKeyPair","ledger","trezor","lattice","transactions","values","tx","checksummedTxFrom","allIgnoredTokens","checkForLatestBlock","threeBoxSyncingAllowed","getThreeBoxSyncingState","box","init","getPrimaryKeyringMnemonic","mnemonic","deviceName","hdPath","keyringName","DEVICE_NAMES","TREZOR","LEDGER","QR","LATTICE","addNewKeyring","setHdPath","appName","model","getModel","setTrezorModel","getKeyringForDevice","attemptMakeApp","page","getPreviousPage","getNextPage","getFirstPage","oldAccounts","accountsToTrack","concat","syncWithAddresses","getAccountLabel","index","hdPathDescription","toUpperCase","parseInt","trim","setAccountToUnlock","keyState","label","getName","serialized","serialize","verifyAccounts","Array","wipeTransactions","resetConnection","executeRestrictedMethod","eth_accounts","errorCodes","unauthorized","removeAllAccountPermissions","targetAccount","updatePermissionsByCaveat","CaveatTypes","restrictReturnedAccounts","existingAccounts","CaveatMutatorFactories","removeAddress","strategy","args","privateKey","importAccount","allAccounts","req","msgParams","normalizeMsgData","promise","ethErrors","invalidParams","addUnapprovedMessageAsync","info","msgId","metamaskId","cleanMsgParams","approveMessage","rawSig","setMsgStatusSigned","rejectMsg","msg","getMsg","stripped","stripHexPrefix","buff","JSON","parse","toString","rawData","_updateMsg","rawMess","setMsgStatusDecrypted","KEYRING_TYPES","publicKey","getEncryptionPublicKey","setMsgStatusReceived","signature","originalTxId","customGasSettings","newTxMetaProps","estimateGasParams","query","res","setPasswordForgotten","setupUntrustedCommunication","connectionStream","usePhishDetect","_subjectType","subjectType","sender","SUBJECT_TYPES","EXTENSION","WEBSITE","hostname","test","sendPhishingWarning","mux","setupMultiplex","setupProviderConnection","createStream","setupPublicConfig","setupTrustedCommunication","setupControllerConnection","INTERNAL","write","outStream","api","handleUpdate","_writableState","ended","jsonrpc","addSubjectMetadata","extensionId","tab","engine","setupProviderEngine","providerStream","connectionId","addConnection","_middleware","mid","destroy","removeConnection","JsonRpcEngine","filterMiddleware","subscriptionManager","events","push","createMiddleware","location","registerOnboarding","createMethodMiddleware","getProviderState","getUnlockPromise","handleWatchAssetRequest","watchAsset","requestUserApproval","addAndShowApprovalRequest","sendMetrics","getPermissionsForOrigin","getPermissions","hasPermission","requestAccountsPermission","requestPermissions","requestPermissionsForOrigin","addCustomRpc","addToFrequentRpcList","chainName","blockExplorerUrl","findCustomRpcBy","updateRpcTarget","setRpcTarget","getWeb3ShimUsageState","setWeb3ShimUsageRecorded","middleware","createPermissionMiddleware","providerAsMiddleware","configStream","storeAsStream","removeAllConnections","payload","conn","notifyAllConnections","getPayload","keyrings","syncAddresses","unlockStateChanged","newState","isClientOpenAndUnlocked","_isClientOpen","chainChanged","addressFrom","nonceDetails","pendingNonce","highestSuggested","nonceLock","nextNonce","oldChainId","newChainId","duplicate","addressBook","entry","memo","updateRpc","removeFromFrequentRpcList","rpcInfo","existingRpcInfo","transportType","newValue","updateTransportMethod","catch","firstTimeInfo","date","Date","now","isClientOpen","open","isOpen","onClientClosed","stopPolling","clearPollingTokens","onEnvironmentTypeClosed","environmentType","appStatePollingTokenType","POLLING_TOKEN_ENVIRONMENT_TYPES","pollingToken","bypass","trezorKeyring","dispose","func","wait","timeout","context","timestamp","later","last","setTimeout","apply","debounced","arguments","callNow","clear","clearTimeout","flush","Stream","end","destroyed","buffer","_ended","stream","drain","paused","shift","_end","writable","readable","autoDestroy","nextTick","pause","resume","writeMethods","readMethods","readEvents","arr","fn","i","writer","reader","methodName","reemit","unshift","stream_1","ObservableStoreStream","Duplex","obsStore","handler","pipe","dest","_encoding","_read","_size","_destroy","unsubscribe","MergedStore","ObservableStore_1","children","_children","child","_addChild","_updateWholeState","childStates","assign","ComposedStore","childKey","updateFromChild","childValue","LocalStorageStore","global","localStorage","storageKey","_storageKey","_getState","getItem","_putState","stringify","setItem","__importDefault","mod","__esModule","safe_event_emitter_1","updateState","partialState","storeTransformStream","through2_1","syncTransformFn","originalVersionedData","rpcTarget","merge","ShapeShiftController","shapeShiftTxList","transformState","stack","currentCurrency","currentFiat","fiatCurrency","conversionRate","conversionDate","retryCount","walletNicknames","accountTokens","identity","mainnet","REJECTED","UNAPPROVED","featureFlags","privacyMode","SAI_TOKEN_SYMBOL","isOldDai","token","symbol","isArray","networkTokens","tokensOnNetwork","accountHiddenTokens","newAccountTokens","newAccountHiddenTokens","NETWORK_TYPE_RPC","detail","providerType","MAINNET","ROPSTEN","ROPSTEN_CHAIN_ID","RINKEBY","RINKEBY_CHAIN_ID","GOERLI","GOERLI_CHAIN_ID","KOVAN","KOVAN_CHAIN_ID","betaUI","completedUiMigration","_state$AppStateContro","mkrMigrationReminderTimestamp","autoLockTimeLimit","autoLogoutTimeLimit","_state$PreferencesCon","outdatedGateways","submittedTime","getTime","connectedStatusPopoverHasBeenShown","NoticeController","migratedPrivacyMode","_state$TransactionCon","transaction","metamaskNetworkId","swapsWelcomeMessageHasBeenShown","isPlainObject","nonceNetworkGroupedObject","groupBy","_tx$txParams","_tx$chainId","nonce","withoutOrphans","pickBy","group","some","CANCEL","RETRY","keyBy","account","chain","assetImages","LEGACY_LOCAL_STORAGE_KEYS","_window$localStorage","removeItem","ABTestController","ProviderApprovalController","_state$NetworkControl","_NETWORK_TYPE_TO_ID_M","enumChainId","NETWORK_TYPE_TO_ID_MAP","currentTime","recoveryPhraseReminderHasBeenShown","recoveryPhraseReminderLastShown","Number","isNaN","reverseTxList","reverse","stripping","txIndex","findIndex","DROPPED","splice","whiteList","addHexPrefix","to","gas","gasPrice","normalizedTxParams","normalizeTxParams","txList","highestConfirmedNonce","nonces","getHighestNonce","highestContinuousNonce","startPoint","highest","getHighestContinuousFrom","maxNonce","note","_state$IncomingTransa","incomingTxLastFetchedBlocksByNetwork","incomingTxLastFetchedBlockByChainId","mapKeys","_NETWORK_TYPE_TO_ID_M2","UNKNOWN_CHAIN_ID_KEY","metaMetricsSendCount","isValidDecimals","decimals","match","validTokens","validTokensOnNetwork","_state$MetaMetricsCon","metaMetricsId","SUPPORT_NOTIFICATION_DATE","_state$NotificationCo","notifications","_notifications$SUPPOR","SENT_ETHER","SIMPLE_SEND","history","txEvent","currentAccountTab","TOSHash","isDisclaimerConfirmed","safeVersionedData","seedWords","_state$SubjectMetadat","subjectMetadata","metadata","BlacklistController","RecentBlocks","_state$OnboardingCont","firstTimeFlowType","noticesList","notice","read","body","metamask","ab","chainIds","newAddressBook","v","add","isEns","util","normalizeEnsName","ABTestControllerState","abTests","fullScreenVsPopup","_failTx","isApproved","APPROVED","createdTime","_randomId","selectedAccount","selectSubstateForKeyringController","gasMultiplier","_state$NetworkControl2","_state$NetworkControl3","_state$CachedBalances","_state$AddressBookCon","_state$IncomingTransa2","settings","chainIdRegEx","_state$NetworkControl4","_state$NetworkControl5","cachedBalances","hexRegEx","networkKey","networkEntries","updateChainIds","chainIdKey","networkKeyEntries","newEntries","mergedEntry","_networkKeyEntries$ad","mergeAddressBookKeys","localhost","_accountTokens$accoun","_accountTokens$accoun2","localhostTokens","rpcTokens","localhostTokensMap","tokenArrayToMap","rpcTokensMap","mergedTokens","tokenAddress","array","mergeTokenArrays","_state$PreferencesCon2","_state$PreferencesCon3","_state$PreferencesCon4","_state$PreferencesCon5","_state$PreferencesCon6","_state$PreferencesCon7","_state$PreferencesCon8","newAllTokens","tokensArray","newAllIgnoredTokens","ignoredTokensArray","hiddenTokens","suggestedTokens","defaultTransportType","navigator","hid","LEDGER_TRANSPORT_TYPES","WEBHID","U2F","useLedgerLive","ledgerTransportType","LIVE","PermissionsController","PermissionsMetadata","remainingState","_objectWithoutProperties2","_excluded","domainMetadata","permissionsHistory","permissionsLog","getPermissionControllerState","permissionActivityLog","permissionHistory","getSubjectMetadataControllerState","domains","subjects","transformed","domainEntry","permissions","ethAccountsPermission","oldCaveat","caveats","caveat","newPermission","icon","other","_excluded2","lastUpdated","host","iconUrl","incomingTransactions","transactionCategory","INCOMING","_bignumber","hexNumberIsGreaterThanZero","hexNumber","gt","showTestNetworks","userIsCurrentlyOnATestNet","TEST_CHAINS","userHasMadeATestNetTransaction","userHasACachedBalanceOnATestnet","userHasUsedATestnet","keyringSubstate","migrateState","_txStateHistoryHelpers","snapshot","snapshotFromTxMeta","newHistory","migrateFromSnapshotsToDiffs","toDataView","variant","alphabet","defaultPadding","view","bits","byteLength","getUint8","eth","_ethjsQuery","_ethEnsNamehash","contract","_ethjsContract","net_version","registryAddress","getRegistryForChainId","Registry","_registry","at","resolverAddress","resolver","hexValueIsEmpty","Resolver","isEIP1577Compliant","supportsInterface","isLegacyResolver","rawContentHash","contenthash","decodedContentHash","_contentHash","decode","getCodec","helpers","cidV0ToV1Base32","content","next","crypto","self","msCrypto","size","bytes","getRandomValues","Uint8Array","methodNotFound","serializeError","shouldIncludeStack","DuplexStream","handle","TAB_ID_NONE","ComposableObservableStore","removeAllListeners","updatedState","getPersistentState","flatState","controller","_metamaskController","unapprovedMsgs","unapprovedMsgCount","messages","getUnapprovedMsgs","addUnapprovedMessage","once","userRejectedRequest","time","msgData","MESSAGE_TYPE","ETH_SIGN","addMsg","_saveMsgList","setMsgStatusApproved","prepMsgForSigning","_setMsgStatus","METAMASK_CONTROLLER_EVENTS","bufferToHex","onboardingTabs","seedPhraseBackedUp","newSeedPhraseBackUpState","hexRe","unapprovedPersonalMsgs","unapprovedPersonalMsgCount","PERSONAL_SIGN","createdAccounts","seedPhrase","getKeyringClassForType","restoredAccounts","_web","_singleCallBalanceCheckerAbi","_contracts","DEFAULT_INTERVAL","MINUTE","_this$preferences","_this$tokensControlle","_this$tokensControlle2","tokenAddresses","ignoredTokens","restartTokenDetection","ethContract","web3","SINGLE_CALL_BALANCES_ADDRESS","balances","isActive","_tokenList","tokensToDetect","setProvider","_provider","sliceOfTokensToDetect","tokensSlice","_getTokenBalances","tokensWithBalance","isZero","_handle","clearInterval","setInterval","_keyringMemStore","_registerUpdates","balancesToCache","_generateBalancesToCache","currentChainBalancesToCache","accountID","updateCachedBalances","isMetamaskInternal","_pubnub","defaultCaptureException","exceptionsToFilter","_captureException","prefState","abandonedFragments","omitBy","fragments","abandoned","generateMetaMetricsId","keccak","String","round","random","MAX_SAFE_INTEGER","_options$uniqueIdenti","successEvent","uniqueIdentifier","generateUUID","initialEvent","sensitiveProperties","referrer","revenue","currency","_fragment$referrer","eventName","failureEvent","_buildContext","METAMETRICS_BACKGROUND_PAGE_OBJECT","app","userAgent","_buildEventPayload","rawPayload","_properties$network","_properties$chain_id","ENVIRONMENT_TYPE_BACKGROUND","omit","chain_id","environment_type","_track","_options$excludeMetaM","isOptIn","metaMetricsIdOverride","flushImmediately","idType","idValue","excludeMetaMetricsId","METAMETRICS_ANONYMOUS_ID","legacy_event","track","safeError","isOptInPath","idTrait","validatePayload","submitEvent","combinedProperties","unapprovedDecryptMsgs","unapprovedDecryptMsgCount","ETH_DECRYPT","prepMsgForDecryption","_alerts","defaultState","alertEnabledness","TOGGLEABLE_ALERT_TYPES","alertType","unconnectedAccountAlertShownOrigins","web3ShimUsageOrigins","alertId","enabledness","_setWeb3ShimUsageState","WEB3_SHIM_USAGE_ALERT_STATES","RECORDED","DISMISSED","_bn","etherscanSupportedNetworks","previousValueComparator","comparator","initialValue","cache","first","_onLatestBlock","newBlockNumberDec","newBlockNumberHex","_update","prevState","currState","showIncomingTransactions","prevShowIncomingTransactions","currShowIncomingTransactions","prevSelectedAddress","currSelectedAddress","_ref","currentState","currentBlock","getCurrentBlock","mostRecentlyFetchedBlock","blockToFetchFrom","newIncomingTxs","_getNewIncomingTransactions","newMostRecentlyFetchedBlock","blockNumber","fromBlock","CHAIN_ID_TO_TYPE_MAP","remoteTxList","remoteTxs","_normalizeTxFromEtherscan","_tx$txParams$to","etherscanTransaction","timeStamp","isError","bnToHex","maxFeePerGas","maxPriorityFeePerGas","CHAIN_ID_TO_NETWORK_ID_MAP","unapprovedEncryptionPublicKeyMsgs","unapprovedEncryptionPublicKeyMsgCount","ETH_GET_ENCRYPTION_PUBLIC_KEY","prepMsgForEncryptionPublicKey","timeoutMinutes","defaultHomeActiveTabName","browserEnvironment","popupGasPollTokens","notificationGasPollTokens","fullScreenGasPollTokens","collectiblesDetectionNoticeDismissed","enableEIP1559V2NoticeDismissed","showTestnetMessageInDropdown","trezorModel","qrHardware","collectiblesDropdownState","timer","waitingForUnlock","handleUnlock","_showUnlockRequest","_setInactiveTimeout","shouldShowUnlockRequest","waitForUnlock","lastShown","_resetTimer","browser","pollingTokenType","_assert","_ethSigUtil","_jsonschema","TypedMessageManager","_getCurrentChainId","unapprovedTypedMessages","unapprovedTypedMessagesCount","validateParams","ETH_SIGN_TYPED_DATA","strict","isValidHexAddress","allowNonPrefixed","doesNotThrow","typedSignatureHash","equal","validation","validate","TYPED_MESSAGE_SCHEMA","primaryType","errors","domain","activeChainId","startsWith","fail","_punycode","ens","ensResolutionsByAddress","getNetworkEnsSupport","_reverseResolveAddress","registeredAddress","lookup","_updateResolutionsByAddress","toASCII","oldState","_caveatMutators","_backgroundApi","_enums","_permissionLog","_specifications","_selectors","_humanStandardTokenAbi","_common","_tx","_ethers","_nonceTracker","_cleanErrorStack","_errorKeys","_gas","_conversion","_transaction2","_contractUtils","_util2","_txStateManager","_txGasUtils","_pendingTxTracker","txUtils","hstInterface","ethers","utils","Interface","SWAP_TRANSACTION_TYPES","SWAP","SWAP_APPROVAL","METRICS_STATUS_FAILED","_getCurrentNetworkEIP1559Compatibility","_getCurrentAccountEIP1559Compatibility","signEthTx","inProcessOfSigning","_trackMetaMetricsEvent","_getParticipateInMetrics","_getEIP1559GasFeeEstimates","_mapMethods","_onBootCleanUp","getPendingTransactions","getConfirmedTransactions","pendingTxTracker","publishTransaction","rawTx","sendRawTransaction","getApprovedTransactions","approveTransaction","getCompletedTransactions","_setupListeners","_updateMemstore","_updatePendingTxsAfterFirstBlock","integerChainId","fromAddress","currentNetworkIsCompatible","fromAccountIsCompatible","hardfork","HARDFORKS","LONDON","BERLIN","networkId","customChainParams","forCustomChain","addTransaction","_trackTransactionMetricsEvent","TRANSACTION_EVENTS","ADDED","initialTxMeta","finishedTxMeta","internal","transactionType","eip1559Compatibility","validateTxParams","generateTxMeta","getCodeResponse","_determineTransactionType","addTxGasDefaults","loadingDefaults","TRANSACTION_ENVELOPE_TYPES","LEGACY","defaultGasPrice","defaultMaxFeePerGas","defaultMaxPriorityFeePerGas","_getDefaultGasFees","gasLimit","defaultGasLimit","_getDefaultGasLimit","eip1559V2Enabled","advancedGasFeeDefaultValues","getAdvancedGasFee","userFeeLevel","CUSTOM_GAS_ESTIMATE","decGWEIToHexWEI","maxBaseFee","priorityFee","GAS_RECOMMENDATIONS","MEDIUM","PRIORITY_LEVELS","DAPP_SUGGESTED","originalGasEstimate","defaultGasEstimates","estimateType","gasFeeEstimates","gasEstimateType","GAS_ESTIMATE_TYPES","FEE_MARKET","medium","suggestedMaxPriorityFeePerGas","suggestedMaxFeePerGas","ETH_GASPRICE","customNetworkGasBuffer","CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP","chainType","getChainType","errorKey","TRANSACTION_NO_CONTRACT_ERROR_KEY","GAS_LIMITS","SIMPLE","blockGasLimit","estimatedGasHex","analyzeGasUsage","addGasBuffer","generateNewGasParams","originalTxMeta","incrementNumerator","previousGasParams","newGasParams","_customGasSettings$ga","estimateSuggested","estimateUsed","isEIP1559Transaction","BnMultiplyByFraction","hexToBn","estimatedBaseFee","newTxMeta","has","setTxStatusApproved","customNonceValue","customOrNonce","_failTransaction","err2","listOfTxParams","initialTx","common","getCommonConfiguration","initialTxAsEthTx","TransactionFactory","fromTxData","initialTxAsSerializedHex","rawTxes","signExternalTransaction","_txParams","decimalToHex","unsignedEthTx","signedEthTx","r","s","setTxStatusSigned","preTxBalance","txHash","toBuffer","setTxHash","setTxStatusSubmitted","baseFeePerGas","blockTimestamp","gasUsed","normalizeTxReceiptGasUsed","setTxStatusConfirmed","_markNonceDuplicatesDropped","metricsParams","gas_used","completion_time","_getTransactionCompletionTime","FINALIZED","postTxBalance","latestTxMeta","approvalTxMeta","approvalTxId","_trackSwapsMetrics","addExternalTransaction","setTxStatusRejected","transactionId","_buildEventFragmentProperties","_createTransactionEventFragment","getUnapprovedTxCount","getUnapprovedTxList","getPendingTxCount","advancedGasFee","getLatestBlock","updatePendingTxs","then","txSignError","_setupBlockTrackerListener","transactionReceipt","confirmTransaction","_dropTransaction","latestBlockNumber","firstRetryBlockNumber","parseTransaction","tokenMethodName","TOKEN_METHOD_APPROVE","TOKEN_METHOD_TRANSFER","contractCode","DEPLOY_CONTRACT","resultCode","isContractAddress","readAddressAsContract","CONTRACT_INTERACTION","sameNonceTxs","otherTxMeta","replacedBy","listenersAreActive","latestBlockHandler","updateSubscription","pendingTxs","resubmitPendingTxs","unapprovedTxs","currentNetworkTxList","limit","swapMetaData","tokensReceived","getSwapsTokensReceivedFromTxMeta","destinationTokenSymbol","destinationTokenAddress","destinationTokenDecimals","quoteVsExecutionRatio","div","token_to_amount","times","estimatedVsUsedGasRatio","estimated_gas","token_to_amount_received","quote_vs_executionRatio","estimated_vs_used_gasRatio","extraParams","source","gasParams","max_fee_per_gas","max_priority_fee_per_gas","gas_price","default_estimate","LOW","HIGH","_gasFeeEstimates$esti","_gasFeeEstimates$esti3","_gasFeeEstimates$esti2","_gasFeeEstimates$esti4","default_max_fee_per_gas","default_max_priority_fee_per_gas","default_gas","default_gas_price","estimate_suggested","estimate_used","gasParamsInGwei","_getGasValuesInGWEI","eip1559Version","eip_1559_version","gas_edit_type","gas_edit_attempted","transaction_envelope_type","TRANSACTION_ENVELOPE_TYPE_NAMES","first_seen","gas_limit","gasValuesInGwei","param","isHexString","hexWEIToDecGWEI","setTxStatusFailed","setTxStatusDropped","_analyticsNode","isDevOrTestEnvironment","METAMASK_DEBUG","SEGMENT_WRITE_KEY","SEGMENT_HOST","_process$env$SEGMENT_2","SEGMENT_FLUSH_INTERVAL","createSegmentMock","flushAt","segmentMock","identify","flushInterval","_ethereumjsWallet","_thirdparty","privateKeyHex","importer","strategies","prefixed","isValidPrivate","wallet","fromEtherWallet","fromV3","privateKeyBuffer","getPrivateKey","walletToPrivateKey","_send","_swaps3","_fetchWithCache","MAX_GAS_LIMIT","FALLBACK_QUOTE_REFRESH_TIME","FALLBACK_SMART_TRANSACTION_REFRESH_TIME","calculateGasEstimateWithRefund","maxGas","estimatedRefund","estimatedGas","maxGasMinusRefund","minus","lt","initialState","swapsState","quotes","quotesPollingLimitEnabled","fetchParams","tradeTxId","approveTxId","quotesLastFetched","customMaxGas","customGasPrice","customMaxFeePerGas","customMaxPriorityFeePerGas","swapsUserFeeLevel","selectedAggId","customApproveTxData","topAggId","routeState","swapsFeatureIsLive","saveFetchedQuotes","swapsQuoteRefreshTime","swapsQuotePrefetchingRefreshTime","swapsStxBatchStatusRefreshTime","swapsStxGetTransactionsRefreshTime","swapsFeatureFlags","getMedianEthValueQuote","_quotes","quoteA","quoteB","overallValueOfQuoteA","overallValueOfQuote","overallValueOfQuoteB","equals","lessThan","medianOverallValue","meansOfQuotesFeesAndValue","quote","upperIndex","lowerIndex","overallValueAtUpperIndex","overallValueAtLowerIndex","quotesMatchingUpperIndexValue","quotesMatchingLowerIndexValue","feesAndValueAtUpperIndex","feesAndValueAtLowerIndex","ethFee","plus","dividedBy","metaMaskFeeInEth","ethValueOfTokens","feeAndValueSumsAsBigNumbers","feeAndValueSums","fetchTradesInfo","_fetchTradesInfo","pollCount","indexOfNewestCallInFlight","ethersProvider","providers","Web3Provider","_currentNetwork","getBaseApi","cacheRefreshTime","refreshRates","quotesPrefetching","stxGetTransactions","stxBatchStatus","stxStatusDeadline","_swapsRefreshRates","_swapsRefreshRates2","_swapsRefreshRates3","_swapsRefreshRates4","_swapsRefreshRates5","swapsRefreshRates","fetchSwapsRefreshRates","latestSwapsState","swapsStxStatusDeadline","pollForNewQuotes","quotesRefreshRateInMs","pollingTimeout","_swapsState$fetchPara","metaData","fetchParamsMetaData","isPolledRequest","indexOfCurrentCall","setSaveFetchedQuotes","newQuotes","_setSwapsRefreshRates","saveFetchedQuotesAfterResponse","mapValues","sourceTokenInfo","destinationTokenInfo","approvalRequired","isSwapsDefaultTokenAddress","sourceToken","allowance","_getERC20Allowance","firstQuote","approvalNeeded","eq","aggregator","approvalGas","timedoutGasReturn","DEFAULT_ERC20_APPROVE_GAS","balanceError","getAllQuotesWithGasEstimates","QUOTES_NOT_AVAILABLE_ERROR","_topAggId","quotesWithSavingsAndFeeData","_findTopQuoteAndCalculateSavings","SWAPS_FETCH_ORDER_CONFLICT","POLL_COUNT_LIMIT","QUOTES_EXPIRED_ERROR","quoteGasData","trade","aggId","gasEstimateWithRefund","gasEstimate","tradeTxParams","gasTimedOut","gasTimeout","tradeTxParamsForGasEstimate","initialAggId","quoteToUpdate","newGasEstimate","setQuotesLastFetched","swapsLiveness","contractExchangeRates","tokenConversionRates","usedGasPrice","high","addCurrencies","aBase","bBase","toNumericBase","numberOfDecimals","overallValueOfBestQuoteForSorting","averageGas","destinationAmount","destinationToken","sourceAmount","fee","metaMaskFee","totalGasLimitForCalculation","gasTotalInWeiHex","calcGasTotal","totalWeiCost","totalEthCost","conversionUtil","fromCurrency","fromDenomination","toDenomination","fromNumericBase","decimalAdjustedDestinationAmount","calcTokenAmount","tokenPercentageOfPreFeeDestAmount","metaMaskFeeInTokens","tokenConversionRate","conversionRateForSorting","conversionRateForCalculations","overallValueOfQuoteForSorting","savings","_newQuotes$topAggId","bestQuote","medianEthFee","medianMetaMaskFee","medianEthValueOfTokens","performance","total","isBestQuote","walletAddress","Contract","SWAPS_CHAINID_CONTRACT_ADDRESS_MAP","EventEmitter","HDKey","ethUtil","sigUtil","pathBase","NETWORK_API_URLS","ropsten","kovan","rinkeby","LedgerBridgeKeyring","accountDetails","bridgeUrl","perPage","unlockedAccount","hdk","paths","iframe","implementFullBIP44","deserialize","iframeLoaded","_setupIframe","_migrateAccountDetails","toChecksumAddress","_isLedgerLiveHdPath","accountIndexes","bip44","_getPathForIndex","_pathFromAddress","log","unlock","_toLedgerPath","_sendMessage","success","chainCode","addAccounts","n","_addressFromIndex","__getPage","delayedPromise","rawTxHex","_signTransaction","messageToSign","getMessageToSign","isBuffer","rlp","encode","txData","toJSON","freeze","isFrozen","handleSigning","unlockAccountByAddress","newOrMutatedTx","verifySignature","withAccount","addressSignedWith","recoverPersonalSignature","sig","checksummedAddress","isV4","TypedDataUtils","sanitizeData","domainSeparatorHex","hashStruct","hashStructMessageHex","recoverTypedSignature_v4","document","createElement","src","allow","onload","head","appendChild","_getOrigin","tmp","join","contentWindow","postMessage","eventListener","removeEventListener","addEventListener","increment","_getAccountsBIP44","_getAccountsLegacy","valid","_hasPreviousTransactions","_padLeftEven","hex","_normalize","buf","dkey","derive","publicToAddress","_toAscii","str","l","substring","substr","fromCharCode","apiUrl","_getApiUrl","fetch","parsedResponse","BN","SDK","EthTx","Common","Util","keyringType","SDK_TIMEOUT","LatticeKeyring","_resetDefaults","creds","accountIndices","accountOpts","walletUID","sdkState","sdkSession","getStateData","_getCurrentWalletUID","bypassOnStateData","forceReconnect","_getCreds","deviceID","endpoint","_initSession","includedStateData","_connect","_fetchAddresses","addrs","addr","alreadySaved","j","_findSignerIdx","accountIdx","addressIdx","addressParentPath","_getEthereumJsChainId","signerPath","_getHDPathIndices","_type","accessList","forceLegacyTx","fwVersion","revertToLegacy","_signTxData","signedTx","txToReturn","validatingTx","_chainId","toNumber","customNetwork","protocol","signTypedData","sign","_syncCurrentWalletUID","_getPage","_ensureCurrentWalletUID","insertIdx","indices","usedX","_idx","isHardened","idx","isLocked","_openConnectorTab","browserTab","chromium","firefox","_findTabById","_hasCreds","base","listenInterval","receiveMessage","closed","loginUrlParam","paramLoc","dataLoc","_creds","connect","setupData","stateData","baseUrl","privKey","_genSessionKey","Client","recursedAddrs","__fetchAddresses","shouldRecurse","_hdPathHasInternalVarIdx","addrData","startPath","skipCache","getAddresses","createHash","digest","chainIdBN","activeWallet","getActiveWallet","uid","newUID","SmartTransactionsController_1","_network3","useBlockie","useNonceField","dismissSeedBackUpReminder","useCollectibleDetection","openSeaEnabled","knownMethodData","lostIdentities","forgottenPassword","showFiatInTestnets","useNativeCurrencyAsPrimaryCurrency","hideZeroBalanceTokens","IPFS_DEFAULT_GATEWAY_URL","infuraBlocked","setMaxListeners","_subscribeToInfuraAvailability","val","fourBytePrefix","methodData","textDirection","oldIdentities","ids","oldId","selected","addAddresses","identityCount","newlyLost","_address","normalize","selectedIdentity","lastSelected","newRpcDetails","rpcList","element","rpcDetail","updatedRpc","addressBookKey","send","builtInProviderNetworkIds","otherRpcEntries","isPrefixedFormattedHexString","feature","activated","updatedFeatureFlags","preference","updatedPreferences","getPreferences","INFURA_IS_BLOCKED","_setInfuraBlocked","INFURA_IS_UNBLOCKED","isBlocked","currentBlockGasLimit","_query","_blockTracker","_currentBlockNumber","_updateForBlock","locals","accountsToAdd","upstream","accountsToRemove","getBlockByNumber","_updateAccountsViaBalanceChecker","SINGLE_CALL_BALANCES_ADDRESS_RINKEBY","SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN","SINGLE_CALL_BALANCES_ADDRESS_KOVAN","_updateAccount","deployedContractAddress","TrezorConnect","transformTypedData","hdPathString","ALLOWED_HD_PATHS","DELAY_BETWEEN_POPUPS","TREZOR_CONNECT_MANIFEST","email","appUrl","ms","isOldStyleEthereumjsTx","TrezorKeyring","features","manifest","getPublicKey","coin","ethereumSignTransaction","getSenderAddress","ethereumSignMessage","dataWithHashes","EIP712Domain","otherTypes","domain_separator_hash","message_hash","ethereumSignTypedData","metamask_v4_compat","_createMethodMiddleware","_migrator","_migrations","_createMetamaskMiddleware","Box","_createProvider","getAppKeyAddress","withAppKeyOrigin","showRestorePrompt","threeBoxLastUpdated","threeBoxAddress","threeBoxSynced","threeBoxDisabled","registeringUpdates","new3Box","space","private","metamaskMiddleware","providerFromEngine","_waitForOnSyncDone","onSyncDone","backupExists","threeBoxConfig","getConfig","spaces","timedOut","syncTimeout","openBox","openSpace","stateUpdate","backedUpState","migrator","formattedStateBackup","initialMigrationState","migratedState","migrateData","migrateBackedUpState","turnThreeBoxSyncingOff","logout","newThreeboxSyncingState","updatePreferences","_update3Box","updateAddressBook","events_1","safeApply","Reflect","SafeEventEmitter","doError","er","len","listeners","copy","arrayClone","Transform","inherits","xtend","DestroyableTransform","_destroyed","noop","enc","through2","construct","transform","t2","_transform","_flush","ctor","Through2","override","highWaterMark","condition","longHistory","generateHistoryEntry","_shortHistory","_fastJsonPatch","applyPatch","newDocument","shallow","previousState","compare","Int8Array","Uint8ClampedArray","DataView","byteOffset","ArrayBuffer","TypeError"],"mappings":"wTA8JwC,0DAQU,CAChDA,KAAM,sBACNC,MAAO,qBACPC,IAAK,mDAmBkC,gEAEvC,2TCrLmB,CACnBC,OAAQ,GACRC,sBAAuB,CACrBC,sBAAuB,CACrB,CACEC,OAAQ,wBACRC,QAAS,QACTC,OAAQ,MACRC,SAAU,iBACVC,SAAU,gSCIH,SAAyBC,GAEtC,OAAOC,GADW,EAAAC,EAAAC,WAAUH,IACDI,GACR,OAAVA,EAAiB,cAAgBA,KAzB5C,IAAAF,EAAAG,EAAA,UAqCA,SAASJ,EAAQK,EAAS,GAAIC,GAQ5B,OAPAC,OAAOC,QAAQH,GAAQI,SAAQ,EAAEC,EAAKP,MAElCE,EAAOK,GADY,iBAAVP,GAAgC,OAAVA,EACjBH,EAAQG,EAAOG,GAEfA,EAAMH,MAGjBE,uPC7CT,IAAAM,EAAAP,EAAA,WACAQ,EAAAR,EAAA,YACAS,EAAAT,EAAA,YAEAU,EAAAC,QAEA,SAAAC,EAAAC,GACA,IACAC,EAAAP,EAAAE,GAKA,SAAAM,GACAC,EAAAC,MAAAF,KAPAH,GAAA,IACAC,IACAG,EAAAT,IAEA,OAAAC,EAAAM,EAAAE,mbCXA,IAAAE,EAAAC,EAAAnB,EAAA,kBACAoB,EAAAD,EAAAnB,EAAA,aACAqB,EAAArB,EAAA,oBAKe,MACbsB,cACEC,KAAKC,YAAcC,QAAQP,EAAAQ,QAAUC,QAAQC,OACxCL,KAAKC,aACRJ,EAAAM,QAAIG,MAAM,oCASLC,YACP,IAAKP,KAAKC,YACR,OAAOO,UAET,MAAMC,QAAeT,KAAKU,OAG1B,OAgEatC,EAhEDqC,EAiEqB,IAA5B7B,OAAO+B,KAAKvC,GAAKwC,OAhEbJ,UAEFC,EA6DX,IAAiBrC,EApDNmC,UAACM,GACR,OAAOb,KAAKc,KAAKD,GASnBH,OACE,MAAML,MAAEA,GAAUV,EAAAQ,QAAUC,QAC5B,OAAO,IAAIW,SAAQ,CAACC,EAASC,KAC3BZ,EAAMa,IAAI,MAA0BT,IAClC,MAAMU,GAAM,EAAArB,EAAAsB,iBACRD,EACFF,EAAOE,GAEPH,EAAQP,SAahBK,KAAK1C,GACH,MAAMiC,MAAEA,GAAUV,EAAAQ,QAAUC,QAC5B,OAAO,IAAIW,SAAQ,CAACC,EAASC,KAC3BZ,EAAMgB,IAAIjD,GAAK,KACb,MAAM+C,GAAM,EAAArB,EAAAsB,iBACRD,EACFF,EAAOE,GAEPH,kbCvDKT,iBACb,IAAIe,EAEJ,IACEA,QAAiCC,IACjC,MAAOC,GAEPF,EAA2B,GAKxBA,IACHA,EAA2B,IAG7B,IAAIG,EAAyBH,EAC1BI,KAAKC,GAASA,EAAKC,cAAcC,QAAQ,IAAK,OAC9CC,MACEH,GACCI,EAAoBJ,KAAUnB,WAC9BuB,EAAoBJ,EAAKK,MAAM,KAAK,MAAQxB,YAOhDiB,IAA2BjB,WAC3BuB,EAAoBN,KAA4BjB,YAEhDiB,EAAyBA,EAAuBO,MAAM,KAAK,IAG7D,OAAOD,EAAoBN,IAA2B,MAzDxD,IAAA9B,EAAAC,EAAAnB,EAAA,kBACAwD,EAAArC,EAAAnB,EAAA,SACAyD,EAAAtC,EAAAnB,EAAA,8BAEA,MAAM8C,EAAsB5B,EAAAQ,QAAUgC,MAClC,EAAAF,EAAA9B,SAAUR,EAAAQ,QAAUgC,KAAKC,mBAAoB,CAAEC,YAAY,IAC3D9B,SAAY,GAGVwB,EAAsB,GAC5BG,EAAA/B,QAAWrB,SAASwD,IACdA,GAAUA,EAAOX,OACnBI,EAAoBO,EAAOX,KAAKC,cAAcC,QAAQ,IAAK,MACzDS,EAAOX,oeCGE,SAA0BY,EAAcC,GACrD,OAAO,IAAIC,EAAoBF,EAAcC,wDAjB/CE,EAAAjE,EAAA,mBACAkE,EAAA/C,EAAAnB,EAAA,sPAEA,MAAMgE,UAA4BC,EAAAE,SAChC7C,YAAYwC,EAAcC,GACxB,MAAMK,6WAAIC,CAAA,CAAKC,YAAY,GAASP,GACpCQ,MAAMH,GACN7C,KAAKiD,cAAgBV,EAIvBW,OAAOC,EAAOC,EAAUC,IACtB,EAAAV,EAAAxC,SAAkBH,KAAKiD,cAAcE,EAAOC,GAA5C,CAAuDC,kkBCZ3DxD,EAAAD,EAAAnB,EAAA,aACA6E,EAAA7E,EAAA,kCAGA,MAAM8E,GAAmB,EAFzB3D,EAAAnB,EAAA,+CAEyB0B,SAA6B,GAATmD,EAAAE,kBAS9B,MACbzD,eAAc,EAAA0D,EAAAtD,SAAAH,KAAA,eASA,GARZA,KAAK0D,cAAe,EACpB1D,KAAK2D,cAAgB3D,KAAK4D,QAC1B5D,KAAK6D,OAASrD,UAWLD,cACT,IACE,MAAMuD,QAAiBP,EAtBD,qCAuBlBO,EAASC,KACX/D,KAAK6D,aAAeC,EAASE,QAE/B,MAAO1D,GACPT,EAAAM,QAAI8D,MAAO,iCAAgC3D,EAAM4D,YANnD,QAQElE,KAAK0D,cAAe,GASfnD,YAIP,OAHKP,KAAK0D,oBACF1D,KAAK2D,cAEN3D,KAAK6D,OASLtD,UAACM,GACHb,KAAK0D,oBACF1D,KAAK2D,cAEb3D,KAAK6D,OAAShD,6cC/DlB,IAAAsD,EAAAvE,EAAAnB,EAAA,uBACA2F,EAAAxE,EAAAnB,EAAA,2BAEA,MAGa4F,EAA8B,CACzCC,aAAc,iDAMD,MAAMC,UAA4BJ,EAAAhE,QAC/CJ,cACEiD,QACAhD,KAAKwE,SAAW,IAAIJ,EAAAjE,QACpBH,KAAKwE,SAASC,qBAAqBzE,KAAK0E,gBAAgBC,KAAK3E,OAS/D4E,4BACE5E,KAAK6E,2BAA4B,EAQpBtE,kBACb,MAAMuE,QAAc9E,KAAK+E,YAGzB,GAAID,QAEI9E,KAAKwE,SAASQ,YAAYF,EAAMG,QACjC,CACL,IAAIC,EAAO,EACPC,EAAM,EACV,IACE,MAAMC,QAAoBpF,KAAKwE,SAASa,uBAExCF,EAAMC,EAAYD,IAClBD,EAAOE,EAAYF,MAAQE,EAAYE,MA7CpB,KA8CnB,MAAOC,GAIP,MAAMC,QAAEA,EAAFC,QAAWA,EAAXC,WAAoBA,GAAeC,OACzCR,EAAMS,KAAKC,IAAIJ,EAAS,GACxBP,EAAOU,KAAKC,IAAIL,GAAWE,EApDR,KAoD0C,GAI/D,MAAMI,QAAoB9F,KAAKwE,SAASuB,WAAW,CACjDpI,IAAK,oBACLqI,KAAM,QACNV,MA3DmB,IA4DnBW,OA7DoB,IA8DpBf,KAAAA,EACAC,IAAAA,IAIEW,EAAYZ,OAASA,GAA8B,eAAtBY,EAAYjF,aACrCb,KAAKwE,SAAS0B,qBAAqBJ,EAAYb,GAAIC,EAAMC,GAEjEnF,KAAKmG,SAAWL,EAAYb,IAIhCP,gBAAgB0B,GACVA,IAAapG,KAAKmG,WACpBnG,KAAKmG,SAAW3F,UAChBR,KAAKqG,KAAKhC,EAA4BC,aAAc,CAClDgC,oBAAqBtG,KAAK6E,4BAE5B7E,KAAK6E,0BAA4BrE,WAUtBD,kBACb,MAAMgG,QAAgBvG,KAAKwE,SAASgC,gBACpC,OAAOxG,KAAKyG,YAAYF,GAS1BE,YAAYF,GACV,OAAOA,EACHA,EAAQzE,MAAM4E,GAELA,GAAoB,UAAbA,EAAIV,MAAoBU,EAAIzB,KAAOjF,KAAKmG,WAExD,uWC7GR,IAAAQ,EAAA3G,MAAAA,KAAA2G,kBAAA/H,OAAAgI,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAnI,OAAAqI,eAAAJ,EAAAG,EAAA,CAAAE,YAAA,EAAAhG,IAAA,WAAA,OAAA4F,EAAAC,OACA,SAAAF,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAF,EAAAG,GAAAF,EAAAC,KAEAI,EAAAnH,MAAAA,KAAAmH,cAAA,SAAAL,EAAA1H,GACA,IAAA,IAAAgI,KAAAN,EAAA,YAAAM,GAAAxI,OAAAyI,UAAAC,eAAAC,KAAAnI,EAAAgI,IAAAT,EAAAvH,EAAA0H,EAAAM,IAEAxI,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACA2I,EAAA1I,EAAA,cAAAW,GACA+H,EAAA1I,EAAA,mBAAAW,GACA+H,EAAA1I,EAAA,uBAAAW,GACA+H,EAAA1I,EAAA,iBAAAW,GACA+H,EAAA1I,EAAA,qBAAAW,GACA+H,EAAA1I,EAAA,eAAAW,8ZCjBA,IAAAoI,EAAA5H,EAAAnB,EAAA,WAce,MAAMgJ,UAAiBD,EAAArH,QAIpCJ,YAAY8C,EAAO,IACjBG,QACA,MAAM0E,EAAa7E,EAAK6E,YAAc,GAEtC1H,KAAK0H,WAAaA,EAAWC,MAAK,CAACC,EAAGC,IAAMD,EAAEE,QAAUD,EAAEC,UAE1D,MAAMC,EAAgB/H,KAAK0H,WAAWM,OAAO,GAAG,GAEhDhI,KAAKiI,eACHpF,EAAKoF,gBAAmBF,GAAiBA,EAAcD,SAAY,EAItDvH,kBAAC2H,EAAgBlI,KAAKmI,wBAErC,MAAMC,EAAoBpI,KAAK0H,WAAWW,QA2C1C,SAA4BC,GAC1B,OAAOA,EAAUR,QAAUI,EAAcK,KAAKT,WAzChD,IAAK,MAAMQ,KAAaF,EACtB,IAEE,MAAMI,QAAqBF,EAAUG,QAAQP,GAC7C,IAAKM,EAAahJ,KAChB,MAAM,IAAIkJ,MAAM,4CAElB,GACEF,EAAaV,UAAYtH,WACzBgI,EAAaD,KAAKT,UAAYQ,EAAUR,QAExC,MAAM,IAAIY,MACR,gEAKJR,EAAgBM,EAChB,MAAOrH,GAEP,MAAMwH,EAAuBxH,EAAI+C,QAKjC,OAJA/C,EAAI+C,QAAW,6BAA4BoE,EAAUR,YAAYa,IAEjE3I,KAAKqG,KAAK,QAASlF,GAEZ+G,EAIX,OAAOA,EAsBTC,qBAAqB3I,GACnB,MAAO,CACL+I,KAAM,CACJT,QAAS9H,KAAKiI,gBAEhBzI,KAAAA,qqCCrFN,IAAA+F,EAAA3F,EAAAnB,EAAA,UACAmK,EAAAhJ,EAAAnB,EAAA,UACAoK,EAAAjJ,EAAAnB,EAAA,UACAqK,EAAAlJ,EAAAnB,EAAA,UACAsK,EAAAnJ,EAAAnB,EAAA,UACAuK,EAAApJ,EAAAnB,EAAA,UACAwK,EAAArJ,EAAAnB,EAAA,UACAyK,EAAAtJ,EAAAnB,EAAA,UACA0K,EAAAvJ,EAAAnB,EAAA,UACA2K,EAAAxJ,EAAAnB,EAAA,UACA4K,EAAAzJ,EAAAnB,EAAA,UACA6K,EAAA1J,EAAAnB,EAAA,UACA8K,EAAA3J,EAAAnB,EAAA,UACA+K,EAAA5J,EAAAnB,EAAA,UACAgL,EAAA7J,EAAAnB,EAAA,UACAiL,EAAA9J,EAAAnB,EAAA,UACAkL,EAAA/J,EAAAnB,EAAA,UACAmL,EAAAhK,EAAAnB,EAAA,UACAoL,EAAAjK,EAAAnB,EAAA,UACAqL,EAAAlK,EAAAnB,EAAA,UACAsL,EAAAnK,EAAAnB,EAAA,UACAuL,EAAApK,EAAAnB,EAAA,UACAwL,EAAArK,EAAAnB,EAAA,UACAyL,EAAAtK,EAAAnB,EAAA,UACA0L,EAAAvK,EAAAnB,EAAA,UACA2L,EAAAxK,EAAAnB,EAAA,UACA4L,EAAAzK,EAAAnB,EAAA,UACA6L,EAAA1K,EAAAnB,EAAA,UACA8L,EAAA3K,EAAAnB,EAAA,UACA+L,EAAA5K,EAAAnB,EAAA,UACAgM,EAAA7K,EAAAnB,EAAA,UACAiM,EAAA9K,EAAAnB,EAAA,UACAkM,EAAA/K,EAAAnB,EAAA,UACAmM,EAAAhL,EAAAnB,EAAA,UACAoM,EAAAjL,EAAAnB,EAAA,UACAqM,EAAAlL,EAAAnB,EAAA,UACAsM,EAAAnL,EAAAnB,EAAA,UACAuM,EAAApL,EAAAnB,EAAA,UACAwM,EAAArL,EAAAnB,EAAA,UACAyM,EAAAtL,EAAAnB,EAAA,UACA0M,EAAAvL,EAAAnB,EAAA,UACA2M,EAAAxL,EAAAnB,EAAA,UACA4M,EAAAzL,EAAAnB,EAAA,UACA6M,EAAA1L,EAAAnB,EAAA,UACA8M,EAAA3L,EAAAnB,EAAA,UACA+M,EAAA5L,EAAAnB,EAAA,UACAgN,EAAA7L,EAAAnB,EAAA,UACAiN,EAAA9L,EAAAnB,EAAA,UACAkN,EAAA/L,EAAAnB,EAAA,UACAmN,EAAAhM,EAAAnB,EAAA,UACAoN,GAAAjM,EAAAnB,EAAA,UACAqN,GAAAlM,EAAAnB,EAAA,UACAsN,GAAAnM,EAAAnB,EAAA,UACAuN,GAAApM,EAAAnB,EAAA,UACAwN,GAAArM,EAAAnB,EAAA,UACAyN,GAAAtM,EAAAnB,EAAA,UACA0N,GAAAvM,EAAAnB,EAAA,UACA2N,GAAAxM,EAAAnB,EAAA,UACA4N,GAAAzM,EAAAnB,EAAA,UACA6N,GAAA1M,EAAAnB,EAAA,UACA8N,GAAA3M,EAAAnB,EAAA,UACA+N,GAAA5M,EAAAnB,EAAA,UACAgO,GAAA7M,EAAAnB,EAAA,UACAiO,GAAA9M,EAAAnB,EAAA,UACAkO,GAAA/M,EAAAnB,EAAA,UACAmO,GAAAhN,EAAAnB,EAAA,UACAoO,GAAAjN,EAAAnB,EAAA,UACAqO,GAAAlN,EAAAnB,EAAA,iBAEmB,CACjB8G,EAAApF,QACAyI,EAAAzI,QACA0I,EAAA1I,QACA2I,EAAA3I,QACA4I,EAAA5I,QACA6I,EAAA7I,QACA8I,EAAA9I,QACA+I,EAAA/I,QACAgJ,EAAAhJ,QACAiJ,EAAAjJ,QACAkJ,EAAAlJ,QACAmJ,EAAAnJ,QACAoJ,EAAApJ,QACAqJ,EAAArJ,QACAsJ,EAAAtJ,QACAuJ,EAAAvJ,QACAwJ,EAAAxJ,QACAyJ,EAAAzJ,QACA0J,EAAA1J,QACA2J,EAAA3J,QACA4J,EAAA5J,QACA6J,EAAA7J,QACA8J,EAAA9J,QACA+J,EAAA/J,QACAgK,EAAAhK,QACAiK,EAAAjK,QACAkK,EAAAlK,QACAmK,EAAAnK,QACAoK,EAAApK,QACAqK,EAAArK,QACAsK,EAAAtK,QACAuK,EAAAvK,QACAwK,EAAAxK,QACAyK,EAAAzK,QACA0K,EAAA1K,QACA2K,EAAA3K,QACA4K,EAAA5K,QACA6K,EAAA7K,QACA8K,EAAA9K,QACA+K,EAAA/K,QACAgL,EAAAhL,QACAiL,EAAAjL,QACAkL,EAAAlL,QACAmL,EAAAnL,QACAoL,EAAApL,QACAqL,EAAArL,QACAsL,EAAAtL,QACAuL,EAAAvL,QACAwL,EAAAxL,QACAyL,EAAAzL,QACA0L,GAAA1L,QACA2L,GAAA3L,QACA4L,GAAA5L,QACA6L,GAAA7L,QACA8L,GAAA9L,QACA+L,GAAA/L,QACAgM,GAAAhM,QACAiM,GAAAjM,QACAkM,GAAAlM,QACAmM,GAAAnM,QACAoM,GAAApM,QACAqM,GAAArM,QACAsM,GAAAtM,QACAuM,GAAAvM,QACAwM,GAAAxM,QACAyM,GAAAzM,QACA0M,GAAA1M,QACA2M,GAAA3M,yiBCrIa,UAA8B4M,kDAM3C,MAAMC,EAAcC,EAAwBvL,KAAMwL,GAAS,SAAQA,QAOnE,OANAvN,EAAAQ,QAAAgN,WAAAC,gBAAAC,YAAiDC,EAAmB,CAClEC,KAAMP,EACNQ,MAAO,CAAC,gBAIH,CAELC,SACE9N,EAAAQ,QAAAgN,WAAAC,gBAAAM,eAAoDJ,KAIxD/M,eAAA+M,EAAAK,GACE,MAAMC,eAAiBD,EAGvB,IAAe,IAAXC,GAAwC,QAAxBC,IAClB,OAGF,6CAA6D,IAAIC,IAAInQ,GAC/DoQ,EAAcC,EAAIhM,MAAO,KACzBiM,EAAiBF,EAAYA,EAAWnN,OAAU,GAEnDqM,EAAwBiB,SAAUD,IAOzC1N,gBAA8BqN,gDAC5B,MAAMO,EAAcC,IAEpBzO,EAAAQ,QAAAkO,KAAAC,OAAsBV,EAAO,CAAEjQ,IAAM,iBACrC,IAAIA,EAAO,gCAA+BqQ,IAC1C,IACE,MAAMhI,qBAAuB,EAAAuI,EAAApO,SAA0B,CACrD4M,SAAAA,EACAiB,KAAAA,IAEF,GAAa,YAAThI,GAA+B,YAATA,EAAoB,CAC5C,MAAMwI,EAAe,WAAUC,KAAQzI,EAAIgC,MACzC,EACA,MACGmG,IAAcO,IAAWC,GAAU,KAAKC,GAAY,KACzD,IAK0B,aAHDrL,EAAiBiL,EAAa,CACnDK,OAAQ,UAEEC,SACVnR,EAAM6Q,GAER,MAAArN,GACA4N,QAAOC,KAAM7N,SAEV,GAAa,aAAT6E,EACTrI,EAAO,mCAAkC8Q,IAAOC,IAC9CC,GAAU,KACTC,GAAY,UACV,GAAa,UAAT5I,GAA6B,WAATA,EAC7BrI,EAAO,UAAS8Q,UAAaC,IAAWC,GAAU,KAAKC,GAAY,UAC9D,GAAa,YAAT5I,EACTrI,EAAO,0BAAyB8Q,IAAOC,IAAWC,GAAU,KAC1DC,GAAY,UAET,GAAa,cAAT5I,EAAsB,CAC/B,MAAMiJ,EAASR,EAAIS,OAAQT,EAAI7N,OAAU,EAAK6N,EAAI7N,OAAU,EAAI,KAC1DuO,EAAUC,EAAAjP,QAAAkP,YAAmBJ,GAE7BK,EAAU,CAAEC,SAAS,GAM3B5R,EAAO,YALsB,EAAA6R,EAAArP,SAC3BgP,EACA,cACAG,GAH2B1N,2BAKsB8M,IACjDC,GAAU,KACTC,GAAY,MAEjB,MAAAzN,GACA4N,QAAOC,KAAM7N,GA9Cf,QAgDExB,EAAAQ,QAAAkO,KAAAC,OAAsBV,EAAO,CAAEjQ,IAAAA,KAxDjC8R,CAAe,CAAE7B,MAAAA,EAAOI,KAAAA,EAAMU,SAAAA,EAAUC,OAAAA,EAAQC,SAAAA,MA/CpD,IAAAY,EAAA5P,EAAAnB,EAAA,kBACA2Q,EAAAxP,EAAAnB,EAAA,cACAkB,EAAAC,EAAAnB,EAAA,kBACA6E,EAAA7E,EAAA,qCACAiR,EAAA9P,EAAAnB,EAAA,kDACA8P,EAAA3O,EAAAnB,EAAA,eAEA,MAAM8E,GAAmB,EAAAmM,EAAAvP,SAA6B,GAATmD,EAAAE,QAEvCyJ,EAA2B,CAAC,mrFCTlCzF,EAAA5H,EAAAnB,EAAA,WACAkR,EAAA/P,EAAAnB,EAAA,SACAmR,EAAAnR,EAAA,uBACAoR,EAAApR,EAAA,qCACAqR,EAAArR,EAAA,mBACAH,EAAAG,EAAA,UACAsR,EAAAnQ,EAAAnB,EAAA,4CACAuR,EAAApQ,EAAAnB,EAAA,yBACAwR,EAAArQ,EAAAnB,EAAA,6CACAyR,EAAAzR,EAAA,2BACA0R,EAAAvQ,EAAAnB,EAAA,2BACA2R,EAAA3R,EAAA,kBACA4R,EAAA5R,EAAA,mBACA6R,EAAA7R,EAAA,mBACAoB,EAAAD,EAAAnB,EAAA,aACA8R,EAAA3Q,EAAAnB,EAAA,uBACA+R,EAAA5Q,EAAAnB,EAAA,wCACAgS,EAAA7Q,EAAAnB,EAAA,wBACAiS,EAAAjS,EAAA,0CACAkS,EAAA/Q,EAAAnB,EAAA,cACAmS,EAAAhR,EAAAnB,EAAA,WACAoS,EAAApS,EAAA,mBACAqS,EAAArS,EAAA,yBAeAsS,EAAAnR,EAAAnB,EAAA,4CACAuS,EAAAvS,EAAA,8BAKAwS,EAAAxS,EAAA,sCAIAyS,EAAAzS,EAAA,gCAKA0S,EAAA1S,EAAA,kCACA2S,EAAA3S,EAAA,2CAIA4S,EAAA5S,EAAA,sCAIA6S,EAAA7S,EAAA,8BACA8S,EAAA9S,EAAA,wCACA6E,EAAA7E,EAAA,+BACA+S,EAAA/S,EAAA,8BAKAgT,EAAAhT,EAAA,2CACAiT,EAAAjT,EAAA,qCACAkT,EAAAlT,EAAA,4CACAqB,EAAArB,EAAA,+BACAmT,EAAAhS,EAAAnB,EAAA,oCACAoT,EAAAjS,EAAAnB,EAAA,0BACAqT,EAAAlS,EAAAnB,EAAA,iCACAsT,EAAAtT,EAAA,+BAGAuT,EAAApS,EAAAnB,EAAA,iCACAwT,EAAArS,EAAAnB,EAAA,gCACAyT,EAAAtS,EAAAnB,EAAA,qCACA0T,EAAA1T,EAAA,sBACA2T,EAAAxS,EAAAnB,EAAA,sBACA4T,EAAAC,GAAA7T,EAAA,0BACA8T,GAAA3S,EAAAnB,EAAA,8BACA+T,GAAA5S,EAAAnB,EAAA,4BACAgU,GAAA7S,EAAAnB,EAAA,kCACAiU,GAAA9S,EAAAnB,EAAA,wBACAkU,GAAA/S,EAAAnB,EAAA,6BACAmU,GAAAhT,EAAAnB,EAAA,2BACAoU,GAAAjT,EAAAnB,EAAA,wCACAqU,GAAAR,GAAA7T,EAAA,0BACAsU,GAAAnT,EAAAnB,EAAA,kCACAuU,GAAApT,EAAAnB,EAAA,wCACAwU,GAAArT,EAAAnB,EAAA,mCACAyU,GAAAtT,EAAAnB,EAAA,gCACA0U,GAAAvT,EAAAnB,EAAA,+BACA2U,GAAAxT,EAAAnB,EAAA,gCACA4U,GAAAzT,EAAAnB,EAAA,wBACA6U,GAAA1T,EAAAnB,EAAA,gCACA8U,GAAA3T,EAAAnB,EAAA,+BACA+U,GAAA5T,EAAAnB,EAAA,8BACAgV,GAAAhV,EAAA,iBACAiV,GAAA9T,EAAAnB,EAAA,+BACAkV,GAAAlV,EAAA,0sCAY0C,CAGxCmV,aAAc,cAEdC,sBAAuB,kCAGV,MAAAC,WAAiCtM,EAAArH,QAI9CJ,YAAW8C,GAAO,IAAAkR,EAChB/Q,QAEAhD,KAAAgU,oBAA2B,GAE3BhU,KAAAiU,YAAkB,EAAA3V,EAAAY,UAChBc,KAAAkU,kBAAAvP,KAA4B3E,MACd,IAAdsD,EAAA6Q,aAEFnU,KAAA6C,KAAYA,EACZ7C,KAAAoU,UAAiBvR,EAAIuR,UACrBpU,KAAAwE,SAAgB3B,EAAI2B,SACpBxE,KAAAqU,oBAA2BxR,EAAIwR,oBAC/B,MAAMC,EAAYzR,EAAIyR,WAAc,GAC9BxM,EAAU9H,KAAAwE,SAAA+P,aAChBvU,KAAAwU,oBAAyBF,GAIzBtU,KAAAyU,4BAAmC,EAEnCzU,KAAA0U,wBAA+B7R,EAAI6R,wBACnC1U,KAAA2U,uBAA8B9R,EAAI8R,uBAElC3U,KAAA4U,oBAA2B,IAAI9D,EAAA+D,oBAG/B7U,KAAA8U,MAAa,IAAIlD,EAAAzR,QAA0B,CACzCU,MAAOyT,EACPM,oBAAqB5U,KAAA4U,oBACrBG,SAAS,IAKX/U,KAAAgV,YAAmB,GAGnBhV,KAAAiV,iBAAwB,IAAI5E,EAAA6E,MAE5BlV,KAAAoU,UAAAe,QAAAC,YAAA/H,aAAgDM,IACvB,WAAnBA,EAAO0H,QAAoC,UAAZvN,GACjC9H,KAAAwE,SAAA8Q,4BAOJtV,KAAAuV,mBAA0B,IAAIzE,EAAA0E,mBAAmB,CAC/CC,UAAWzV,KAAA4U,oBAAAc,cAAuC,CAChD1H,KAAM,uBAER2H,oBAAqB9S,EAAI+S,uBAG3B5V,KAAA6V,kBAAyB,IAAIxD,EAAAlS,QAAkBmU,EAASwB,mBACxD9V,KAAA6V,kBAAAE,mBAA0ClT,EAAImT,iBAG9ChW,KAAAiW,qBACAjW,KAAA+M,SAAgB/M,KAAA6V,kBAAAK,6BAAAnJ,SAChB/M,KAAAmW,aAAoBnW,KAAA6V,kBAAAK,6BAAAC,aAEpBnW,KAAAoW,sBAA6B,IAAI7D,GAAApS,QAAsB,CACrDmU,UAAWA,EAASzW,sBACpBwY,aAAcxT,EAAIwT,aAClBC,UAAWzT,EAAIyT,UACfC,QAASvW,KAAA6V,kBACT9I,SAAU/M,KAAA+M,SACVyJ,wBAAyBxW,KAAAwW,wBAAA7R,KAAkC3E,QAG7DA,KAAAyW,iBAAwB,IAAI3F,EAAA4F,iBAAiB,CAC3CC,yBAA0B3W,KAAAoW,sBAAAtB,MAAA8B,UAAAjS,KACxB3E,KAAAoW,sBAAAtB,OAEF+B,qBAAsB7W,KAAA6V,kBAAAf,MAAA8B,UAAAjS,KACpB3E,KAAA6V,kBAAAf,OAEFlX,OAAQ,CAAEmP,SAAU/M,KAAA+M,UACpBlM,MAAOyT,EAASoC,mBAGlB1W,KAAA8W,yBAAgC,IAAIhG,EAAAiG,yBAAyB,CAC3DhK,SAAU/M,KAAA+M,WAGZ/M,KAAAgX,uBAA8B,IAAIlG,EAAAmG,uBAChC,CACEN,yBAA0B3W,KAAAoW,sBAAAtB,MAAA8B,UAAAjS,KACxB3E,KAAAoW,sBAAAtB,OAEF+B,qBAAsB7W,KAAA6V,kBAAAf,MAAA8B,UAAAjS,KACpB3E,KAAA6V,kBAAAf,OAEFoC,mBAAoBlX,KAAA8W,yBAAAI,mBAAAvS,KAClB3E,KAAA8W,0BAEFK,qBAAsBnX,KAAA8W,yBAAAK,qBAAAxS,KACpB3E,KAAA8W,0BAEFM,kBAAmBpX,KAAA8W,yBAAAM,kBAAAzS,KACjB3E,KAAA8W,0BAEFO,iBAAkBrX,KAAA8W,yBAAAO,iBAAA1S,KAChB3E,KAAA8W,0BAEFQ,oBAAqBtX,KAAA8W,yBAAAQ,oBAAA3S,KACnB3E,KAAA8W,0BAEFS,mBAAoBvX,KAAA8W,yBAAAS,mBAAA5S,KAClB3E,KAAA8W,2BAGJ,GACAxC,EAAS2C,wBAGXjX,KAAAgX,uBAAAQ,UAAsCC,EAAOC,IAAPC,aAGnC3X,KAAA4X,+BAAsC,IAAI9G,EAAA+G,+BACzC,CACEC,0BAA4BC,GAC1B/X,KAAAgX,uBAAAJ,UAAsCmB,GACxCpB,yBAA0B3W,KAAAoW,sBAAAtB,MAAA8B,UAAAjS,KACxB3E,KAAAoW,sBAAAtB,OAEF+B,qBAAsB7W,KAAA6V,kBAAAf,MAAA8B,UAAAjS,KACpB3E,KAAA6V,kBAAAf,OAEFkD,iBAAkB,IAAMhY,KAAAgX,uBAAAiB,cACxBC,wBAAyBlY,KAAA8W,yBAAAoB,wBAAAvT,KACvB3E,KAAA8W,0BAEFqB,eAAgBnY,KAAAgX,uBAAAmB,eAAAxT,KACd3E,KAAAgX,wBAEFoB,qBAAsB,IAAMpY,KAAAgX,uBAAAnW,QAIlCb,KAAAqY,sBAA6B,IAAI7E,GAAArT,QAAsB,CACrDmY,QAAA7E,GAAA6E,QACAC,iBAAkBvY,KAAAoW,sBAAAtB,MAClB0D,mBAAoBxY,KAAA6V,kBAAA4C,GAAA9T,KAClB3E,KAAA6V,kBACAxD,EAAAqG,eAAAC,oBAEFC,qBAAsB5Y,KAAA6V,kBAAA+C,qBAAAjU,KACpB3E,KAAA6V,mBAEFhI,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEF/N,QAAS9H,KAAAwE,SAAA+P,aACTsE,YAAa,QACbvE,UAAWA,EAASwE,sBACpBC,iBAAAlI,EAAAkI,mBAGF,MAAMC,EAAkBhZ,KAAA4U,oBAAAc,cAAuC,CAC7D1H,KAAM,qBAGFiL,EACF/H,EAAAgI,iBAGJlZ,KAAAmZ,iBAAwB,IAAIrI,EAAAsI,iBAAiB,CAC3CC,SAAU,IACV5D,UAAWuD,EACXM,SAAUpI,EAAAqI,gBACVC,YAAa,IACXxZ,KAAA6V,kBAAAK,6BAAAnJ,SACF8J,qBAAsB7W,KAAA6V,kBAAA4C,GAAA9T,KACpB3E,KAAA6V,kBACAxD,EAAAqG,eAAAC,oBAEFc,sCAAuCzZ,KAAA6V,kBAAA6D,wBAAA/U,KACrC3E,KAAA6V,mBAEF8D,sCAAuC3Z,KAAA2Z,sCAAAhV,KACrC3E,MAEF4Z,kBAAoB,GAAEX,kCACtBY,mBAAqB,GAAEZ,yCACvBa,2CAA4C,KAC1C,MAAM9b,EAAUgC,KAAA6V,kBAAAhI,oBAChB,OAAO4J,EAAOC,IAAPqC,SAAuB/b,IAAYmT,EAAA6I,kBAE5CC,WAAY,IACHxC,EAAOC,IAAPqC,QACH5I,EAAA6I,iBACAha,KAAA6V,kBAAAhI,sBAIR7N,KAAAka,kBAAyB,IAAIxJ,EAAAyJ,gBAE7Bna,KAAAoa,mBAA0B,IAAI5H,GAAArS,QAAmB,CAC/Cka,kBAAmBra,KAAAyY,GAAA9T,KAAa3E,KAAM,UACtCsa,WAAYta,KAAAsa,WAAA3V,KAAqB3E,MACjCsU,UAAWA,EAASiG,mBACpBC,kBAAmB,IAAMxa,KAAAya,YACzBC,kBAAmB7X,EAAI+S,qBACvB2C,iBAAkBvY,KAAAoW,sBAAAtB,MAClB6F,gBAAiB3a,KAAAka,kBAAAU,gBAGnB,MAAMC,EAAwB7a,KAAA4U,oBAAAc,cAAuC,CACnE1H,KAAM,2BAERhO,KAAA8a,uBAA8B,IAAIhK,EAAAiK,uBAAuB,CACvDC,gBAAgB,EAChBvF,UAAWoF,EACXha,MAAOyT,EAAS2G,qBAGlB,MAAMC,EAAqBlb,KAAA4U,oBAAAc,cAAuC,CAChE1H,KAAM,wBAERhO,KAAAmb,oBAA2B,IAAIrK,EAAAsK,oBAAoB,CACjDpd,SAAS,EAAAyT,EAAA4J,cAAarb,KAAA6V,kBAAAhI,qBACtByN,oBAAqBtb,KAAAoW,sBAAAtB,MAAAyG,WAAAC,kBAErB3E,qBAAuB4E,GACrBzb,KAAA6V,kBAAAf,MAAA8B,WAAwC8E,IACtC,MAAMC,EAAoB7Y,GAAAA,GAAA,GACrB4Y,GADqB,GAAA,CAExB3O,SAAQjK,GAAAA,GAAA,GACH4Y,EAAY3O,UADT,GAAA,CAEN/O,SAAS,EAAAyT,EAAA4J,cAAaK,EAAY3O,SAAZ/O,aAG1B,OAAOyd,EAAGE,MAEdhF,yBAA2B8E,GACzBzb,KAAAoW,sBAAAtB,MAAA8B,WAA4CgF,IAC1C,MAAMC,EAAwB/Y,GAAAA,GAAA,GACzB8Y,GADyB,GAAA,CAE5BN,oBAAqBtb,KAAAoW,sBAAAtB,MAAAyG,WAAAC,oBAGvB,OAAOC,EAAGI,MAEdpG,UAAWyF,EACXra,MAAOyT,EAAS8G,sBAGlBpb,KAAA8b,mBAA0B,IAAIhL,EAAAiL,mBAE9B/b,KAAAgc,uBAA8B,IAAIlL,EAAAmL,uBAChC,CAAEC,iBAAkB5K,EAAA6K,kBACpB7H,EAAS2H,wBAIXjc,KAAAoc,qBAA4B,IAAItL,EAAAuL,qBAAqB,CACnDC,oBAAsBvE,GACpB/X,KAAAyW,iBAAAG,UAAgCmB,GAClCwE,0BAA4BxE,GAC1B/X,KAAA4U,oBAAAgC,UACG,GAAE5W,KAAA8a,uBAAA9M,mBACH+J,GAEJlB,qBAAuB4E,GACrBzb,KAAA6V,kBAAAf,MAAA8B,WAAwC8E,IACtC,MAAMC,EAAoB7Y,GAAAA,GAAA,GACrB4Y,GADqB,GAAA,CAExB3O,SAAQjK,GAAAA,GAAA,GACH4Y,EAAY3O,UADT,GAAA,CAEN/O,SAAS,EAAAyT,EAAA4J,cAAaK,EAAY3O,SAAZ/O,aAG1B,OAAOyd,EAAGE,QAIhB3b,KAAAwc,cAAqB,IAAIpK,EAAAjS,QAAc,CACrC4M,SAAU/M,KAAA+M,SACVc,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEF2C,mBAAoBxY,KAAA6V,kBAAA4C,GAAA9T,KAClB3E,KAAA6V,kBACAxD,EAAAqG,eAAAC,sBAIJ3Y,KAAAyc,+BAAsC,IAAI5J,GAAA1S,QAA+B,CACvEgW,aAAcnW,KAAAmW,aACdqC,mBAAoBxY,KAAA6V,kBAAA4C,GAAA9T,KAClB3E,KAAA6V,kBACAxD,EAAAqG,eAAAC,oBAEF9K,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEFO,sBAAuBpW,KAAAoW,sBACvB9B,UAAWA,EAASoI,iCAItB1c,KAAA2c,eAAsB,IAAI9K,EAAA1R,QAAe,CACvC4M,SAAU/M,KAAA+M,SACVoJ,aAAcnW,KAAAmW,aACdtI,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,qBAKJ7V,KAAAyY,GAAQ,+BAAgChE,IAClCA,EAA8B,GAChCzU,KAAA2c,eAAAC,QACA5c,KAAAyc,+BAAAG,QACA5c,KAAA8a,uBAAA8B,QACA5c,KAAAmb,oBAAAyB,UAEA5c,KAAA2c,eAAAE,OACA7c,KAAAyc,+BAAAI,OACA7c,KAAA8a,uBAAA+B,OACA7c,KAAAmb,oBAAA0B,WAIJ7c,KAAA8c,yBAAgC,IAAIrK,GAAAtS,QAAyB,CAC3Dwc,eAAgB3c,KAAA2c,eAChB9O,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEFvB,UAAWA,EAASyI,2BAGtB/c,KAAAgd,qBAA4B,IAAIrK,GAAAxS,QAAqB,CACnDmU,UAAWA,EAAS2I,uBAGtBjd,KAAAyW,iBAAAyG,IAAAzE,GAA6B,yBAAyBlY,gBAC9CsC,EAAIyT,eAGZ,MAAM6G,EAAqB,CACzB5M,EAAApQ,QACAqQ,EAAArQ,QACAsQ,EAAAtQ,QACAuQ,EAAAyJ,iBAEFna,KAAAod,kBAAyB,IAAIjN,EAAAhQ,QAAkB,CAC7Ckd,aAAcF,EACd7I,UAAWA,EAASgJ,kBACpBC,UAAW1a,EAAI0a,WAAc/c,YAE/BR,KAAAod,kBAAAI,SAAA5G,WAA2C/V,GACzCb,KAAAyd,2BAAgC5c,KAElCb,KAAAod,kBAAA3E,GAA0B,UAAU,IAAMzY,KAAA0d,cAC1C1d,KAAAod,kBAAA3E,GAA0B,QAAQ,IAAMzY,KAAA2d,YAExC,MAAMC,EAAgB,IACpB5d,KAAAoW,sBAAAtB,MAAAyG,WAAAsC,WAEF7d,KAAA8d,qBAA4B,IAAI9M,EAAA+M,qBAAqB,CACnDtI,UAAWzV,KAAA4U,oBAAAc,cAAuC,CAChD1H,KAAM,uBACNgQ,eAAgB,CACb,GAAEhe,KAAAuV,mBAAAvH,kBACF,GAAEhO,KAAAuV,mBAAAvH,kBACF,GAAEhO,KAAAuV,mBAAAvH,qBACF,GAAEhO,KAAAuV,mBAAAvH,wBAGPnN,MAAOyT,EAASyJ,qBAChBE,sBAAsB,EAAAtK,GAAAuK,yBAAwB,CAAEN,cAAAA,IAChDO,yBAAwBrb,GAAA,IACnB,EAAA6Q,GAAAyK,6BAA4B,CAC7BR,cAAAA,EACAS,eAAgBre,KAAAod,kBAAAkB,YAAA3Z,KACd3E,KAAAod,mBAEFmB,yCAA0C,CACxCV,EAAa,GACbW,EAAW,MAEX,MAGMC,EAH4BD,EAAQnW,QACvCqW,IAAab,EAAWa,KAEwChd,KAChEgd,IAAD,IAAAC,EAAA,OAAA,QAAAA,EACE3e,KAAAod,kBAAAwB,qBAA4CF,UAD9C,IAAAC,OAAA,EACEA,EAAA3Y,QAGE6Y,EAAkBjgB,OAAM+B,KAAMkd,GAAc,IAA1Bjd,OAElBke,EAAsBlgB,OAAM+B,KAChCX,KAAA2c,eAAA7H,MAAAyG,WAAAiD,UAAiD,IADvB5d,QAI5B,EAAAiQ,EAAAkI,kBACE,IAAIrQ,MACD,sEAAqE8V,EAAQ5d,wBAAyBie,yBAAuCJ,8EAA8GK,2CAMtQC,oBAAApL,GAAAoL,sBAGF/e,KAAAgf,wBAA+B,IAAIrL,GAAAsL,wBAAwB,CACzDC,kBAAmB,IAAIC,IAAIvgB,OAAM+B,KAAM0Q,EAAA+N,oBACvC9K,UAAWA,EAAS2K,0BAGtBjf,KAAAqf,0BAAiC,IAAIrO,EAAAsO,0BAA0B,CAC7D7J,UAAWzV,KAAA4U,oBAAAc,cAAuC,CAChD1H,KAAM,4BACNgQ,eAAgB,CAAE,GAAEhe,KAAA8d,qBAAA9P,yBAEtBnN,MAAOyT,EAASgL,0BAChBC,kBAAmB,MAIrBvf,KAAAwf,uBAA8B,IAAIpM,GAAAjT,QAAuB,CACvDsf,YAAazf,KAAAoW,sBACbK,iBAAkBzW,KAAAyW,iBAClBF,QAASvW,KAAA6V,kBACT6J,gBAAiB1f,KAAAod,kBAAAI,SACjBmC,UAAW3f,KAAAmb,sBAGbnb,KAAA4f,sBAA6B,IAAI9O,EAAA+O,sBAC/Brf,UACA8T,EAASuL,uBAGX7f,KAAA8f,gBAAuB,IAAIpN,GAAAvS,QAAgB,CACzCmU,UAAWA,EAASyL,gBACpBxH,iBAAkBvY,KAAAoW,sBAAAtB,QAGpB9U,KAAAggB,mBAA0B,IAAIpN,GAAAzS,QAAmB,CAC/CiW,sBAAuBpW,KAAAoW,sBACvBwJ,sBAAuB5f,KAAA4f,sBACvBxC,kBAAmBpd,KAAAod,kBACnB9I,UAAWA,EAAS2L,mBACpBC,0BAA2BlgB,KAAAod,kBAAAI,SAAAjC,SAAA5W,KACzB3E,KAAAod,kBAAAI,UAEF1V,QAAAA,EACAqY,sBAAuBngB,KAAAqY,sBAAA+H,WAAAzb,KACrB3E,KAAAqY,yBAIJrY,KAAAqgB,aAAoB,IAAIlN,GAAAhT,QAAsB,CAC5CmU,UACEA,EAASgM,uBAA0BhM,EAASiM,mBAC9CC,qBAAsBxgB,KAAAwgB,qBAAA7b,KAA+B3E,MACrDygB,kBAAmBzgB,KAAA6V,kBAAA4K,kBAAA9b,KACjB3E,KAAA6V,mBAEF4D,sCAAuCzZ,KAAA6V,kBAAA6D,wBAAA/U,KACrC3E,KAAA6V,mBAEF8D,sCAAuC3Z,KAAA2Z,sCAAAhV,KACrC3E,MAEF0gB,aAAc1gB,KAAA6V,kBAAA6K,aACd7S,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEF0C,iBAAkBvY,KAAAoW,sBAAAtB,MAClB6L,eAAgB,GAChBC,gBAAiB5gB,KAAAod,kBAAAwD,gBAAAjc,KACf3E,KAAAod,mBAEFrQ,SAAU/M,KAAA+M,SACVoJ,aAAcnW,KAAAmW,aACd0K,oBAAqB7gB,KAAAqY,sBAAAwI,oBAAAlc,KACnB3E,KAAAqY,uBAEFyI,oBAAqB9gB,KAAAqY,sBAAAyI,oBAAAnc,KACnB3E,KAAAqY,uBAEF0I,sBAAuB/gB,KAAAqY,sBAAA0I,sBAAApc,KACrB3E,KAAAqY,uBAEF2I,qBAAsBhhB,KAAAqY,sBAAA2I,qBAAArc,KACpB3E,KAAAqY,uBAEF8H,sBAAuBngB,KAAAqY,sBAAA+H,WAAAzb,KACrB3E,KAAAqY,uBAEF4I,wBAAyB,IACvBjhB,KAAAqY,sBAAAxX,MAAAqgB,yBACFC,0BAA2BnhB,KAAAmZ,iBAAAiI,qBAAAzc,KACzB3E,KAAAmZ,kBAEFkI,+BAAgCrhB,KAAAqhB,+BAAA1c,KAC9B3E,QAGJA,KAAAqgB,aAAA5H,GAAqB,mBAAmB,IAAM5V,EAAI+S,yBAElD5V,KAAAqgB,aAAA5H,GAAsB,oBAAmBlY,MAAA+gB,EAAAxS,KACvC,GACEA,IAAWmC,EAAAsQ,qBAAAC,WACX1S,IAAWmC,EAAAsQ,qBAAAE,OACX,CACA,MAAMC,EAAS1hB,KAAAqgB,aAAAsB,eAAAC,eAAgDN,GACzDxjB,EAAwBkC,KAAAoW,sBAAAyL,2BAC9B,IAAI1jB,EAAW,GACf,GAAIujB,EAAM1jB,QAAU,CAAA,IAAA8jB,EAClB,MAAMC,EAAcjkB,EAAqBgE,MACtCkgB,GAAQN,EAAM1jB,UAAagkB,EAAGhkB,UAEjCG,EAAQ,QAAA2jB,EAAGC,MAAAA,OAAH,EAAGA,EAAW5jB,gBAAd,IAAA2jB,EAAAA,EAA4B,GAEtC9hB,KAAAwE,SAAAyd,4BAA0CP,EAAQvjB,GAElD,MAAM+jB,aAAgBR,EAItB,GACEA,EAAM1b,OAAUiL,EAAAkR,kBAAAC,4BAChBV,EAAMW,WAAc7hB,UACpB,CAAA,IAAA8hB,EACA,MAAM9iB,oBAIFkiB,EAAMW,UACJrkB,WAAc0jB,EACda,GAAkB,EAAA5Q,EAAA6Q,oBAAmBhjB,GACrCijB,GAAuB,EAAA/Q,EAAAgR,oBAAmBH,IAC1CI,mBAAsB3iB,KAAAgX,uBAAAnW,MAGtB+hB,EAAmBD,MAAAA,GAAH,QAAAL,EAAGK,EAAkBE,UAArB,IAAAP,OAAA,EAAGA,EACvBtkB,GADuB8D,MAGvB,0BACE,EAAAhC,EAAAgjB,wBAAuBpE,EAASqE,IAChCC,IAAYP,IAIZG,GACF5iB,KAAAgX,uBAAAiM,+CACEL,GACA,EACA,CAAEC,YAAAA,EAAa7kB,QAAAA,IAKrB,MAAMklB,QAAsBljB,KAAAub,WAEiB,IAAA4H,EAA7C,GAAIjB,GAAkC,QAArBA,EAASpT,OACxB9O,KAAAqY,sBAAA+H,WACE,CACEgD,MAAO,qCACPC,SAAU,aACVC,WAAY,CACVC,OAAQ,eACRC,aAAY,QAAAL,EAAEzB,EAAM+B,uBAAR,IAAAN,OAAA,EAAEA,EAAA9N,OACdqO,eAAgBR,EAAaS,OAAb/iB,OAChBgjB,iBAAkBhlB,OAAM+B,KAAMuiB,EAAa1E,UAAzB5d,SAGtB,CACEijB,aAAa,QAOvB7jB,KAAA6V,kBAAA4C,GAA0BpG,EAAAqG,eAAAC,oBAAmCpY,UAC3D,MAAMtC,UAAa+B,KAAA6V,kBAAA4K,oBACnB,UACQzgB,KAAA8a,uBAAAgJ,kBAA8C7lB,GACpD,MAAAqC,GAEAyO,QAAOzO,MAAOA,OAIlBN,KAAA6V,kBAAAkO,gBACA/jB,KAAAgkB,eAAsB,IAAIlR,GAAA3S,QAAe,CACvC8jB,aAAcjkB,KAAAqY,sBAAA+H,WAAAzb,KACZ3E,KAAAqY,yBAGJrY,KAAAkkB,uBAA8B,IAAIjR,GAAA9S,QAAuB,CACvD8jB,aAAcjkB,KAAAqY,sBAAA+H,WAAAzb,KACZ3E,KAAAqY,yBAGJrY,KAAAmkB,sBAA6B,IAAIpR,GAAA5S,QAAsB,CACrD8jB,aAAcjkB,KAAAqY,sBAAA+H,WAAAzb,KACZ3E,KAAAqY,yBAGJrY,KAAAokB,2BAAkC,IAAIpR,GAAA7S,QAA2B,CAC/D8jB,aAAcjkB,KAAAqY,sBAAA+H,WAAAzb,KACZ3E,KAAAqY,yBAGJrY,KAAAqkB,oBAA2B,IAAInR,GAAA/S,QAAoB,CACjD0N,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEFoO,aAAcjkB,KAAAqY,sBAAA+H,WAAAzb,KACZ3E,KAAAqY,yBAIJrY,KAAAskB,gBAAuB,IAAIjR,GAAAlT,QAAgB,CACzCokB,oBAAqBvkB,KAAAqgB,aAAAmE,UAAAD,oBAAA5f,KACnB3E,KAAAqgB,aAAAmE,WAEF3O,kBAAmB7V,KAAA6V,kBACnB9I,SAAU/M,KAAA+M,SACV0T,kBAAmBzgB,KAAA6V,kBAAA4K,kBAAA9b,KACjB3E,KAAA6V,mBAEF4O,mBAAoB,IAAMzkB,KAAAoc,qBAAAvb,MAC1BgN,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEFsL,0BAA2BnhB,KAAAmZ,iBAAAiI,qBAAAzc,KACzB3E,KAAAmZ,oBAGJnZ,KAAA0kB,4BAAmC,IAAI3T,EAAA5Q,QACrC,CACE0W,qBAAsB7W,KAAA6V,kBAAAf,MAAA8B,UAAAjS,KACpB3E,KAAA6V,kBAAAf,OAEF6P,WAAY3kB,KAAA6V,kBAAA+O,gBAAAjgB,KACV3E,KAAA6V,mBAEFgP,aAAc7kB,KAAAqgB,aAAAyE,aAAAD,aAAAlgB,KACZ3E,KAAAqgB,aAAAyE,cAEFC,2BAA4B/kB,KAAAqgB,aAAA0E,2BAAApgB,KAC1B3E,KAAAqgB,cAEFtT,SAAU/M,KAAA+M,SACVoT,sBAAuBngB,KAAAqY,sBAAA+H,WAAAzb,KACrB3E,KAAAqY,wBAGJ7X,UACA8T,EAAS0Q,6BAIXhlB,KAAA6V,kBAAA4C,GAA0BpG,EAAAqG,eAAAC,oBAAmC,KAC3D3Y,KAAA2c,eAAAsI,qBAIFjlB,KAAA6V,kBAAA4C,GAA0BpG,EAAAqG,eAAAwM,qBAAoC,KAC5DllB,KAAAqgB,aAAAsB,eAAAwD,qBACAnlB,KAAAokB,2BAAAgB,kBACAplB,KAAAkkB,uBAAAkB,kBACAplB,KAAAqkB,oBAAAe,kBACAplB,KAAAmkB,sBAAAiB,kBACAplB,KAAAgkB,eAAAoB,qBAIFplB,KAAAyY,GAAQ,UAAW4M,GAAarlB,KAAAslB,eAAoBD,KAEpDrlB,KAAA8U,MAAAyQ,gBAA2B,CACzBhL,mBAAoBva,KAAAoa,mBAAAtF,MACpBwL,sBAAuBtgB,KAAAqgB,aAAAvL,MACvBwI,kBAAmBtd,KAAAod,kBAAAtI,MACnBjX,sBAAuBmC,KAAAoW,sBAAAtB,MACvBgE,sBAAuB9Y,KAAAqY,sBAAAvD,MACvB+K,sBAAuB7f,KAAA4f,sBACvB3E,mBAAoBjb,KAAA8a,uBACpBhF,kBAAmB9V,KAAA6V,kBAAAf,MACnBiI,yBAA0B/c,KAAA8c,yBAAAhI,MAC1BiL,gBAAiB/f,KAAA8f,gBAAAhL,MACjBmI,qBAAsBjd,KAAAgd,qBAAAlI,MACtB4H,+BAAgC1c,KAAAyc,+BAAA3H,MAChCiJ,qBAAsB/d,KAAA8d,qBACtBmB,wBAAyBjf,KAAAgf,wBAAAlK,MACzBwK,0BAA2Btf,KAAAqf,0BAC3BY,mBAAoBjgB,KAAAggB,mBAAAlL,MACpBmH,uBAAwBjc,KAAAgc,uBACxB5C,iBAAkBpZ,KAAAmZ,iBAClBiC,oBAAqBpb,KAAAmb,oBACrBzE,iBAAkB1W,KAAAyW,iBAClBuO,4BAA6BhlB,KAAA0kB,4BAC7BzN,uBAAwBjX,KAAAgX,yBAG1BhX,KAAAwd,SAAgB,IAAI5L,EAAAzR,QAA0B,CAC5CvC,OAAQ,CACN2c,mBAAoBva,KAAAoa,mBAAAtF,MACpBgB,kBAAmB9V,KAAA6V,kBAAAf,MACnB0Q,eAAgBxlB,KAAA2c,eAAA7H,MAChB2Q,aAAczlB,KAAAqgB,aAAA7C,SACdT,yBAA0B/c,KAAA8c,yBAAAhI,MAC1BuH,qBAAsBrc,KAAAoc,qBACtBsJ,eAAgB1lB,KAAAgkB,eAAAxG,SAChBmI,uBAAwB3lB,KAAAkkB,uBAAA1G,SACxBoI,sBAAuB5lB,KAAAmkB,sBAAA3G,SACvBqI,2BAA4B7lB,KAAAokB,2BAAA5G,SAC5BsI,oBAAqB9lB,KAAAqkB,oBAAA7G,SACrBF,kBAAmBtd,KAAAod,kBAAAI,SACnB3f,sBAAuBmC,KAAAoW,sBAAAtB,MACvBgE,sBAAuB9Y,KAAAqY,sBAAAvD,MACvB+K,sBAAuB7f,KAAA4f,sBACvB3E,mBAAoBjb,KAAA8a,uBACpBiF,gBAAiB/f,KAAA8f,gBAAAhL,MACjBmI,qBAAsBjd,KAAAgd,qBAAAlI,MACtB4H,+BAAgC1c,KAAAyc,+BAAA3H,MAEhCiJ,qBAAsB/d,KAAA8d,qBACtBmB,wBAAyBjf,KAAAgf,wBAAAlK,MACzBwK,0BAA2Btf,KAAAqf,0BAC3BY,mBAAoBjgB,KAAAggB,mBAAAlL,MACpBiR,gBAAiB/lB,KAAAskB,gBAAAxP,MACjBkR,cAAehmB,KAAAwc,cAAA1H,MACfU,mBAAoBxV,KAAAuV,mBACpB0G,uBAAwBjc,KAAAgc,uBACxB5C,iBAAkBpZ,KAAAmZ,iBAClBiC,oBAAqBpb,KAAAmb,oBACrBzE,iBAAkB1W,KAAAyW,iBAClBuO,4BAA6BhlB,KAAA0kB,4BAC7BzN,uBAAwBjX,KAAAgX,wBAE1BpC,oBAAqB5U,KAAA4U,sBAEvB5U,KAAAwd,SAAA5G,UAAwB5W,KAAAiU,WAAAtP,KAAqB3E,OAE7C,MAAMimB,EAAkB,QAAVlS,EAAG,UAAH,IAAAA,OAAA,EAAAA,EAAGmS,SAEfD,IACCjmB,KAAAsa,cACDta,KAAAgd,qBAAAlI,MAAAyG,WAAA4K,qBAEAnmB,KAAAomB,eAAoBH,GAItBjmB,KAAAoU,UAAAe,QAAAkR,iBAAuC,WACrCrmB,KAAAoa,mBAAAkM,sBACEC,EAEAvmB,KAAAoU,UAAAe,QAAAqR,iBAA0ChmB,UACtC,SACA,cAIRR,KAAAymB,oCAGAzmB,KAAA0mB,kBAAyB1mB,KAAA2mB,0BAgB3BF,oCACE,MAAMG,EAAuBrmB,MAAAsmB,EAAAC,KACvB9mB,KAAAsa,cACFta,KAAA+mB,kBAAuBF,EAAQ,CAC7BhY,OAAQ8E,GAAAqT,mBAAAC,gBAIRC,OACEJ,EAAWlmB,OAAU,EAEjBkmB,QAGM9mB,KAAAwgB,qBAA0BqG,KAI1C7mB,KAAAgf,wBAAAmI,sBAAmDN,EAAQC,IAI7D,IAAIM,EACJpnB,KAAAoW,sBAAAtB,MAAA8B,WAA2CrW,6BACzC,GAAI8mB,GAAmBA,IAAoBD,EAAqB,CAC9DA,EAAsBC,EACtB,MAAMC,GAAuB,EAAA3T,GAAA4T,8BAC3BvnB,KAAA8d,qBAAAjd,OAGF,IAAK,MAAMgmB,EAAArI,KAAsB8I,EAAoBzoB,UAC/C2f,EAAQtQ,SAAUmZ,IACpBT,EAAqBC,EAAQrI,OAQrCxe,KAAA4U,oBAAAgC,UACG,GAAE5W,KAAA8d,qBAAA9P,oBACHzN,MAAAinB,EAAAC,KACE,MAAMC,GAAkB,EAAA/T,GAAAgU,oBAAmBH,EAAcC,GAEzD,IAAK,MAAMZ,EAAArI,KAAsBkJ,EAAe7oB,UAC9C+nB,EAAqBC,EAAQrI,KAGjC7K,GAAA4T,8BAQJtR,qBACE,MAAMnO,EAAU9H,KAAAwE,SAAA+P,aACVqT,EAAe,CACnBC,OAAQ,CACNC,aAAa,EACbC,mBAAqB,aAAYjgB,KAEnCA,QAAAA,EAEAwW,YAAa/d,oBACX,GAAe,aAAXsmB,EAAuB,CACzB,MAAMQ,EAAkBrnB,KAAAoW,sBAAA4R,qBACxB,OAAOX,EAAkB,CAACA,GAAmB,GACxC,OAAIrnB,KAAAsa,mBACIta,KAAAwgB,qBAA0BqG,GAElC,IAGToB,mBAAoBjoB,KAAAkoB,yBAAAvjB,KAAmC3E,MAEvDmoB,sBAAuBnoB,KAAAooB,mBAAAzjB,KAA6B3E,MACpDqoB,oBAAqBroB,KAAAsoB,wBAAA3jB,KAAkC3E,MACvDuoB,sBAAuBvoB,KAAAsoB,wBAAA3jB,KAAkC3E,MACzDwoB,sBAAuBxoB,KAAAsoB,wBAAA3jB,KAAkC3E,MACzDyoB,uBAAwBzoB,KAAA0oB,2BAAA/jB,KAAqC3E,MAC7D2oB,sBAAuB3oB,KAAA4oB,yBAAAjkB,KAAmC3E,MAC1D6oB,2BAA4B7oB,KAAA8oB,8BAAAnkB,KAAwC3E,MACpE+oB,gBAAiB/oB,KAAA+oB,gBAAApkB,KAA0B3E,MAC3CgpB,4BAA8Bva,GAC5BzO,KAAAqgB,aAAA4I,gBAAkC,CAChCC,eAAgB,CACdza,KAAAA,EACAK,OAAQmC,EAAAsQ,qBAAA4H,aAET,IAKP,OAHsBnpB,KAAA6V,kBAAAI,mBACpB2R,GAUJjB,0BAEE,MAAMD,EAAoB,IAAI9W,EAAAwZ,iBACxBvT,qBAAwB7V,KAM9B,SAAAqpB,EAAAhE,GACE,MAAMrnB,EAAU6X,EAAiBhI,oBACR,YAArBwX,EAAQ9O,SACVmQ,EAAiB4C,SAIrB,SAAAtrB,GAAoCsc,yBAClC,MAAO,CACLA,WAAAA,EACAtc,QAAAA,EACAurB,eAAgBhT,GARWiT,CAAkBxrB,EAASqnB,IAY1D,OAlBArlB,KAAAyY,GAAQ,SAAU4Q,GAClBA,EAAwBrpB,KAAAub,YAiBjBmL,EAcanmB,uBAAAsmB,GACpB,OAAA/jB,GAAAA,GAAA,CACEwX,WAAYta,KAAAsa,cACTta,KAAAypB,2BAFL,GAAA,CAGEjL,eAAgBxe,KAAAwgB,qBAA0BqG,KAW9C4C,wBAAuBpE,GACrB,MAAM9O,WAAc8O,GAAYrlB,KAAAub,WAChC,MAAO,CACLvd,QAASgC,KAAA6V,kBAAAhI,oBACT0b,eAAgBhT,GAapBgF,WACE,MAAMmO,SAAY1pB,KAAAod,kBAAAtI,MAAAyG,WAGlB,OAAAzY,GAAA,CACE6mB,cAHoBzpB,QAAQwpB,IAIzB1pB,KAAAwd,SAAAoM,gBAWPC,SACE,MAAMjK,yhBAyBF5f,KAEJ,OAAA8C,GAAAA,GAAA,CAEEyY,SAAUvb,KAAAub,SAAA5W,KAAmB3E,MAC7B8pB,mBAAoBhP,EAAsBgP,mBAAtBnlB,KAClBmW,GAEFiP,cAAe3T,EAAqB2T,cAArBplB,KACbyR,GAEF4T,iBAAkB5T,EAAqB4T,iBAArBrlB,KAChByR,GAEF6T,kBAAmB7T,EAAqB6T,kBAArBtlB,KACjByR,GAEF8T,qBAAsB9T,EAAqB8T,qBAArBvlB,KACpByR,GAEF+T,2BAA4B/T,EAAqB+T,2BAArBxlB,KAC1ByR,GAEFgU,kBAAmBhU,EAAqBgU,kBAArBzlB,KACjByR,GAEFiU,eAAgBjU,EAAqBiU,eAArB1lB,KACdyR,GAEFkU,4BAA6BjS,EAAqBiS,4BAArB3lB,KAC3B0T,GAEFkS,iBAAkBnU,EAAqBmU,iBAArB5lB,KAChByR,GAEFoU,sBAAuBxqB,KAAAwqB,sBAAA7lB,KAAgC3E,MACvDyqB,wBAAyBzqB,KAAAyqB,wBAAA9lB,KAAkC3E,MAC3D0qB,uBAAwB1qB,KAAA0qB,uBAAA/lB,KAAiC3E,MACzD0U,wBAAyB1U,KAAA0U,wBACzBC,uBAAwB3U,KAAA2U,uBACxBgW,2CAA4C,IAC1C3qB,KAAAqU,oBAAAzP,4BAGFgmB,cAAe5qB,KAAA4qB,cAAAjmB,KAAwB3E,MACvC6qB,iBAAkB7qB,KAAA6qB,iBAAAlmB,KAA2B3E,MAC7C8qB,aAAc9qB,KAAA8qB,aAAAnmB,KAAuB3E,MACrC+qB,cAAe/qB,KAAA+qB,cAAApmB,KAAwB3E,MACvCgrB,0BAA2BhrB,KAAAgrB,0BAAArmB,KAAoC3E,MAG/DirB,gBAAiBjrB,KAAAirB,gBAAAtmB,KAA0B3E,MAC3CkrB,aAAclrB,KAAAkrB,aAAAvmB,KAAuB3E,MACrCmrB,oBAAqBnrB,KAAAmrB,oBAAAxmB,KAA8B3E,MACnDorB,4BAA6BprB,KAAAorB,4BAAAzmB,KAAsC3E,MACnEqrB,6BAA8BrrB,KAAAqrB,6BAAA1mB,KAC5B3E,MAEFsrB,+BAAgCtrB,KAAAsrB,+BAAA3mB,KAC9B3E,MAEFurB,mCAAoCvrB,KAAAurB,mCAAA5mB,KAClC3E,MAIFwrB,4BAA6BtR,EAAiBuR,kBAAjB9mB,KAC3BuV,GAEFwR,8BAA+BxR,EAAiByR,oBAAjBhnB,KAC7BuV,GAEF0R,qBAAsB1R,EAAiB2R,WAAjBlnB,KACpBuV,GAEF4R,0BAA2B5R,EAAiB6R,gBAAjBpnB,KACzBuV,GAEF8R,4BAA6B9R,EAAiB+R,kBAAjBtnB,KAC3BuV,GAIFgS,gBAAiBlsB,KAAAksB,gBAAAvnB,KAA0B3E,MAG3ComB,eAAgBpmB,KAAAomB,eAAAzhB,KAAyB3E,MACzCmsB,eAAgBnsB,KAAAmsB,eAAAxnB,KAAyB3E,MAGzCosB,gBAAiBvW,EAAiBuW,gBAAjBznB,KACfkR,GAEFwW,2BAA4BxW,EAAiBwW,2BAAjB1nB,KAC1BkR,GAEFyW,aAActsB,KAAAssB,aAAA3nB,KAAuB3E,MACrCusB,sBAAuBvsB,KAAAusB,sBAAA5nB,KAAgC3E,MACvDwsB,aAAcxsB,KAAAwsB,aAAA7nB,KAAuB3E,MAGrCysB,mBAAoBrW,EAAqBqW,mBAArB9nB,KAClByR,GAEFsW,SAAUjW,EAAgBiW,SAAhB/nB,KAA+B8R,GACzCkW,iBAAkBlW,EAAgBkW,iBAAhBhoB,KAChB8R,GAEFmW,iBAAkBnW,EAAgBmW,iBAAhBjoB,KAChB8R,GAEFoW,gBAAiBpW,EAAgBoW,gBAAhBloB,KAAsC8R,GACvDqW,YAAarW,EAAgBsW,qBAAhBpoB,KAA2C8R,GACxDuW,gBAAiB5W,EAAqB4W,gBAArBroB,KACfyR,GAEF6W,eAAgB7W,EAAqB6W,eAArBtoB,KACdyR,GAEF8W,cAAe9W,EAAqB8W,cAArBvoB,KACbyR,GAGF+W,mBAAoB/W,EAAqB+W,mBAArBxoB,KAClByR,GAEFgX,6BAA8BhX,EAAqBgX,6BAArBzoB,KAC5ByR,GAEFiX,kBAAmBjX,EAAqBiX,kBAArB1oB,KACjByR,GAEFkX,oBAAqBlX,EAAqBkX,oBAArB3oB,KACnByR,GAIFmX,2BAA4BzW,EAAwByW,2BAAxB5oB,KAC1BmS,GAIFqB,eAAgBnB,EAAsBmB,eAAtBxT,KACdqS,GAGFwW,8BAA+BxW,EAAsBwW,8BAAtB7oB,KAC7BqS,GAGFyW,2BAA4BzW,EAAsByW,2BAAtB9oB,KAC1BqS,GAGF0W,kBAAmB1W,EAAsB0W,kBAAtB/oB,KACjBqS,GAGF2W,6CAA8C3W,EAAsB2W,6CAAtBhpB,KAC5CqS,GAGFiM,+CAAgDjM,EAAsBiM,+CAAtBte,KAC9CqS,GAGF4W,mBAAoB5W,EAAsB4W,mBAAtBjpB,KAClBqS,GAIF6W,eAAgBjO,EAAqBve,IAArBsD,KAA+Bib,GAC/CkO,sBAAuBlO,EAAqBmO,OAArBppB,KACrBib,GAIFoO,kBAAmB5T,EAAkB4T,kBAAlBrpB,KACjByV,GAEF6T,4BAA6B7T,EAAkB6T,4BAAlBtpB,KAC3ByV,GAEF8T,sCAAuC9T,EAAkB8T,sCAAlBvpB,KACrCyV,GAEF+T,sCAAuC/T,EAAkB+T,sCAAlBxpB,KACrCyV,GAEFgU,mCAAoChU,EAAkBgU,mCAAlBzpB,KAClCyV,GAEFiU,gCAAiCjU,EAAkBiU,gCAAlB1pB,KAC/ByV,GAEFkU,wCAAyClU,EAAkBkU,wCAAlB3pB,KACvCyV,GAEFmU,kCAAmCnU,EAAkBmU,kCAAlB5pB,KACjCyV,GAEFoU,+BAAgCpU,EAAkBoU,+BAAlB7pB,KAC9ByV,GAGFqU,yBAA0BjS,EAAakS,sBAAb/pB,KACxB6X,GAIF/B,UAAWza,KAAAya,UAAA9V,KAAoB3E,MAC/B2uB,0BAA2B3uB,KAAA2uB,0BAAAhqB,KAAoC3E,MAC/D4uB,yBAA0B5uB,KAAA4uB,yBAAAjqB,KAAmC3E,MAC7D6uB,cAAezR,EAAiByR,cAAjBlqB,KAAqCyY,GAGpD0R,kBAAmBzO,EAAYyO,kBAAZnqB,KAAoC0b,GACvD0O,kBAAmB1O,EAAY0O,kBAAZpqB,KAAoC0b,GACvD2O,4BAA6B3O,EAAY2O,4BAAZrqB,KAC3B0b,GAEF4O,iCAAkC5O,EAAY4O,iCAAZtqB,KAChC0b,GAEF6O,wBAAyBlvB,KAAAkvB,wBAAAvqB,KAAkC3E,MAC3DmvB,yBAA0BnvB,KAAAmvB,yBAAAxqB,KAAmC3E,MAC7DovB,YAAapvB,KAAAovB,YAAAzqB,KAAsB3E,MACnCqvB,aAAcrvB,KAAAqvB,aAAA1qB,KAAuB3E,MACrCsvB,yBAA0BjP,EAAYiP,yBAAZ3qB,KACxB0b,GAEFkP,+BAAgClP,EAAYkP,+BAAZ5qB,KAC9B0b,GAEF4I,gBAAiB5I,EAAY4I,gBAAZtkB,KAAkC0b,GAGnDmP,YAAaxvB,KAAAwvB,YAAA7qB,KAAsB3E,MACnCyvB,cAAezvB,KAAAyvB,cAAA9qB,KAAwB3E,MAGvC0vB,oBAAqB1vB,KAAA0vB,oBAAA/qB,KAA8B3E,MACnD2vB,sBAAuB3vB,KAAA2vB,sBAAAhrB,KAAgC3E,MAGvD4vB,iBAAkB5vB,KAAA4vB,iBAAAjrB,KAA2B3E,MAC7C6vB,mBAAoB7vB,KAAA6vB,mBAAAlrB,KAA6B3E,MAGjD8vB,eAAgB9vB,KAAA8vB,eAAAnrB,KAAyB3E,MACzC+vB,qBAAsB/vB,KAAA+vB,qBAAAprB,KAA+B3E,MACrDgwB,qBAAsBhwB,KAAAgwB,qBAAArrB,KAA+B3E,MAGrDiwB,oBAAqBjwB,KAAAiwB,oBAAAtrB,KAA8B3E,MACnDkwB,0BAA2BlwB,KAAAkwB,0BAAAvrB,KAAoC3E,MAG/DmwB,sBAAuBnT,EAAoBmT,sBAApBxrB,KACrBqY,GAEFoT,mBAAoBpT,EAAoBoT,mBAApBzrB,KAClBqY,GAEFqT,qBAAsBrT,EAAoBqT,qBAApB1rB,KACpBqY,GAIFsT,oBAAqBxQ,EAAewQ,oBAAf3rB,KACnBmb,GAEFyQ,gCAAiCzQ,EAAeyQ,gCAAf5rB,KAC/Bmb,GAEF0Q,+BAAgC1Q,EAAe0Q,+BAAf7rB,KAC9Bmb,GAIF2Q,6BAA8BzQ,EAAkByQ,6BAAlB9rB,KAC5Bqb,GAEF0Q,oBAAqB1Q,EAAkB0Q,oBAAlB/rB,KACnBqb,GAEF2Q,4BAA6B3Q,EAAkB2Q,4BAAlBhsB,KAC3Bqb,GAEF4Q,uBAAwB5Q,EAAkB6Q,eAAlBlsB,KACtBqb,GAEF8Q,sBAAuB9Q,EAAkB8Q,sBAAlBnsB,KACrBqb,GAEF+Q,mBAAoB/wB,KAAA+wB,mBAAApsB,KAA6B3E,MAGjDgxB,qBAAsBlT,EAAoBmT,kBAApBtsB,KACpBmZ,GAEFoT,0BAA2BpT,EAAoBqT,yBAApBxsB,KACzBmZ,GAEFsT,yBAA0BtT,EAAoBsT,yBAApBzsB,KACxBmZ,KAEC,EAAAnK,GAAA0d,mCAAkCvT,IAjTvC,GAAA,CAqTEwT,kBAAmBhN,EAAegN,kBAAf3sB,KACjB2f,GAEFiN,sBAAuBjN,EAAeiN,sBAAf5sB,KACrB2f,GAEFkN,gBAAiBlN,EAAekN,gBAAf7sB,KAAqC2f,GACtDmN,eAAgBnN,EAAemN,eAAf9sB,KAAoC2f,GACpDoN,iBAAkBpN,EAAeoN,iBAAf/sB,KAAsC2f,GACxDqN,eAAgBrN,EAAeqN,eAAfhtB,KAAoC2f,GACpDsN,aAActN,EAAesN,aAAfjtB,KAAkC2f,GAChDuN,mBAAoBvN,EAAeuN,mBAAfltB,KAClB2f,GAEFwN,mBAAoBxN,EAAewN,mBAAfntB,KAClB2f,GAEFyN,uBAAwBzN,EAAeyN,uBAAfptB,KACtB2f,GAEF0N,+BAAgC1N,EAAe0N,+BAAfrtB,KAC9B2f,GAEF2N,kBAAmB3N,EAAe2N,kBAAfttB,KACjB2f,GAEF4N,qBAAsB5N,EAAe4N,qBAAfvtB,KACpB2f,GAEF6N,4BAA6B7N,EAAe6N,4BAAfxtB,KAC3B2f,GAEF8N,oBAAqB9N,EAAe8N,oBAAfztB,KACnB2f,GAEF+N,iBAAkB/N,EAAe+N,iBAAf1tB,KAAsC2f,GACxDgO,sBAAuBhO,EAAegO,sBAAf3tB,KACrB2f,GAEFiO,uBAAwBjO,EAAeiO,uBAAf5tB,KACtB2f,GAEFkO,iBAAkBlO,EAAekO,iBAAf7tB,KAAsC2f,GACxDmO,qBAAsBnO,EAAemO,qBAAf9tB,KACpB2f,GAEFoO,qBAAsBpO,EAAeoO,qBAAf/tB,KACpB2f,GAEFqO,kCAAmCrO,EAAeqO,kCAAfhuB,KACjC2f,GAIFsO,gCAAiClO,EAA2BmO,cAA3BluB,KAC/B+f,GAEFoO,0BAA2BpO,EAA2BqO,QAA3BpuB,KACzB+f,GAEFsO,6BAA8BtO,EAA2B0K,YAA3BzqB,KAC5B+f,GAEFuO,yBAA0BvO,EAA2BuO,yBAA3BtuB,KACxB+f,GAEFwO,uBAAwBxO,EAA2BwO,uBAA3BvuB,KACtB+f,GAEFyO,+BAAgCzO,EAA2B0O,cAA3BzuB,KAC9B+f,GAEF2O,uBAAwB3O,EAA2B2O,uBAA3B1uB,KACtB+f,GAEF4O,yBAA0B5O,EAA2B4O,yBAA3B3uB,KACxB+f,GAIFvE,sBAAuB9H,EAAqB+H,WAArBzb,KACrB0T,GAEFkb,qBAAsBlb,EAAqBmb,UAArB7uB,KACpB0T,GAEFwI,oBAAqBxI,EAAqBwI,oBAArBlc,KACnB0T,GAEFyI,oBAAqBzI,EAAqByI,oBAArBnc,KACnB0T,GAEF0I,sBAAuB1I,EAAqB0I,sBAArBpc,KACrB0T,GAIFob,uBAAwBle,EAAkBme,OAAlB/uB,KACtB4Q,GAEFoe,sBAAuBpe,EAAkBtU,OAAlB0D,KAA+B4Q,GAGtDqe,0BAA2B5X,EAAsB6X,aAAtBlvB,KACzBqX,GAIF8X,kCAAmC3a,EAAgB2a,kCAAhBnvB,KACjCwU,GAGF4a,+BAAgC5a,EAAgB6a,iBAAhBrvB,KAC9BwU,GAGF8a,sBAAuB9a,EAAgB+a,gBAAhBvvB,KACrBwU,GAGFgb,0BAA2B/Z,EAAkBga,gBAAlBzvB,KACzByV,GAGFia,+BAAgCja,EAAkBka,mBAAlB3vB,KAC9ByV,GAIFma,gBAAiB/U,EAAsB+U,gBAAtB5vB,KACf6a,GAIFgV,mBAEM,OAuBqBj0B,gCAAA0lB,GAC7B,MAAMwO,QAAoBz0B,KAAAiV,iBAAAyf,UAC1B,IACE,IAAIhL,EAEJ,UADuB1pB,KAAAod,kBAAAkB,eACX1d,OAAU,EACpB8oB,QAAc1pB,KAAAod,kBAAAuX,iBACT,CACLjL,QAAc1pB,KAAAod,kBAAAuR,0BACZ1I,GAEF,MAAM2O,QAAkB50B,KAAAod,kBAAAkB,cACxBte,KAAAoW,sBAAAye,aAAwCD,GACxC50B,KAAA80B,sBAGF,OAAOpL,EAdT,QAgBE+K,KAW0Bl0B,+BAAA0lB,EAAA8O,GAC5B,MAAMN,QAAoBz0B,KAAAiV,iBAAAyf,UAC1B,IACE,IAAIlW,EAAUwW,EAEd,MAAMC,EAAqBC,EAAMC,KAAMJ,IAEjC3X,qBAAwBpd,KAG9BA,KAAAoW,sBAAAye,aAAwC,IAGxC70B,KAAA8d,qBAAAsX,aAGAp1B,KAAA2c,eAAA0Y,gBAGAr1B,KAAA8c,yBAAAwY,sBAGAt1B,KAAAqgB,aAAAsB,eAAAwD,qBAGA,MAAMuE,QAActM,EAAiBwR,yBACnC3I,EACAgP,GAGIM,EAAW,IAAI5kB,EAAAxQ,QAASH,KAAA+M,UAC9ByR,QAAiBpB,EAAiBkB,cAClC0W,QAAoBh1B,KAAAw1B,WAClBhX,EAASA,EAAQ5d,OAAU,GAC3B20B,GAGF,MAAME,EAAiBrY,EAAiBsY,kBACtC,eACA,GACF,IAAKD,EACH,MAAM,IAAI/sB,MAAM,6CAIlB,KAAuB,QAAhBssB,SACC5X,EAAiBwN,cAAe6K,GACtCjX,QAAiBpB,EAAiBkB,cAClC0W,QAAoBh1B,KAAAw1B,WAClBhX,EAASA,EAAQ5d,OAAU,GAC3B20B,GAKA/W,EAAQ5d,OAAU,GAAqB,QAAhBo0B,UACnBh1B,KAAA+qB,cAAmBvM,EAASA,EAAQ5d,OAAU,IACpD4d,QAAiBpB,EAAiBkB,eAOpC,MAAMqX,EAAsB31B,KAAAoW,sBAAAwf,+BAM5B,OALA51B,KAAAqrB,6BAAkCsK,GAGlC31B,KAAAoW,sBAAAye,aAAwCrW,GACxCxe,KAAA80B,sBACOpL,EApET,QAsEE+K,KAUJe,WAAU9W,EAAA6W,GACR,OAAO,IAAIx0B,SAAQ,CAAAC,EAAAC,KACjB,MAAM40B,EAAS71B,KAAA2c,eAAA7H,MAAAyG,WAAAiD,SAA8CE,GAEzDmX,GAAUA,EAAMC,QAClB90B,EAAQ60B,EAAMC,SAEdP,EAAQC,WAAY9W,GAAS,CAAApe,EAAAw1B,KACvBx1B,GACFW,EAAOX,GACPT,EAAAM,QAAAG,MAAUA,IAEVU,EAAQ80B,GAAW,aAaRv1B,wBAEnB,MAAMw1B,sFAMF/1B,KAAAoW,sBAAAtB,MAAAyG,YAEEoE,aAAgB3f,KAAAmb,oBAAAta,MAEhB4e,EAAc,CAClBsW,cAAAA,EACAC,gBAAAA,EACAnY,WAAAA,EACAwJ,gBAAAA,IAII4O,gCAAkCj2B,KAAAyW,iBAAA5V,MAGlCq1B,EAAiB,GAEvBt3B,OAAM+B,KAAMs1B,GAAZn3B,SAAgCd,IAC9Bk4B,EAAel4B,GAAW,GAC1BY,OAAM+B,KAAMs1B,EAAUj4B,IAAtBc,SAAyCq3B,IACvC,MAAMC,GAA4B,EAAA7kB,EAAA8kB,sBAAqBF,GACvDD,EAAel4B,GAASo4B,GAA6BH,EAAUj4B,GAC7Do4B,GADmD/tB,QAE3CiuB,IACR,GAAIA,EAAKC,WAAc/1B,UAAW,CAGhC,MAAMke,EAAUlD,EACZ8a,EAAK5X,QAAL9c,cACA00B,EAAK5X,QAET,GAAIiB,EAAUjB,KAAale,UACzB,OAAO,OAEJ,IAAuB,IAAnB81B,EAAKC,SACd,OAAO,EAET,OAAO,WAMb,MAAMC,EAAYx2B,KAAAod,kBAAAsY,kBAChB,eACA,GACIe,EAAwBz2B,KAAAod,kBAAAsY,kBAC5B,mBAEIgB,QAAmBF,EAASlY,cAI5BqY,SAHqC51B,QAAO61B,IAChDH,EAAqB/0B,KAAMm1B,GAAYA,EAAOvY,kBAEUwY,QACxD,CAAAC,EAAAvY,IAAmB,IAAIuY,KAAQvY,IAC/B,IAEIA,EAAW,CACfwY,GAAIN,EAAUruB,QACJ,CAAA4uB,EAAAC,IAAeR,EAAUS,QAASF,KAAUC,IADlDx1B,KAEIgd,IAAY,EAAAnN,EAAA8kB,sBAAqB3X,KACzC0Y,cAAeT,EAAqBtuB,QAC1B,CAAA4uB,EAAAC,IAAeP,EAAqBQ,QAASF,KAAUC,IADlDx1B,KAEPgd,IAAY,EAAAnN,EAAA8kB,sBAAqB3X,KACzC2Y,OAAQ,GACRC,OAAQ,GACRC,QAAS,IAKX,IAAIC,gBAAmBx3B,KAAAqgB,aAAAvL,MAAAyG,WAOvB,OALAic,EAAe54B,OAAM64B,OAAQD,GAAdnvB,QAAoCqvB,IACjD,MAAMC,GAAoB,EAAApmB,EAAA8kB,sBAAqBqB,EAAErV,SAAF8S,MAC/C,OAAO3W,EAAQwY,GAAR9oB,SAAqBypB,MAGvB,CACLnZ,SAAAA,EACAiB,YAAAA,EACA+X,aAAAA,EACA7T,OAAQ,CAAEsS,UAAWC,EAAgB0B,iBAAAA,GACrCrhB,QAASvW,KAAA6V,kBAAAf,MAAAyG,YAYOhb,qBAAA0lB,SACZjmB,KAAAod,kBAAAgJ,eAAsCH,GAE5C,UACQjmB,KAAAmW,aAAA0hB,sBACN,MAAAv3B,GACAT,EAAAM,QAAAG,MAAU,mCAAoCA,GAGhD,IACE,MAAMw3B,EAAyB93B,KAAAggB,mBAAA+X,0BAC3BD,IAA2B93B,KAAAggB,mBAAAgY,KAE7Bh4B,KAAAggB,mBAAAiY,OACAj4B,KAAAggB,mBAAA8Q,yBACSgH,GAA0B93B,KAAAggB,mBAAAgY,KACnCh4B,KAAAggB,mBAAA8Q,wBAEF,MAAAxwB,GACAT,EAAAM,QAAAG,MAAU,mCAAoCA,GAOhD,MAAMq1B,EAAsB31B,KAAAoW,sBAAAwf,+BAI5B,OAFA51B,KAAAqrB,6BAAkCsK,GAE3B31B,KAAAod,kBAAAuX,aAQWp0B,qBAAA0lB,SACZjmB,KAAAod,kBAAA+O,eAAsClG,GAc9C6O,sBACE,MAAMjX,cAAiB7d,KAAAoW,sBAAAtB,MAAAyG,WACjBmD,EAAU9f,OAAM+B,KAAMkd,GAAY,GACxC7d,KAAAoW,sBAAAqW,mBAA8C/N,GAMhDwZ,4BACE,MAAMrB,EAAU72B,KAAAod,kBAAAsY,kBAAyC,eAAe,GACxE,IAAKmB,EAAOsB,SACV,MAAM,IAAIzvB,MAAM,yCAElB,OAAOmuB,EAAOsB,SAOS53B,0BAAA63B,EAAaC,EAAS,MAC7C,IAAIC,EAAc,KAClB,OAAQF,QACDhnB,EAAAmnB,aAAAC,OACHF,EAAc/nB,EAAApQ,QAAA6F,KACd,WACGoL,EAAAmnB,aAAAE,OACHH,EAAc9nB,EAAArQ,QAAA6F,KACd,WACGoL,EAAAmnB,aAAAG,GACHJ,EAAc5nB,EAAAyJ,gBAAAnU,KACd,WACGoL,EAAAmnB,aAAAI,QACHL,EAAc7nB,EAAAtQ,QAAA6F,KACd,cAEA,MAAM,IAAI0C,MACR,2DAGN,IAAImuB,QAAgB72B,KAAAod,kBAAAsY,kBAClB4C,GACA,GAUF,GATKzB,IACHA,QAAgB72B,KAAAod,kBAAAwb,cAAqCN,IAEnDD,GAAUxB,EAAOgC,WACnBhC,EAAOgC,UAAWR,GAEhBD,IAAehnB,EAAAmnB,aAAAI,UACjB9B,EAAOiC,QAAW,YAEhBV,IAAehnB,EAAAmnB,aAAAC,OAAqB,CACtC,MAAMO,EAAQlC,EAAOmC,WACrBh5B,KAAAoa,mBAAA6e,eAAuCF,GAKzC,OAFAlC,EAAOtgB,QAAWvW,KAAA6V,kBAAA4K,oBAAAza,KAEX6wB,EAG2Bt2B,uCAClC,MAAMs2B,QAAgB72B,KAAAk5B,oBAAyB9nB,EAAAmnB,aAAAE,QAC/C,aAAa5B,EAAOsC,iBAGkB54B,2CACtC,MAAMo1B,EAAsB31B,KAAAoW,sBAAAwf,+BAC5B,aAAa51B,KAAAqrB,6BAAkCsK,GAW5Bp1B,sBAAA63B,EAAAgB,EAAAf,GACnB,MAAMxB,QAAgB72B,KAAAk5B,oBAAyBd,EAAYC,GAC3D,IAAI7Z,EAAW,GACf,OAAQ4a,QACA,EACJ5a,QAAiBqY,EAAOwC,kBACxB,WACG,EACH7a,QAAiBqY,EAAOyC,cACxB,cAEA9a,QAAiBqY,EAAO0C,eAK5B,MAAMC,QAAoBx5B,KAAAod,kBAAAkB,cACpBmb,EAAkB,IACnB,IAAIta,IACLqa,EAAWE,OAAQlb,EAAQ9c,KAAMkG,GAAMA,EAAC8W,QAAD9c,mBAI3C,OADA5B,KAAA2c,eAAAgd,kBAAsCF,GAC/Bjb,EAUgBje,0BAAA63B,EAAAC,GAEvB,aADsBr4B,KAAAk5B,oBAAyBd,EAAYC,IAC7C/d,aASE/Z,mBAAA63B,GAGhB,aAFsBp4B,KAAAk5B,oBAAyBd,IACxClN,gBACA,EAST0O,gBAAe5rB,EAAA6rB,EAAAC,GACb,MAAQ,GAAE9rB,EAAK,GAAL+rB,gBAAwB/rB,EAAIhG,MAAO,MAC3CgyB,SAASH,EAAO,IAAM,KACpBC,GAAqB,KAFlBG,OAcwB15B,kCAAAs5B,EAAAzB,EAAAC,EAAAyB,GAM/B,MAAMjD,QAAgB72B,KAAAk5B,oBAAyBd,EAAYC,GAE3DxB,EAAOqD,mBAAoBL,GAC3B,MAAML,QAAoBx5B,KAAAod,kBAAAkB,cACpB6b,QAAiBn6B,KAAAod,kBAAAwN,cAAqCiM,GACtD/P,QAAoB9mB,KAAAod,kBAAAkB,cAC1Bte,KAAAoW,sBAAAye,aAAwC/N,GACxCA,EAAWhoB,SAAU4f,IACnB,IAAK8a,EAAWtrB,SAAUwQ,GAAU,CAClC,MAAM0b,EAAQp6B,KAAA45B,gBACZxB,IAAehnB,EAAAmnB,aAAAG,GAAkB7B,EAAOwD,UAAajC,EACrDyB,EACAC,GAGF95B,KAAAoW,sBAAA4W,gBAA2CtO,EAAS0b,GAEpDp6B,KAAAoW,sBAAAqW,mBAA8C/N,OAIlD,MAAMb,cAAiB7d,KAAAoW,sBAAAtB,MAAAyG,WACvB,OAAAzY,GAAAA,GAAA,GAAYq3B,GAAZ,GAAA,CAAsBtc,WAAAA,IAYLtd,sBACjB,MAAMk1B,EAAiBz1B,KAAAod,kBAAAsY,kBACrB,eACA,GACF,IAAKD,EACH,MAAM,IAAI/sB,MAAM,6CAElB,MAAM0U,qBAAwBpd,KACxBw5B,QAAoBpc,EAAiBkB,cACrC6b,QAAiB/c,EAAiBwN,cAAe6K,GACjD3O,QAAoB1J,EAAiBkB,oBAErCte,KAAA6qB,mBAEN7qB,KAAAoW,sBAAAye,aAAwC/N,GACxCA,EAAWhoB,SAAU4f,IACd8a,EAAWtrB,SAAUwQ,IACxB1e,KAAAoW,sBAAAqW,mBAA8C/N,MAIlD,MAAMb,cAAiB7d,KAAAoW,sBAAAtB,MAAAyG,WACvB,OAAAzY,GAAAA,GAAA,GAAYq3B,GAAZ,GAAA,CAAsBtc,WAAAA,IAaFtd,yBACpB,MAAMk1B,EAAiBz1B,KAAAod,kBAAAsY,kBACrB,eACA,GACF,IAAKD,EACH,MAAM,IAAI/sB,MAAM,6CAGlB,MAAM4xB,QAAmB7E,EAAc8E,YACjCtF,EAAqBC,EAAMC,KAAMmF,EAAUnC,UAE3C3Z,QAAiBiX,EAAcnX,cACrC,GAAIE,EAAQ5d,OAAU,EACpB,MAAM,IAAI8H,MAAM,0CAGlB,IAEE,aADM6K,GAAApT,QAAAq6B,eAAkChc,EAAUyW,GAC3CwF,MAAKtF,KAAMF,EAAkBwC,UACpC,MAAAt2B,GAEA,MADAtB,EAAAM,QAAAG,MAAUa,EAAG+C,SACP/C,GAWQZ,qBAChB,MAAM8mB,EAAkBrnB,KAAAoW,sBAAA4R,qBAIxB,OAHAhoB,KAAAqgB,aAAAqa,iBAAmCrT,GACnCrnB,KAAA6V,kBAAA8kB,kBAEOtT,EAWiB9mB,2BAAAsmB,GACxB,IACE,aAAa7mB,KAAA8d,qBAAA8c,wBACX/T,EACAxV,EAAA+N,kBAAAyb,cAEF,MAAAv6B,GACA,GAAIA,EAAKqB,OAAUyO,EAAA0qB,WAAA/tB,SAAAguB,aACjB,MAAO,GAET,MAAMz6B,GAcV06B,4BAA2BC,GACzBj7B,KAAA8d,qBAAAod,0BACE7pB,EAAA8pB,YAAAC,0BACCC,GACC1nB,GAAA2nB,uBACEjqB,EAAA8pB,YAAAC,0BADFrQ,cAEgBkQ,EAAeI,KASlB96B,oBAAAme,GAUjB,OARA1e,KAAAg7B,4BAAiCtc,GAEjC1e,KAAAoW,sBAAAmlB,cAAyC7c,GAEzC1e,KAAA2c,eAAAoO,cAAkC,CAACrM,UAG7B1e,KAAAod,kBAAA2N,cAAqCrM,GACpCA,EAWsBne,gCAAAi7B,EAAAC,GAC7B,MAAMC,QAAmBpoB,GAAAnT,QAAAw7B,cAA8BH,EAAUC,GAC3D5E,QAAgB72B,KAAAod,kBAAAwb,cACpB,kBACA,CAAC8C,IAEGld,QAAiBqY,EAAOvY,cAExBsd,QAAoB57B,KAAAod,kBAAAkB,cAC1Bte,KAAAoW,sBAAAye,aAAwC+G,SAElC57B,KAAAoW,sBAAAqW,mBAA8CjO,EAAS,IAcjCje,+BAAA8hB,EAAAwZ,GAC5B,aAAa77B,KAAAqgB,aAAA6H,yBAA2C7F,EAAUwZ,GAc5Ct7B,yBAAAu7B,EAAAD,GACtB,MAAMr8B,GAAO,EAAAsT,GAAAipB,kBAAiBD,EAASt8B,MACvC,IAAIw8B,EAIJ,GAAoB,KAAhBx8B,EAAIoB,QAAkC,KAAhBpB,EAAIoB,OAK5B,MAAMwP,EAAA6rB,UAAAja,IAAAka,cACJ,0CAGJ,OAREF,EAAUh8B,KAAAgkB,eAAAmY,0BAA8CL,EAAWD,GACnE77B,KAAAiU,aACAjU,KAAA6C,KAAA+S,6BAMWomB,EAUEz7B,kBAAAu7B,GACfj8B,EAAAM,QAAAi8B,KAAS,oCACT,MAAMC,EAAQP,EAASQ,WACvB,IAGE,MAAMC,QAAuBv8B,KAAAgkB,eAAAwY,eAC3BV,GAEIW,QAAez8B,KAAAod,kBAAAoS,YAAmC+M,GAExD,OADAv8B,KAAAgkB,eAAA0Y,mBAAuCL,EAAOI,GACvCz8B,KAAAub,WACP,MAAAjb,GAGA,MAFAT,EAAAM,QAAAi8B,KAAS,uCAAwC97B,GACjDN,KAAAgkB,eAAAR,aAAiC6Y,EAAO/7B,GAClCA,GASVmvB,cAAa4M,GACX,MAAMrY,kBAAqBhkB,KAE3B,OADAgkB,EAAc2Y,UAAWN,GAClBr8B,KAAAub,WAeuBhb,iCAAAu7B,EAAAD,GAC9B,MAAMG,EAAUh8B,KAAAkkB,uBAAAiY,0BACdL,EACAD,GAIF,OAFA77B,KAAAiU,aACAjU,KAAA6C,KAAA+S,uBACOomB,EAUgBz7B,0BAAAu7B,GACvBj8B,EAAAM,QAAAi8B,KAAS,4CACT,MAAMC,EAAQP,EAASQ,WAGvB,IACE,MAAMC,QAAuBv8B,KAAAkkB,uBAAAsY,eAC3BV,GAEIW,QAAez8B,KAAAod,kBAAAsS,oBACnB6M,GAKF,OADAv8B,KAAAkkB,uBAAAwY,mBAA+CL,EAAOI,GAC/Cz8B,KAAAub,WACP,MAAAjb,GAGA,MAFAT,EAAAM,QAAAi8B,KAAS,+CAAgD97B,GACzDN,KAAAkkB,uBAAAV,aAAyC6Y,EAAO/7B,GAC1CA,GASVqvB,sBAAqB0M,GAGnB,OAFuBr8B,KAAAkkB,uBACTyY,UAAWN,GAClBr8B,KAAAub,WAYqBhb,+BAAAu7B,EAAAD,GAC5B,MAAMG,EAAUh8B,KAAAmkB,sBAAAgY,0BACdL,EACAD,GAIF,OAFA77B,KAAAiU,aACAjU,KAAA6C,KAAA+S,uBACOomB,EASiBz7B,2BAAAu7B,GACxBj8B,EAAAM,QAAAi8B,KAAS,6CAET,MAAMC,EAAQP,EAASQ,WACjBM,EAAM58B,KAAAmkB,sBAAA0Y,OAAkCR,GAC9C,IACE,MAAMS,GAAW,EAAAxsB,EAAAysB,gBAAejB,EAASt8B,MACnCw9B,EAAO9H,EAAMC,KAAM2H,EAAU,OACnChB,EAASt8B,KAAQy9B,KAAIC,MAAOF,EAAIG,SAAU,SAE1CP,EAAGQ,cAAiBp9B,KAAAod,kBAAA0S,eAAsCgM,GAC1D,MAAAt6B,GACAo7B,EAAGt8B,MAASkB,EAAC0C,QAIf,OAFAlE,KAAAmkB,sBAAAkZ,WAAsCT,GAE/B58B,KAAAub,WAUWhb,qBAAAu7B,GAClBj8B,EAAAM,QAAAi8B,KAAS,uCACT,MAAMC,EAAQP,EAASQ,WAGvB,IACE,MAAMC,QAAuBv8B,KAAAmkB,sBAAAqY,eAC3BV,GAGIgB,GAAW,EAAAxsB,EAAAysB,gBAAeR,EAAc/8B,MACxCw9B,EAAO9H,EAAMC,KAAM2H,EAAU,OACnCP,EAAc/8B,KAAQy9B,KAAIC,MAAOF,EAAIG,SAAU,SAG/C,MAAMG,QAAgBt9B,KAAAod,kBAAA0S,eACpByM,GAGFv8B,KAAAmkB,sBAAAoZ,sBAAiDlB,EAAOiB,GACxD,MAAAh9B,GACAT,EAAAM,QAAAi8B,KAAS,2CAA4C97B,GACrDN,KAAAmkB,sBAAAX,aAAwC6Y,EAAO/7B,GAEjD,OAAON,KAAAub,WAQTyU,qBAAoBqM,GAGlB,OAFuBr8B,KAAAmkB,sBACTwY,UAAWN,GAClBr8B,KAAAub,WAY0Bhb,oCAAAu7B,EAAAD,GACjC,MAAMnd,EAAUod,EAGhB,cAFsB97B,KAAAod,kBAAAwB,qBAA4CF,IAEnD1Y,WACRoL,EAAAosB,cAAA/E,OACH,OAAO,IAAI13B,SAAQ,CAAAwE,EAAAtE,KACjBA,EACE,IAAIyH,MAAM,gEAKX0I,EAAAosB,cAAAhF,OACH,OAAO,IAAIz3B,SAAQ,CAAAwE,EAAAtE,KACjBA,EACE,IAAIyH,MAAM,gEAKX0I,EAAAosB,cAAA7E,QACH,OAAO,IAAI53B,SAAQ,CAAAwE,EAAAtE,KACjBA,EACE,IAAIyH,MAAM,iEAKX0I,EAAAosB,cAAA9E,GACH,OAAO33B,QAAOE,OACZ,IAAIyH,MAAM,qEAIL,CACP,MAAMszB,EAAUh8B,KAAAokB,2BAAA+X,0BACdL,EACAD,GAIF,OAFA77B,KAAAiU,aACAjU,KAAA6C,KAAA+S,uBACOomB,IAYYz7B,0BAAAu7B,GACvBj8B,EAAAM,QAAAi8B,KAAS,4CACT,MAAMC,EAAQP,EAASQ,WAGvB,IACE,MAAMpV,QAAelnB,KAAAokB,2BAAAoY,eACnBV,GAII2B,QAAkBz9B,KAAAod,kBAAAsgB,uBACtBxW,EAAM1nB,MAKRQ,KAAAokB,2BAAAuZ,qBAAqDtB,EAAOoB,GAC5D,MAAAn9B,GACAT,EAAAM,QAAAi8B,KACE,0DACA97B,GAEFN,KAAAokB,2BAAAZ,aAA6C6Y,EAAO/7B,GAEtD,OAAON,KAAAub,WAQT2U,0BAAyBmM,GAGvB,OAFuBr8B,KAAAokB,2BACTuY,UAAWN,GAClBr8B,KAAAub,WAYT+M,wBAAuBwT,EAAAD,EAAA/zB,GACrB,MAAMk0B,EAAUh8B,KAAAqkB,oBAAA8X,0BACdL,EACAD,EACA/zB,GAIF,OAFA9H,KAAAiU,aACAjU,KAAA6C,KAAA+S,uBACOomB,EAUaz7B,uBAAAu7B,GACpBj8B,EAAAM,QAAAi8B,KAAS,0CACT,MAAMC,EAAQP,EAASQ,YACjBx0B,WAAcg0B,EACpB,IACE,MAAMS,QAAuBv8B,KAAAqkB,oBAAAmY,eAC3BV,GAIc,OAAZh0B,GAEiC,iBAAxBy0B,EAAc/8B,OACvB+8B,EAAc/8B,KAAQy9B,KAAIC,MAAOX,EAAc/8B,OAInD,MAAMo+B,QAAkB59B,KAAAod,kBAAAwS,iBACtB2M,EACA,CAAEz0B,QAAAA,IAGJ,OADA9H,KAAAqkB,oBAAAqY,mBAA4CL,EAAOuB,GAC5C59B,KAAAub,WACP,MAAAjb,GAGA,MAFAT,EAAAM,QAAAi8B,KAAS,iDAAkD97B,GAC3DN,KAAAqkB,oBAAAb,aAAsC6Y,EAAO/7B,GACvCA,GASVuvB,mBAAkBwM,GAGhB,OAFuBr8B,KAAAqkB,oBACTsY,UAAWN,GAClBr8B,KAAAub,WAMkChb,8CACzC,OAAO,EAoBoBA,8BAAAs9B,EAAAC,EAAAC,SAKrB/9B,KAAAqgB,aAAA6O,wBACJ2O,EACAC,EACAC,GAGF,aADoB/9B,KAAAub,WAiBQhb,+BAAAs9B,EAAAC,EAAAC,SAKtB/9B,KAAAqgB,aAAA8O,yBACJ0O,EACAC,EACAC,GAGF,aADoB/9B,KAAAub,WAItB6T,YAAW4O,GACT,OAAO,IAAIj9B,SAAQ,CAAAC,EAAAC,IACVjB,KAAAqgB,aAAAmE,UAAAyZ,MAAA7O,YACL4O,GACA,CAAA78B,EAAA+8B,IACM/8B,EACKF,EAAOE,GAGTH,EAAQk9B,EAAGf,SAAU,SAapC3S,wBACExqB,KAAAoW,sBAAA+nB,sBAAgD,GAChDn+B,KAAAiU,aAMFwW,0BACEzqB,KAAAoW,sBAAA+nB,sBAAgD,GAChDn+B,KAAAiU,aA+BFmqB,6BAA4BC,4CAC1B,MAAMC,kBAAqBt+B,KAAAoW,sBAAAtB,MAAAyG,WAE3B,IAAIgjB,EASJ,GAPEA,EADEC,IAEOC,EAAMx5B,IAAOw5B,EAAMx5B,KAAQjF,KAAAoU,UAAAe,QAAAlQ,GACrBuM,EAAAktB,cAAAC,UAEAntB,EAAAktB,cAAAE,SAGbH,EAAM9gC,IAAM,CACd,MAAMkhC,YAAe,IAAI/wB,IAAI2wB,EAAM9gC,KAEnC,GAAI2gC,GAAkBt+B,KAAA8b,mBAAAgjB,KAA6BD,GAGjD,OAFAh/B,EAAAM,QAAA8D,MAAU,0CAA2C46B,QACrD7+B,KAAA++B,oBAAyBV,EAAkBQ,GAM/C,MAAMG,GAAM,EAAA7sB,EAAA8sB,gBAAeZ,GAG3Br+B,KAAAk/B,wBACEF,EAAGG,aAAc,qBACjBV,EACAF,GAIEE,EAAM9gC,KAERqC,KAAAo/B,kBAAuBJ,EAAGG,aAAc,iBAa5CE,0BAAyBhB,EAAAI,GAEvB,MAAMO,GAAM,EAAA7sB,EAAA8sB,gBAAeZ,GAE3Br+B,KAAAs/B,0BAA+BN,EAAGG,aAAc,eAChDn/B,KAAAk/B,wBACEF,EAAGG,aAAc,YACjBV,EACAjtB,EAAAktB,cAAAa,UAaJR,oBAAmBV,EAAAQ,IACL,EAAA1sB,EAAA8sB,gBAAeZ,GACDc,aAAc,YAC1BK,MAAO,CAAEX,SAAAA,IAQzBS,0BAAyBG,GACvB,MAAMC,EAAM1/B,KAAA6pB,SAGZ7pB,KAAAyU,6BAAoC,EACpCzU,KAAAqG,KAAU,8BAA+BrG,KAAAyU,6BAGzCgrB,EAAShnB,GAAI,QAAQ,EAAA/E,GAAAvT,SAAqBu/B,EAAKD,IAC/C,MAAME,EAAgBrxB,IAChBmxB,EAASG,eAATC,OAIJJ,EAASD,MAAO,CACdM,QAAS,MACTjxB,OAAQ,aACRqY,OAAQ,CAAC5Y,MAGbtO,KAAAyY,GAAQ,SAAUknB,GAClBF,EAAShnB,GAAI,OAAO,KAClBzY,KAAAyU,6BAAoC,EACpCzU,KAAAqG,KACE,8BACArG,KAAAyU,6BAEFzU,KAAA0N,eAAoB,SAAUiyB,MAWlCT,wBAAuBO,EAAAhB,EAAAD,GACrB,IAAI3X,EAgBAjZ,EAdFiZ,EADE2X,IAAgBhtB,EAAAktB,cAAAa,SACT,WAGA,IAAIzxB,IAAI2wB,EAAM9gC,KAAdkpB,OAGP4X,EAAMx5B,IAAOw5B,EAAMx5B,KAAQjF,KAAAoU,UAAAe,QAAAlQ,IAC7BjF,KAAAqf,0BAAA0gB,mBAAkD,CAChDlZ,OAAAA,EACAmZ,YAAavB,EAAMx5B,GACnBu5B,YAAahtB,EAAAktB,cAAAC,YAKbF,EAAMwB,KAAQxB,EAAMwB,IAANh7B,KAChB2I,EAAQ6wB,EAAMwB,IAANh7B,IAGV,MAAMi7B,EAASlgC,KAAAmgC,oBAAyB,CACtCtZ,OAAAA,EACA4X,OAAAA,EACAD,YAAAA,EACA5wB,MAAAA,IAIIwyB,GAAiB,EAAArwB,EAAA5P,SAAmB,CAAE+/B,OAAAA,IAEtCG,EAAergC,KAAAsgC,cAAmBzZ,EAAQ,CAAEqZ,OAAAA,KAElD,EAAAvwB,EAAAxP,SAAKs/B,EAAWW,EAAgBX,GAAYt+B,IAE1C++B,EAAMK,YAANzhC,SAA4B0hC,IACtBA,EAAGC,SAAmC,mBAAhBD,EAAGC,SAC3BD,EAAGC,aAGPJ,GAAgBrgC,KAAA0gC,iBAAsB7Z,EAAQwZ,GAC1Cl/B,GACFtB,EAAAM,QAAAG,MAAUa,MAehBg/B,qBAAoBtZ,0CAElB,MAAMqZ,EAAS,IAAIpwB,EAAA6wB,eACbxqB,2BAA6BnW,KAG7B4gC,GAAmB,EAAA5wB,EAAA7P,SAAuB,CAAE4M,SAAAA,EAAUoJ,aAAAA,IAGtD0qB,GAAsB,EAAA5wB,EAAA9P,SAA0B,CACpD4M,SAAAA,EACAoJ,aAAAA,IAoIF,OAlIA0qB,EAAmBC,OAAnBroB,GAA8B,gBAAiBvU,GAC7Cg8B,EAAM75B,KAAM,eAAgBnC,KAI9Bg8B,EAAMa,MAAM,EAAA/uB,EAAA7R,SAAuB,CAAE0mB,OAAAA,KAGjCjZ,GACFsyB,EAAMa,MAAM,EAAA9uB,EAAA9R,SAAsB,CAAEyN,MAAAA,KAItCsyB,EAAMa,MAAM,EAAAjvB,EAAA3R,SAAuB,CAAE0mB,OAAAA,KACrCqZ,EAAMa,KAAM/gC,KAAAgf,wBAAAgiB,oBAGRxC,IAAgBhtB,EAAAktB,cAAAE,SAClBsB,EAAMa,MACJ,EAAA7uB,EAAA/R,SAA2B,CACzB8gC,SAAUxC,EAAM9gC,IAChBujC,mBAAoBlhC,KAAAgd,qBAAAkkB,sBAM1BhB,EAAMa,MACJ,EAAAhvB,EAAAovB,wBAAuB,CACrBta,OAAAA,EAEA2X,YAAAA,EAGAuB,mBAAoB//B,KAAAqf,0BAAA0gB,mBAAAp7B,KAClB3E,KAAAqf,2BAEF+hB,iBAAkBphC,KAAAohC,iBAAAz8B,KAA2B3E,MAC7CqhC,iBAAkBrhC,KAAAoa,mBAAAinB,iBAAA18B,KAChB3E,KAAAoa,oBAEFknB,wBAAyBthC,KAAAyW,iBAAA8qB,WAAA58B,KACvB3E,KAAAyW,kBAEF+qB,oBAAqBxhC,KAAAuV,mBAAAksB,0BAAA98B,KACnB3E,KAAAuV,oBAEFmsB,YAAa1hC,KAAAqY,sBAAA+H,WAAAzb,KACX3E,KAAAqY,uBAIFiG,YAAate,KAAAwgB,qBAAA7b,KAA+B3E,KAAM6mB,GAClD8a,wBAAyB3hC,KAAA8d,qBAAA8jB,eAAAj9B,KACvB3E,KAAA8d,qBACA+I,GAEFgb,cAAe7hC,KAAA8d,qBAAA+jB,cAAAl9B,KACb3E,KAAA8d,qBACA+I,GAEFib,0BAA2B9hC,KAAA8d,qBAAAikB,mBAAAp9B,KACzB3E,KAAA8d,qBACA,CAAE+I,OAAAA,GACF,CAAEgU,aAAc,KAElBmH,4BAA6BhiC,KAAA8d,qBAAAikB,mBAAAp9B,KAC3B3E,KAAA8d,qBACA,CAAE+I,OAAAA,IAIJob,aAAc1hC,mEAMV,YACIP,KAAAoW,sBAAA8rB,qBACJnkC,EACAC,EACAC,EACAkkC,EACA,CACEC,iBAAAA,KAINC,gBAAiBriC,KAAAqiC,gBAAA19B,KAA0B3E,MAC3C6N,kBAAmB7N,KAAA6V,kBAAAhI,kBAAAlJ,KACjB3E,KAAA6V,mBAEFuW,gBAAiBpsB,KAAA6V,kBAAAuW,gBAAAznB,KACf3E,KAAA6V,mBAEFysB,gBAAiB,6CACftiC,KAAA6V,kBAAA0sB,aACExkC,EACAC,EACAC,EACAC,IAKJskC,sBAAuBxiC,KAAA8f,gBAAA0iB,sBAAA79B,KACrB3E,KAAA8f,iBAEF2iB,yBAA0BziC,KAAA8f,gBAAA2iB,yBAAA99B,KACxB3E,KAAA8f,oBAONogB,EAAMa,KAAMH,GACZV,EAAMa,KAAMF,EAAmB6B,YAC3BlE,IAAgBhtB,EAAAktB,cAAAa,UAElBW,EAAMa,KACJ/gC,KAAA8d,qBAAA6kB,2BAAqD,CACnD9b,OAAAA,KAMNqZ,EAAMa,MAAM,EAAA7wB,EAAA0yB,sBAAqB71B,IAC1BmzB,EAcTd,kBAAiBK,GACf,MAAMoD,GAAe,EAAAhzB,EAAAizB,eAAc9iC,KAAA0mB,oBAEnC,EAAA/W,EAAAxP,SAAK0iC,EAAcpD,GAAYt+B,IAC7B0hC,EAAYpC,UACRt/B,GACFtB,EAAAM,QAAAG,MAAUa,MAehBm/B,cAAazZ,GAASqZ,WACpB,GAAe,aAAXrZ,EACF,OAAO,KAGJ7mB,KAAAgV,YAAiB6R,KACpB7mB,KAAAgV,YAAiB6R,GAAU,IAG7B,MAAM5hB,GAAK,EAAA2L,EAAAzQ,WAKX,OAJAH,KAAAgV,YAAiB6R,GAAQ5hB,GAAM,CAC7Bi7B,OAAAA,GAGKj7B,EAUTy7B,iBAAgB7Z,EAAA5hB,GACd,MAAM+P,EAAchV,KAAAgV,YAAiB6R,GAChC7R,WAIEA,EAAY/P,GAEqB,IAApCrG,OAAM+B,KAAMqU,GAAZpU,eACKZ,KAAAgV,YAAiB6R,IAW5Bkc,qBAAoBlc,GAClB,MAAM7R,EAAchV,KAAAgV,YAAiB6R,GAChC7R,GAILpW,OAAM+B,KAAMqU,GAAZlW,SAAkCmG,IAChCjF,KAAA0gC,iBAAsB7Z,EAAQ5hB,MAgBlC8hB,kBAAiBF,EAAAmc,GACf,MAAMhuB,EAAchV,KAAAgV,YAAiB6R,GAEjC7R,GACFpW,OAAM64B,OAAQziB,GAAdlW,SAAoCmkC,IAC9BA,EAAI/C,QACN+C,EAAI/C,OAAJ75B,KAAiB,eAAgB28B,MAmBzCE,qBAAoBF,GAClB,MAAMG,EACe,mBAAZH,EACFnc,GAAWmc,EAAQnc,GACpB,IAAMmc,EAEZpkC,OAAM+B,KAAMX,KAAAgV,aAAZlW,SAAuC+nB,IACrCjoB,OAAM64B,OAAQz3B,KAAAgV,YAAiB6R,IAA/B/nB,SAAgDyB,MAAAA,IAC1C0iC,EAAI/C,QACN+C,EAAI/C,OAAJ75B,KAAiB,qBAAsB88B,EAAWtc,UAe1BtmB,iCAAAM,GAC9B,MAAMuiC,YAAeviC,EACf+zB,EAAYwO,EAAQtM,QACxB,CAAAC,iBAAuBA,EAAG2C,OAAQlb,IAClC,IAGGoW,EAASh0B,SAKdZ,KAAAoW,sBAAAitB,cAAyCzO,GACzC50B,KAAA2c,eAAAgd,kBAAsC/E,IAQxClX,YACE1d,KAAAkjC,sBAA0B3iC,MAAAA,IACjB,CACLsO,OAAQ8E,GAAAqT,mBAAAsc,mBACRpc,OAAQ,CACN5M,YAAY,EACZkE,eAAgBxe,KAAAwgB,qBAA0BqG,QAQhD7mB,KAAAqG,KAAU,UAOZsX,UACE3d,KAAAkjC,qBAA0B,CACxBr0B,OAAQ8E,GAAAqT,mBAAAsc,mBACRpc,OAAQ,CACN5M,YAAY,KAOhBta,KAAAqG,KAAU,QAWZif,eAAcie,GACZvjC,KAAAwjC,wBAA+BD,EAAQjpB,YAAeta,KAAAyjC,cACtDzjC,KAAAkjC,qBAA0B,CACxBr0B,OAAQ8E,GAAAqT,mBAAA0c,aACRxc,OAAQlnB,KAAAypB,wBAA6B8Z,KAWzCrvB,oBACElU,KAAAqG,KAAU,SAAUrG,KAAAub,YAMtBjB,aACE,OAAOta,KAAAod,kBAAAI,SAAAjC,WAAAjB,WAOT+G,+BAA8B3C,GAC5B,OAAO1e,KAAA0kB,4BAAAuE,gBAAiD,CACtD0a,YAAajlB,EACb5P,OAAQ,YAUSvO,sBAAAme,GACnB,MAAMklB,oCAGI5jC,KAAAqgB,aAAAyE,aAAAD,aAA4CnG,GAChDmlB,EAAeD,EAAY1c,OAAZ4c,iBAGrB,OADArP,IACOoP,EASStjC,mBAAAme,GAChB,MAAMqlB,QAAkB/jC,KAAAqgB,aAAAyE,aAAAD,aACtBnG,GAGF,OADAqlB,EAAStP,cACFsP,EAASC,UAmBWzjC,8BAAA0jC,EAAAC,EAAyBC,GAAY,GAChE,MAAMC,eAAkBpkC,KAAA4f,sBAAA/e,MAExB,GAAKujC,EAAYH,GAIjB,IAAK,MAAMvlB,KAAW9f,OAAM+B,KAAMyjC,EAAYH,IAAc,CAC1D,MAAMI,EAAQD,EAAYH,GAAYvlB,GACtC1e,KAAA4f,sBAAAve,IACEqd,EACA2lB,EAAKr2B,KACLk2B,EACAG,EAAKC,MAEFH,GACHnkC,KAAA4f,sBAAAmO,OAAkCkW,EAAYvlB,IAsBzBne,4BAAAxC,EAAAC,EAGzBC,EAAS,MAHgBC,EAAAC,GAqBzB,OAdA6B,KAAA6V,kBAAA0sB,aACExkC,EACAC,EACAC,EACAC,EACAC,SAEI6B,KAAAoW,sBAAAmuB,UAAqC,CACzCxmC,OAAAA,EACAC,QAAAA,EACAC,OAAAA,EACAC,SAAAA,EACAC,SAAAA,IAEKJ,EAaSwC,mBAAAxC,EAAAC,EAGhBC,EAAS,MACTC,EAAW,GACXC,EAAW,IAEX,MACM4jB,EADwB/hB,KAAAoW,sBAAAyL,2BACW/f,MACtCkgB,GAAQjkB,IAAWikB,EAAGjkB,SA2BzB,OAxBIgkB,EACF/hB,KAAA6V,kBAAA0sB,aACExgB,EAAWhkB,OACXgkB,EAAW/jB,QACX+jB,EAAW9jB,OACX8jB,EAAW7jB,SACXC,IAGF6B,KAAA6V,kBAAA0sB,aACExkC,EACAC,EACAC,EACAC,EACAC,SAEI6B,KAAAoW,sBAAA8rB,qBACJnkC,EACAC,EACAC,EACAC,EACAC,IAGGJ,EAQSwC,mBAAAxC,SACViC,KAAAoW,sBAAAouB,0BAAqDzmC,GAU7DskC,gBAAeoC,GACb,MAAM3mC,EAAwBkC,KAAAoW,sBAAAyL,2BAC9B,IAAK,MAAM6iB,KAAmB5mC,EAC5B,IAAK,MAAMiB,KAAOH,OAAM+B,KAAM8jC,GAC5B,GAAIC,EAAgB3lC,KAAS0lC,EAAQ1lC,GACnC,OAAO2lC,EAIb,OAAO,KAGenkC,iCAChBP,KAAAggB,mBAAAiY,OAQ0B13B,mCAAAokC,GAChC,MAAMnd,EAAexnB,KAAAoW,sBAAAwf,+BACfgP,EAAW5kC,KAAAoW,sBAAAiV,6BACfsZ,GAGI9N,QAAgB72B,KAAAk5B,oBAAyB9nB,EAAAmnB,aAAAE,QAC/C,OAAI5B,MAAAA,GAAAA,EAAOgO,sBACFhO,EAAOgO,sBAAuBD,GAA9BE,OAA+CtjC,IAIpD,MADAxB,KAAAoW,sBAAAiV,6BAAwD7D,GAClDhmB,KAIHhB,UASTgU,oBAAmBF,GACjB,KAAM,kBAAmBA,GAAY,CACnC,MAAMxM,EAAU9H,KAAAwE,SAAA+P,aAChBD,EAASywB,cAAiB,CACxBj9B,QAAAA,EACAk9B,KAAMC,KAAIC,QAYAC,iBAAAC,GACdplC,KAAAyjC,cAAqB2B,EACrBplC,KAAAwf,uBAAA6lB,OAAqCD,EAQvCE,iBACE,IACEtlC,KAAAmZ,iBAAAosB,cACAvlC,KAAAoa,mBAAAorB,qBACA,MAAAllC,GACAyO,QAAOzO,MAAOA,IAUlBmlC,wBAAuBC,GACrB,MAAMC,EACJn0B,EAAAo0B,gCAAgCF,GACA1lC,KAAAoa,mBAAAtF,MAAAyG,WAChCoqB,GAEuB7mC,SAAU+mC,IACjC7lC,KAAAmZ,iBAAA6a,iBAAuC6R,GACvC7lC,KAAAoa,mBAAAka,mBACEuR,EACAF,MAUNjb,uBAAsBmU,GACpB,OAAO7+B,KAAA8b,mBAAAgqB,OAA+BjH,GAMxCpkB,YACE,MAAMsrB,GAAkB/lC,KAAAod,kBAAAsY,kBACtBtkB,EAAAosB,cAAAhF,QAKF,OAHIuN,GACFA,EAAaC,UAERhmC,KAAAod,kBAAA3C,iSC1iHXtb,EAAAC,QAAA,SAAA6mC,EAAAC,EAAA5mC,GACA,IAAA6mC,EAAA1K,EAAA2K,EAAAC,EAAA5lC,EAGA,SAAA6lC,IACA,IAAAC,EAAAtB,KAAAC,MAAAmB,EAEAE,EAAAL,GAAAK,GAAA,EACAJ,EAAAK,WAAAF,EAAAJ,EAAAK,IAEAJ,EAAA,KACA7mC,IACAmB,EAAAwlC,EAAAQ,MAAAL,EAAA3K,GACA2K,EAAA3K,EAAA,OAXA,MAAAyK,IAAAA,EAAA,KAgBA,IAAAQ,EAAA,WACAN,EAAApmC,KACAy7B,EAAAkL,UACAN,EAAApB,KAAAC,MACA,IAAA0B,EAAAtnC,IAAA6mC,EAOA,OANAA,IAAAA,EAAAK,WAAAF,EAAAJ,IACAU,IACAnmC,EAAAwlC,EAAAQ,MAAAL,EAAA3K,GACA2K,EAAA3K,EAAA,MAGAh7B,GAoBA,OAjBAimC,EAAAG,MAAA,WACAV,IACAW,aAAAX,GACAA,EAAA,OAIAO,EAAAK,MAAA,WACAZ,IACA1lC,EAAAwlC,EAAAQ,MAAAL,EAAA3K,GACA2K,EAAA3K,EAAA,KAEAqL,aAAAX,GACAA,EAAA,OAIAO,+PChEA,IAAAM,EAAAvoC,EAAA,UAYA,SAAAO,EAAAwgC,EAAAyH,EAAApkC,GACA28B,EAAAA,GAAA,SAAAhgC,GAAAQ,KAAAN,MAAAF,IACAynC,EAAAA,GAAA,WAAAjnC,KAAAN,MAAA,OAEA,IAAAmgC,GAAA,EAAAqH,GAAA,EAAAC,EAAA,GAAAC,GAAA,EACAC,EAAA,IAAAL,EAYA,SAAAM,IACA,KAAAH,EAAAvmC,SAAAymC,EAAAE,QAAA,CACA,IAAA/nC,EAAA2nC,EAAAK,QACA,GAAA,OAAAhoC,EACA,OAAA6nC,EAAAhhC,KAAA,OAEAghC,EAAAhhC,KAAA,OAAA7G,IA2BA,SAAAioC,IACAJ,EAAAK,UAAA,EACAT,EAAA1/B,KAAA8/B,IACAA,EAAAM,UAAAN,EAAAO,aACAP,EAAA5G,UAuCA,OAvFA4G,EAAAM,SAAAN,EAAAK,UAAA,EACAL,EAAAE,QAAA,EAGAF,EAAAO,cAAA/kC,IAAA,IAAAA,EAAA+kC,aAEAP,EAAA7H,MAAA,SAAAhgC,GAEA,OADAggC,EAAAj4B,KAAAvH,KAAAR,IACA6nC,EAAAE,QAaAF,EAAA3nC,MAAA2nC,EAAAtG,KAAA,SAAAvhC,GAEA,OAAA4nC,IACA,OAAA5nC,IAAA4nC,GAAA,GACAD,EAAApG,KAAAvhC,GACA8nC,KAHAD,GAaAA,EAAA5uB,GAAA,OAAA,WACA4uB,EAAAM,UAAA,GACAN,EAAAK,UAAAL,EAAAO,aACAnwB,EAAAowB,UAAA,WACAR,EAAA5G,gBAWA4G,EAAAJ,IAAA,SAAAznC,GACA,IAAAqgC,EAIA,OAHAA,GAAA,EACA8G,UAAA/lC,QAAAymC,EAAA7H,MAAAhgC,GACAioC,IACAJ,GAGAA,EAAA5G,QAAA,WACA,IAAAyG,EAMA,OALAA,GAAA,EACArH,GAAA,EACAsH,EAAAvmC,OAAA,EACAymC,EAAAK,SAAAL,EAAAM,UAAA,EACAN,EAAAhhC,KAAA,SACAghC,GAGAA,EAAAS,MAAA,WACA,IAAAT,EAAAE,OAEA,OADAF,EAAAE,QAAA,EACAF,GAGAA,EAAAU,OAAA,WAUA,OATAV,EAAAE,SACAF,EAAAE,QAAA,EACAF,EAAAhhC,KAAA,WAEAihC,IAGAD,EAAAE,QACAF,EAAAhhC,KAAA,SACAghC,GAEAA,EAlGAloC,EAAAC,QAAAJ,EACAA,EAAAA,QAAAA,6PCRA,IAAAgoC,EAAAvoC,EAAA,UACAupC,EAAA,CAAA,QAAA,MAAA,WACAC,EAAA,CAAA,SAAA,SACAC,EAAA,CAAA,OAAA,SACAlgC,EAAAyyB,MAAApzB,UAAAW,MAIA,SAAAlJ,EAAAqpC,EAAAC,GACA,GAAAD,EAAArpC,QACA,OAAAqpC,EAAArpC,QAAAspC,GAGA,IAAA,IAAAC,EAAA,EAAAA,EAAAF,EAAAvnC,OAAAynC,IACAD,EAAAD,EAAAE,GAAAA,GARAlpC,EAAAC,QAYA,SAAAkpC,EAAAC,GACA,IAAAlB,EAAA,IAAAL,EACAnH,GAAA,EAoBA,OAlBA/gC,EAAAkpC,GAoBA,SAAAQ,GAGA,SAAA35B,IACA,OAAAy5B,EAAAE,GAAA/B,MAAA6B,EAAA3B,WAHAU,EAAAmB,GAAA35B,KAnBA/P,EAAAmpC,GA0BA,SAAAO,GAGA,SAAA35B,IACAw4B,EAAAhhC,KAAAmiC,GACA,IAAAvC,EAAAsC,EAAAC,GACA,GAAAvC,EACA,OAAAA,EAAAQ,MAAA8B,EAAA5B,WAEA4B,EAAAliC,KAAAmiC,GARAnB,EAAAmB,GAAA35B,KAzBA/P,EAAAopC,GAqCA,SAAAM,GAGA,SAAAC,IACA,IAAAhN,EAAAzzB,EAAAT,KAAAo/B,WACAlL,EAAAiN,QAAAF,GACAnB,EAAAhhC,KAAAogC,MAAAY,EAAA5L,GALA8M,EAAA9vB,GAAA+vB,EAAAC,MApCAF,EAAA9vB,GAAA,OA6CA,WACA,GAAAonB,EACA,OAEAA,GAAA,EACA,IAAApE,EAAAzzB,EAAAT,KAAAo/B,WACAlL,EAAAiN,QAAA,OACArB,EAAAhhC,KAAAogC,MAAAY,EAAA5L,MAlDA6M,EAAA7vB,GAAA,SAAA,WACA4uB,EAAAhhC,KAAA,YAGAiiC,EAAA7vB,GAAA,QAAAgwB,GACAF,EAAA9vB,GAAA,QAAAgwB,GAEApB,EAAAK,SAAAY,EAAAZ,SACAL,EAAAM,SAAAY,EAAAZ,SAEAN,EA2CA,SAAAoB,EAAAtnC,GACAkmC,EAAAhhC,KAAA,QAAAlF,0NCnFAvC,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACAY,EAAA0jC,mBAAA,EACA,MAAA6F,EAAAlqC,EAAA,UACA,MAAAmqC,UAAAD,EAAAE,OACA9oC,YAAA+oC,GACA9lC,MAAA,CAEAD,YAAA,IAGA/C,KAAA+nC,SAEA/nC,KAAA+oC,QAAAloC,GAAAb,KAAA+gC,KAAAlgC,GAEAb,KAAA8oC,SAAAA,EACA9oC,KAAA8oC,SAAAlyB,UAAA5W,KAAA+oC,SAGAC,KAAAC,EAAA35B,GACA,MAAA7O,EAAAuC,MAAAgmC,KAAAC,EAAA35B,GAEA,OADA25B,EAAAzJ,MAAAx/B,KAAA8oC,SAAAvtB,YACA9a,EAGAyC,OAAAC,EAAA+lC,EAAA7lC,GACArD,KAAA8oC,SAAAxf,SAAAnmB,GACAE,IAGA8lC,MAAAC,GACA,OAAA5oC,UAGA6oC,SAAAloC,EAAAkC,GACArD,KAAA8oC,SAAAQ,YAAAtpC,KAAA+oC,SACA/lC,MAAAqmC,SAAAloC,EAAAkC,IAMAjE,EAAA0jC,cAHA,SAAAgG,GACA,OAAA,IAAAF,EAAAE,oQCvCAlqC,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACAY,EAAAmqC,iBAAA,EACA,MAAAC,EAAA/qC,EAAA,qBACA,MAAA8qC,UAAAC,EAAApgB,gBACArpB,YAAA0pC,EAAA,IACAzmC,QAEAhD,KAAAub,YAEAvb,KAAAspB,SAAA,IAEAtpB,KAAA0pC,UAAAD,EAEAA,EAAA3qC,SAAA6qC,GAAA3pC,KAAA4pC,UAAAD,KACA3pC,KAAA6pC,oBAEAD,UAAAD,GACAA,EAAA/yB,WAAA,IAAA5W,KAAA6pC,sBAEAA,oBACA,MAAAC,EAAA9pC,KAAA0pC,UAAAhoC,KAAAioC,GAAAA,EAAApuB,aAEA1a,EAAAjC,OAAAmrC,OAAA,MAAAD,GACA9pC,KAAAspB,SAAAzoB,IAGAzB,EAAAmqC,YAAAA,qQC1BA3qC,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACAY,EAAA4qC,mBAAA,EACA,MAAAR,EAAA/qC,EAAA,qBACA,MAAAurC,UAAAR,EAAApgB,gBACArpB,YAAA0pC,GACAzmC,QAEAhD,KAAAub,YAEAvb,KAAAspB,SAAA,IAGAtpB,KAAA0pC,UAAAD,GAAA,GACA7qC,OAAA+B,KAAAX,KAAA0pC,WAAA5qC,SAAAmrC,IACA,MAAAN,EAAA3pC,KAAA0pC,UAAAO,GACAjqC,KAAA4pC,UAAAK,EAAAN,MAGAC,UAAAK,EAAAN,GACA,MAAAO,EAAAC,IACA,MAAAtpC,EAAAb,KAAAub,WACA1a,EAAAopC,GAAAE,EACAnqC,KAAAspB,SAAAzoB,IAEA8oC,EAAA/yB,UAAAszB,GACAA,EAAAP,EAAApuB,aAGAnc,EAAA4qC,cAAAA,uQC5BAprC,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACAY,EAAAgrC,uBAAA,EACA,MAAAZ,EAAA/qC,EAAA,qBACA,MAAA2rC,UAAAZ,EAAApgB,gBACArpB,YAAA8C,EAAA,IACA,IAAAwnC,OAAAC,aACA,MAAA,IAAA5hC,MAAA,gDAGA,GADA1F,SACAH,EAAA0nC,WACA,MAAA,IAAA7hC,MAAA,gDAEA1I,KAAAwqC,YAAA3nC,EAAA0nC,WAMAE,YACA,MAAAnQ,EAAA+P,OAAAC,aAAAI,QAAA1qC,KAAAwqC,aACA,OAAAlQ,EAAA2C,KAAAC,MAAA5C,GAAA95B,UAGAmqC,UAAApH,GACA,MAAAjJ,EAAA2C,KAAA2N,UAAArH,GACA,OAAA8G,OAAAC,aAAAO,QAAA7qC,KAAAwqC,YAAAlQ,IAGAl7B,EAAAgrC,kBAAAA,sRC5BA,IAAAU,EAAA9qC,MAAAA,KAAA8qC,iBAAA,SAAAC,GACA,OAAAA,GAAAA,EAAAC,WAAAD,EAAA,CAAA5qC,QAAA4qC,IAEAnsC,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACAY,EAAAgqB,qBAAA,EACA,MAAA6hB,EAAAH,EAAArsC,EAAA,iCACA,MAAA2qB,UAAA6hB,EAAA9qC,QACAJ,YAAAuU,EAAA,IACAtR,QAEAhD,KAAA6D,OAAAyQ,EAGAiH,WACA,OAAAvb,KAAAyqC,YAGAnhB,SAAAia,GACAvjC,KAAA2qC,UAAApH,GACAvjC,KAAAqG,KAAA,SAAAk9B,GAEA2H,YAAAC,GAEA,GAAAA,GAAA,iBAAAA,EAAA,CACA,MAAAtqC,EAAAb,KAAAub,WACAgoB,EAAA3kC,OAAAmrC,OAAA,GAAAlpC,EAAAsqC,GACAnrC,KAAAspB,SAAAia,QAIAvjC,KAAAspB,SAAA6hB,GAIAv0B,UAAAmyB,GACA/oC,KAAAyY,GAAA,SAAAswB,GAGAO,YAAAP,GACA/oC,KAAA0N,eAAA,SAAAq7B,GAMA0B,YACA,OAAAzqC,KAAA6D,OAGA8mC,UAAApH,GACAvjC,KAAA6D,OAAA0/B,GAGAnkC,EAAAgqB,gBAAAA,8PCrDAxqB,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACAY,EAAAgsC,0BAAA,EACA,MAAAC,EAAA5sC,EAAA,YAcAW,EAAAgsC,qBAbA,SAAAE,GACA,OAAAD,EAAAjtC,KAAA,CAAAyC,EAAAqoC,EAAAztB,KACA,IAGA,OADAA,EAAA,KADA6vB,EAAAzqC,IAEAL,UAEA,MAAAW,GAEA,OADAsa,EAAAta,GACAX,mUCbA,IAAAlC,EAAAG,EAAA,gBAMe,CACbqJ,QALc,EAOdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,EAUZ,IATe,oCAUTI,EAAc1I,KAAK5B,OAAOmP,SAASy+B,YACrCtjC,EAAc1I,KAAK5B,OAAOmP,SAASy+B,UAVxB,gCAYb,MAAOjmC,IAGT,OAAOxE,QAAQC,QAAQkH,mSCnB3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,EAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,EAQZ,IACkD,cAA5CI,EAAc1I,KAAK5B,OAAOmP,SAAS/G,OACrCkC,EAAc1I,KAAK5B,OAAOmP,SAAS/G,KAAO,MAC1CkC,EAAc1I,KAAK5B,OAAOmP,SAASy+B,UACjC,4BAEJ,MAAOjmC,IAGT,OAAOxE,QAAQC,QAAQkH,mSCb3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,GAAW,EAAAjlC,EAAAmtC,OAAM,GAAI5qC,EAAO,CAChC6qC,qBAAsB,CACpBC,iBAAkB9qC,EAAM8qC,kBAAoB,MAKhD,cAFOpI,EAASoI,iBAETpI,EAjBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,mSCjB3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,EAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,EAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,GAAW,EAAAjlC,EAAAmtC,OAAM,GAAI5qC,EAAO,CAChCoa,mBAAoB,CAClB6wB,gBAAiBjrC,EAAMkrC,aAAelrC,EAAMmrC,cAAgB,MAC5DC,eAAgBprC,EAAMorC,eACtBC,eAAgBrrC,EAAMqrC,kBAQ1B,cALO3I,EAASwI,mBACTxI,EAASyI,oBACTzI,EAAS0I,sBACT1I,EAAS2I,eAET3I,EAtBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,wBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,gVCjB3B,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,GACXyf,sBAAEA,GAA0BijB,EAClC,GAAIjjB,GAAyBA,EAAsBkX,aAAc,CAC/D,MAAMA,aAAEA,GAAiB+L,EAASjjB,sBAClCijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KAAKggB,KACzDA,EAAO5S,SAAWmC,EAAAsQ,qBAAqBE,QAGxCC,EAAOyqB,WAAa,GAAKzqB,EAAOyqB,WAAa,IAC/CzqB,EAAO5S,OAASmC,EAAAsQ,qBAAqB4H,iBAC9BzH,EAAOvgB,KAJPugB,KASb,OAAO6hB,EAzBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,gVCjB3B,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,GACXyf,sBAAEA,GAA0BijB,EAClC,GAAIjjB,GAAyBA,EAAsBkX,aAAc,CAC/D,MAAMA,aAAEA,GAAiBlX,EACzBijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KAAKggB,GACzDA,EAAOvgB,KAEsB,2BAAvBugB,EAAOvgB,IAAI+C,UACpBwd,EAAO5S,OAASmC,EAAAsQ,qBAAqBE,QAEhCC,GAJEA,IAOb,OAAO6hB,EAvBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,oSClB3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAIdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QANP,GAOZ,IACE,MAAMjH,EAAQqH,EAAc1I,KAC5B0I,EAAc1I,KASpB,SAAwBqB,GACtB,IAAKA,EAAMyc,oBAAsBzc,EAAMhD,sBACrC,OAAOgD,EAGT,IAAKA,EAAMyc,kBAAkB8uB,gBAC3B,OAAOvrC,EAaT,OAVAA,EAAMhD,sBAAsBggB,WAAajf,OAAO+B,KAC9CE,EAAMyc,kBAAkB8uB,iBACxBtV,QAAO,CAACjZ,EAAYa,KACpBb,EAAWa,GAAW,CACpB1Q,KAAMnN,EAAMyc,kBAAkB8uB,gBAAgB1tB,GAC9CA,QAAAA,GAEKb,IACN,WACIhd,EAAMyc,kBAAkB8uB,gBACxBvrC,EA5BkB+qC,CAAe/qC,GACpC,MAAOM,GAEP,OADA4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAC3C9qC,QAAQE,OAAOE,GAExB,OAAOJ,QAAQC,QAAQkH,mSCjB3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,GACXjD,OAAEA,GAAW2lC,EACf3lC,GAAUA,EAAOmP,UACU,YAAzBnP,EAAOmP,SAAS/G,OAClBu9B,EAAS3lC,OAAOmP,SAAS/G,KAAO,WAGpC,OAAOu9B,EAjBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,mSCjB3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAIjB,OAHA0iC,EAASztB,kBAAoB,GAC7BytB,EAASztB,kBAAkB/I,SAAWw2B,EAAS3lC,OAAOmP,gBAC/Cw2B,EAAS3lC,OAAOmP,SAChBw2B,EAdcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,oSCjB3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAEjB,GAAI0iC,EAAS1lC,uBAET0lC,EAAS1lC,sBAAsB8lB,QAC/B4f,EAAS1lC,sBAAsBggB,WAC/B,CACA,MAAMA,WAAEA,EAAF8F,OAAcA,GAAW4f,EAAS1lC,sBACxC0lC,EAAS1lC,sBAAsBwuC,cAAgB,GAC/CztC,OAAO+B,KAAKkd,GAAY/e,SAASwtC,IAC/B/I,EAAS1lC,sBAAsBwuC,cAAcC,GAAY,CACvDC,QAAS5oB,MAGb4f,EAAS1lC,sBAAsB8lB,OAAS,GAI5C,OAAO4f,EAzBYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,gVCbX,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAEjB,GAAI0iC,EAASjjB,uBACPijB,EAASjjB,sBAAsBkX,aAAc,CAC/C,MAAMA,aAAEA,GAAiB+L,EAASjjB,sBAClCijB,EAASjjB,sBAAsBkX,aAAeA,EAAanvB,QACxDqZ,GAAWA,EAAO5S,SAAWmC,EAAAsQ,qBAAqBirB,WAKzD,OAAOjJ,EAlBYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,gVCbX,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EACjB,IAAK0iC,EAASjjB,sBACZ,OAAOijB,EAET,MAAM/L,aAAEA,GAAiB+L,EAASjjB,sBAalC,OAZAijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KACzD,CAACggB,EAAQnc,KAELmc,EAAO5S,SAAWmC,EAAAsQ,qBAAqBkrB,YACvC/qB,EAAOW,UACPX,EAAOW,SAAS8S,OAEhBzT,EAAOW,SAAS8S,KAAOzT,EAAOW,SAAS8S,KAAKvzB,eAEvC8f,KAGJ6hB,EAxBYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,mSCrBX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GACtB,MAAMhD,sBAAEA,GAA0BgD,EAElC,GAAIhD,EAAuB,CACzB,MAAM6uC,EAAe7uC,EAAsB6uC,cAAgB,QAEnB,IAA7BA,EAAaC,oBACfD,EAAaC,YAIxB,OAAO9rC,EAhBgB+qC,CAAe/qC,GAC7BqH,kVCdX,IAAA5J,EAAAG,EAAA,UACA8S,EAAA9S,EAAA,2CAEA,MAIMmuC,EAAmB,MAEzB,SAAAC,EAAkBC,EAAQ,IACxB,OACEA,GACiB,iBAAVA,GANiB,QAOxBA,EAAKC,QARuB,gDAS5B,EAAAx7B,EAAA8kB,sBAAqByW,EAAKpuB,eAWf,CACb5W,QAvBc,GAwBdvH,cAAAgrC,GACE,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAaK,KAAbT,QA1BY,GA2BZ,MAAMjH,EAAQqH,EAAa1I,KAE3B,OADA0I,EAAa1I,KAKjB,SAAAqB,GACE,MAAMhD,yBAA4BgD,EAElC,GAAIhD,EAAuB,CACzB,MAAM8lB,EAAS9lB,EAAqB8lB,QAAW,GAC/C,GAAI8W,MAAKuS,QAASrpB,GAChB,IAAK,MAAMmpB,KAASnpB,EACdkpB,EAASC,KACXA,EAAKC,OAAUH,GAKrB,MAAMP,EAAgBxuC,EAAqBwuC,eAAkB,GAC7D,GAAIA,GAA0C,iBAAlBA,EAC1B,IAAK,MAAM3tB,KAAW9f,OAAM+B,KAAM0rC,GAAgB,CAChD,MAAMY,EAAgBZ,EAAc3tB,GACpC,GAAIuuB,GAA0C,iBAAlBA,EAC1B,IAAK,MAAM12B,KAAW3X,OAAM+B,KAAMssC,GAAgB,CAChD,MAAMC,EAAkBD,EAAc12B,GACtC,GAAIkkB,MAAKuS,QAASE,GAChB,IAAK,MAAMJ,KAASI,EACdL,EAASC,KACXA,EAAKC,OAAUH,KAU/B,OAAO/rC,EAtCgB+qC,CAAe/qC,GAC7BqH,4UChCX,IAAA5J,EAAAG,EAAA,UACA0S,EAAA1S,EAAA,2CAsBe,CACbqJ,QATc,GAUdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAZP,GAaZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,EAAQ,IAC9B,GAAIA,EAAMhD,sBAAuB,CAC/B,MAAMwuC,cACJA,EADIc,oBAEJA,EAFIrvC,sBAGJA,GACE+C,EAAMhD,sBAEJuvC,EAAmB,GACnBC,EAAyB,GAE/B,GAAIhB,GAAiBztC,OAAO+B,KAAK0rC,GAAezrC,OAAS,EAAG,CAC1D,IAAK,MAAM8d,KAAW9f,OAAO+B,KAAK0rC,GAAgB,CAChDe,EAAiB1uB,GAAW,GACxB2tB,EAAc3tB,GAASvN,EAAAm8B,mBACzBxvC,EAAsBgB,SAASyuC,IAC7BH,EAAiB1uB,GAAS6uB,EAAOvvC,SAC/BquC,EAAc3tB,GAASvN,EAAAm8B,qBAG7B,IAAK,MAAME,KAAgB5uC,OAAO+B,KAAK0rC,EAAc3tB,IACnD,OAAQ8uB,GACN,KAAKr8B,EAAAs8B,QACHL,EAAiB1uB,GAASvN,EAAA6I,kBACxBqyB,EAAc3tB,GAASvN,EAAAs8B,SACzB,MACF,KAAKt8B,EAAAu8B,QACHN,EAAiB1uB,GAASvN,EAAAw8B,kBACxBtB,EAAc3tB,GAASvN,EAAAu8B,SACzB,MACF,KAAKv8B,EAAAy8B,QACHR,EAAiB1uB,GAASvN,EAAA08B,kBACxBxB,EAAc3tB,GAASvN,EAAAy8B,SACzB,MACF,KAAKz8B,EAAA28B,OACHV,EAAiB1uB,GAASvN,EAAA48B,iBACxB1B,EAAc3tB,GAASvN,EAAA28B,QACzB,MACF,KAAK38B,EAAA68B,MACHZ,EAAiB1uB,GAASvN,EAAA88B,gBACxB5B,EAAc3tB,GAASvN,EAAA68B,QAOjCntC,EAAMhD,sBAAsBwuC,cAAgBe,EAG9C,GAAID,GAAuBvuC,OAAO+B,KAAKwsC,GAAqBvsC,OAAS,EAAG,CACtE,IAAK,MAAM8d,KAAW9f,OAAO+B,KAAKwsC,GAAsB,CACtDE,EAAuB3uB,GAAW,GAC9ByuB,EAAoBzuB,GAASvN,EAAAm8B,mBAC/BxvC,EAAsBgB,SAASyuC,IAC7BF,EAAuB3uB,GAAS6uB,EAAOvvC,SACrCmvC,EAAoBzuB,GAASvN,EAAAm8B,qBAGnC,IAAK,MAAME,KAAgB5uC,OAAO+B,KAAKwsC,EAAoBzuB,IACzD,OAAQ8uB,GACN,KAAKr8B,EAAAs8B,QACHJ,EAAuB3uB,GAASvN,EAAA6I,kBAC9BmzB,EAAoBzuB,GAASvN,EAAAs8B,SAC/B,MACF,KAAKt8B,EAAAu8B,QACHL,EAAuB3uB,GAASvN,EAAAw8B,kBAC9BR,EAAoBzuB,GAASvN,EAAAu8B,SAC/B,MACF,KAAKv8B,EAAAy8B,QACHP,EAAuB3uB,GAASvN,EAAA08B,kBAC9BV,EAAoBzuB,GAASvN,EAAAy8B,SAC/B,MACF,KAAKz8B,EAAA28B,OACHT,EAAuB3uB,GAASvN,EAAA48B,iBAC9BZ,EAAoBzuB,GAASvN,EAAA28B,QAC/B,MACF,KAAK38B,EAAA68B,MACHX,EAAuB3uB,GAASvN,EAAA88B,gBAC9Bd,EAAoBzuB,GAASvN,EAAA68B,QAOvCntC,EAAMhD,sBAAsBsvC,oBAAsBE,GAGtD,OAAOxsC,EA9FgB+qC,CAAe/qC,GAC7BqH,mSC9BX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GACtB,MAAMhD,sBAAEA,GAA0BgD,EAElC,GAAIhD,EAAuB,CACzB,MAAMqwC,OAAEA,GAAWrwC,EAAsB6uC,cAAgB,GAGzD7uC,EAAsBswC,qBAAuBD,EAG/C,OAAOrtC,EAfgB+qC,CAAe/qC,GAC7BqH,mSCdX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAAutC,OAG3B,KADOvtC,MAAAA,GAAP,QAAAutC,EAAOvtC,EAAO0Z,0BAAd,IAAA6zB,OAAA,EAAOA,EAA2BC,uCAG3BxtC,EAAM0Z,mBAAmB8zB,8BAElC,OAAOxtC,EAZgB+qC,CAAe/qC,GAC7BqH,+UCPX,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,GACXyf,sBAAEA,GAA0BijB,EAClC,GAAIjjB,GAAyBA,EAAsBkX,aAAc,CAC/D,MAAMA,aAAEA,GAAiB+L,EAASjjB,sBAElCijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KAAKggB,GACzDA,EAAOvgB,KAIK,yDAAfugB,EAAOvgB,MAEPugB,EAAO5S,OAASmC,EAAAsQ,qBAAqB4H,iBAC9BzH,EAAOvgB,KAETugB,GAREA,IAWb,OAAO6hB,EA5BcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,oSCzB3B,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAClBA,EAAMhD,uBAAyBgD,EAAMhD,sBAAsB4hB,cAC7D5e,EAAMhD,sBAAsB4hB,YAAY6uB,kBACtCztC,EAAMhD,sBAAsB4hB,YAAY8uB,2BACnC1tC,EAAMhD,sBAAsB4hB,YAAY8uB,qBAEjD,OAAO1tC,EAXgB+qC,CAAe/qC,GAC7BqH,mSCdX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAAgrC,GACE,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAaK,KAAbT,QATY,GAUZ,MAAMjH,EAAQqH,EAAa1I,KAE3B,OADA0I,EAAa1I,KAOjB,SAAAqB,GAA+B,IAAA2tC,EACzBC,EAAgBvgC,SAAUrN,MAAAA,GAA1B,QAAA2tC,EAA0B3tC,EAAKhD,6BAA/B,IAAA2wC,OAAA,EAA0BA,EAAArgC,eAC5BtN,EAAKhD,sBAALsQ,YAA0C,aAE5C,OAAOtN,EAXgB+qC,CAAe/qC,GAC7BqH,gBAIX,MAAMumC,EAAmB,CAAC,UAAW,kVCZrC,IAAAnwC,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,GACXyf,sBAAEA,GAA0BijB,EAClC,GAAIjjB,GAAyBA,EAAsBkX,aAAc,CAC/D,MAAMA,aAAEA,GAAiB+L,EAASjjB,sBAElCijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KAAKggB,IAE5DA,EAAO5S,SAAWmC,EAAAsQ,qBAAqB4H,WACvCzH,EAAOgtB,gBAIThtB,EAAOgtB,eAAgB,IAAIzJ,MAAO0J,WAFzBjtB,KAMb,OAAO6hB,EA1BcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,oSCxB3B,IAAA5J,EAAAG,EAAA,gBAQe,CACbqJ,QAPc,GAQdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAVP,GAWZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAClBA,EAAM0Z,mBACR1Z,EAAM0Z,mBAAmBq0B,oCAAqC,EAE9D/tC,EAAM0Z,mBAAqB,CACzBq0B,oCAAoC,GAGxC,OAAO/tC,EAbgB+qC,CAAe/qC,GAC7BqH,mSCRX,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAEbA,EAAMguC,yBACDtL,EAASsL,iBAElB,OAAOtL,EAZYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,mSCpBX,IAAA5J,EAAAG,EAAA,gBAQe,CACbqJ,QAPc,GAQdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAVP,GAWZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GACtB,MAAMhD,sBAAEA,GAA0BgD,EAElC,GAAIhD,EAAuB,CACzB,MAAM6uC,EAAe7uC,EAAsB6uC,cAAgB,GAGxDA,EAAaC,kBACuC,IAA9C9uC,EAAsBixC,sBAG7BjxC,EAAsBixC,qBAAsB,EAC5CpC,EAAaC,aAAc,GAI/B,OAAO9rC,EArBgB+qC,CAAe/qC,GAC7BqH,mSCfX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAAkuC,EAC7B,MAAMvX,EAAe32B,MAAAA,GAAH,QAAAkuC,EAAGluC,EAAOyf,6BAAV,IAAAyuB,OAAA,EAAGA,EAA8BvX,aAC/CiD,MAAMuS,QAAQxV,IAChBA,EAAa14B,SAASkwC,IACyB,iBAAlCA,EAAYC,oBACrBD,EAAYC,kBAAoBD,EAAYC,kBAAkB9R,eAIpE,OAAOt8B,EAdgB+qC,CAAe/qC,GAC7BqH,mSCdX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAAutC,EAG7B,OAFA,QAAAA,EAAOvtC,EAAM0Z,0BAAb,IAAA6zB,UAAOA,EAA0Bc,gCAE1BruC,EARgB+qC,CAAe/qC,GAC7BqH,mSCbX,IAAA5J,EAAAG,EAAA,gBAQe,CACbqJ,QAPc,GASdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAXP,GAYZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAMyc,kBAAEA,EAAFzf,sBAAqBA,GAA0BgD,EAErD,GAAIyc,GAAqBzf,EAAuB,CAC9C,MAAM6rB,MAAEA,GAAUpM,EAClBzf,EAAsBsoB,oBAAsBjmB,QAAQwpB,GAGtD,OAAO7oB,EAdY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,gVClBX,IAAA5J,EAAAG,EAAA,UAQAwS,EAAAxS,EAAA,+CAQe,CACbqJ,QAPc,GAQdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAVP,GAWZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAAkuC,EAC7B,MAAMvX,EAAe32B,MAAAA,GAAH,QAAAkuC,EAAGluC,EAAOyf,6BAAV,IAAAyuB,OAAA,EAAGA,EAA8BvX,aACnD,IAAI,EAAAl5B,EAAA6wC,eAAc3X,GAAe,CAC/B,MAAM4X,GAA4B,EAAA9wC,EAAA+wC,SAChCzwC,OAAO64B,OAAOD,IACbE,IAAO,IAAA4X,EAAAC,EACN,MAAQ,GAAD,QAAAD,EAAG5X,EAAGrV,gBAAN,IAAAitB,OAAA,EAAGA,EAAaE,SAAhB,QAAAD,EAAyB7X,EAAG15B,eAA5B,IAAAuxC,EAAAA,EAAuC7X,EAAGuX,uBAI/CQ,GAAiB,EAAAnxC,EAAAoxC,QAAON,GAA4BO,GACjDA,EAAMC,MACVlY,GACCA,EAAG1xB,OAASiL,EAAAkR,kBAAkB0tB,QAC9BnY,EAAG1xB,OAASiL,EAAAkR,kBAAkB2tB,UAGpCjvC,EAAMyf,sBAAsBkX,cAAe,EAAAl5B,EAAAyxC,QACzC,EAAAzxC,EAAAo7B,WAAU96B,OAAO64B,OAAOgY,KACvB/X,GAAOA,EAAGzyB,KAIf,OAAOpE,EA5BgB+qC,CAAe/qC,GAC7BqH,mSCvBX,IAAA5J,EAAAG,EAAA,gBASe,CACbqJ,QARc,GASdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAXP,GAaZ,MAAMjK,sBAAEA,GAA0BqK,EAAc1I,KAiChD,OA/BIi7B,MAAMuS,QAAQnvC,MAAAA,OAAd,EAAcA,EAAuB8lB,UACvC9lB,EAAsB8lB,OAAS9lB,EAAsB8lB,OAAOtb,QAC1D,EAAGqW,QAAAA,KAAcA,KAKnB7gB,MAAAA,GAAAA,EAAuBwuC,eACwB,iBAAxCxuC,EAAsBwuC,eAE7BztC,OAAO+B,KAAK9C,EAAsBwuC,eAAevtC,SAASkxC,IACzCpxC,OAAO+B,KACpB9C,EAAsBwuC,cAAc2D,IAE/BlxC,SAASmxC,IACdpyC,EAAsBwuC,cAAc2D,GAClCC,GACEpyC,EAAsBwuC,cAAc2D,GAASC,GAAO5nC,QACtD,EAAGqW,QAAAA,KAAcA,UAOvB7gB,MAAAA,GAAAA,EAAuBqyC,aACvB,cAAeryC,EAAsBqyC,oBAE9BryC,EAAsBqyC,YAAY1vC,UAGpC0H,mSChDX,IAAA5J,EAAAG,EAAA,UAEA,MAEM0xC,EAA4B,CAChC,8CACA,+BACA,cACA,uCACA,wBACA,mCACA,kDACA,mCACA,2BAMa,CACbroC,QAlBc,GAmBdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAOhC,OANArjC,EAAcK,KAAKT,QArBP,GAuBZqoC,EAA0BrxC,SAASC,IAAD,IAAAqxC,EAAA,OAAA,QAAAA,EAChCzqC,OAAO2kC,oBADyB,IAAA8F,OAAA,EAChCA,EAAqBC,WAAWtxC,MAG3BmJ,mSC7BX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,QACiB,KAA5BA,MAAAA,OAAP,EAAOA,EAAOyvC,0BACTzvC,EAAMyvC,iBAEf,OAAOzvC,EATgB+qC,CAAe/qC,GAC7BqH,mSCdX,IAAA5J,EAAAG,EAAA,gBASe,CACbqJ,QARc,GASdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAXP,GAYZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAEtB,cADOA,EAAM0vC,2BACN1vC,EAPgB+qC,CAAe/qC,GAC7BqH,4UChBX,IAAA5J,EAAAG,EAAA,UACA0S,EAAA1S,EAAA,2CAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAA2vC,EAAAC,EAC7B,MAAMzyC,QAAEA,EAAFgI,KAAWA,IAASnF,MAAAA,GAAA,QAAA2vC,EAAA3vC,EAAOiV,yBAAP,IAAA06B,OAAA,EAAAA,EAA0BzjC,WAAY,GAC1D2jC,EAAW,QAAAD,EAAGt/B,EAAAw/B,uBAAuB3qC,UAA1B,IAAAyqC,OAAA,EAAGA,EAA8BzyC,QAE9C0yC,GAAe1yC,IAAY0yC,IAC7B7vC,EAAMiV,kBAAkB/I,SAAS/O,QAAU0yC,GAE7C,OAAO7vC,EAZgB+qC,CAAe/qC,GAC7BqH,mSCfX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM+vC,GAAc,IAAI3L,MAAO0J,UAC3B9tC,EAAM0Z,oBACR1Z,EAAM0Z,mBAAmBs2B,oCAAqC,EAC9DhwC,EAAM0Z,mBAAmBu2B,gCAAkCF,GAE3D/vC,EAAM0Z,mBAAqB,CACzBs2B,oCAAoC,EACpCC,gCAAiCF,GAGrC,OAAO/vC,EAjBY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,mSCRX,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EACjB,GAAIA,EAAMhD,sBAAuB,CAC/B,MAAMC,sBAAEA,GAA0BylC,EAAS1lC,sBACvCC,IACFA,EAAsBgB,SAAQ,CAACkjB,EAAK6X,KAE9B35B,QAAQ8hB,EAAIhkB,UAAY+yC,OAAOC,MAAMhX,SAAShY,EAAIhkB,kBAC7CF,EAAsB+7B,GAAO77B,WAGxCulC,EAAS1lC,sBAAsBC,sBAAwBA,GAGvD+C,EAAMiV,oBAENytB,EAASztB,kBAAkBS,SAE3Bw6B,OAAOC,MAAMhX,SAASuJ,EAASztB,kBAAkBS,kBAE1CgtB,EAASztB,kBAAkBS,QAIlCgtB,EAASztB,kBAAkB/I,UAC3Bw2B,EAASztB,kBAAkB/I,SAAS/O,SAEpC+yC,OAAOC,MAAMhX,SAASuJ,EAASztB,kBAAkB/I,SAAS/O,kBAEnDulC,EAASztB,kBAAkB/I,SAAS/O,SAI/C,OAAOulC,EAvCYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,gVCdX,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,GAEXyf,sBAAEA,GAA0BijB,EAClC,GAAIjjB,GAAyBA,EAAsBkX,aAAc,CAC/D,MAAMA,aAAEA,GAAiB+L,EAASjjB,sBAElC,GAAIkX,EAAa52B,QAAU,GACzB,OAAO2iC,EAGT,MAAM0N,EAAgBzZ,EAAa0Z,UACnC,IAAIC,GAAY,EAChB,KAAOF,EAAcrwC,OAAS,IAAMuwC,GAAW,CAC7C,MAAMC,EAAUH,EAAcI,WAAW3vB,GAErCA,EAAO5S,SAAWmC,EAAAsQ,qBAAqBE,QACvCC,EAAO5S,SAAWmC,EAAAsQ,qBAAqBirB,UACvC9qB,EAAO5S,SAAWmC,EAAAsQ,qBAAqBC,WACvCE,EAAO5S,SAAWmC,EAAAsQ,qBAAqB+vB,UAGvCF,EAAU,EACZD,GAAY,EAEZF,EAAcM,OAAOH,EAAS,GAIlC7N,EAASjjB,sBAAsBkX,aAAeyZ,EAAcC,UAE9D,OAAO3N,EAxCcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,kWClB3B,IAAA5J,EAAAG,EAAA,UACAqB,EAAArB,EAAA,eACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAEjB,GAAI0iC,EAASjjB,uBACPijB,EAASjjB,sBAAsBkX,aAAc,CAC/C,MAAMA,aAAEA,GAAiB+L,EAASjjB,sBAClCijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KACxDggB,IACKA,EAAO5S,SAAWmC,EAAAsQ,qBAAqBkrB,aAG3C/qB,EAAOW,SAUjB,SAA2BA,GAEzB,MAAMmvB,EAAY,CAChBrc,KAAOA,IAAS,EAAAr1B,EAAA2xC,cAAatc,GAAMvzB,cACnC8vC,GAAI,KAAM,EAAA5xC,EAAA2xC,cAAapvB,EAASqvB,IAAI9vC,cACpC4tC,MAAQA,IAAU,EAAA1vC,EAAA2xC,cAAajC,GAC/BhxC,MAAQA,IAAU,EAAAsB,EAAA2xC,cAAajzC,GAC/BgB,KAAOA,IAAS,EAAAM,EAAA2xC,cAAajyC,GAC7BmyC,IAAMA,IAAQ,EAAA7xC,EAAA2xC,cAAaE,GAC3BC,SAAWA,IAAa,EAAA9xC,EAAA2xC,cAAaG,IAIjCC,EAAqB,GAO3B,OANAjzC,OAAO+B,KAAK6wC,GAAW1yC,SAASC,IAC1BsjB,EAAStjB,KACX8yC,EAAmB9yC,GAAOyyC,EAAUzyC,GAAKsjB,EAAStjB,QAI/C8yC,EA9BmBC,CAAkBpwB,EAAOW,WAFlCX,KASjB,OAAO6hB,EAxBYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,gVCdX,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,+CAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,GACXyf,sBAAEA,GAA0BijB,EAClC,GAAIjjB,GAAyBA,EAAsBkX,aAAc,CAC/D,MAAMA,aAAEA,GAAiB+L,EAASjjB,sBAElCijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KACzD,CAACggB,EAAQnc,EAAGwsC,KACV,GAAIrwB,EAAO5S,SAAWmC,EAAAsQ,qBAAqB4H,UACzC,OAAOzH,EAGT,MAMMswB,EA8Cd,SAAyBD,GACvB,MAAME,EAASF,EAAOrwC,KAAKggB,IACzB,MAAM8tB,MAAEA,GAAU9tB,EAAOW,SACzB,OAAO2X,SAASwV,GAAS,MAAO,OAGlC,OADqB5pC,KAAKC,IAAI4gC,MAAM,KAAMwL,GAnDNC,CANTH,EAClB1pC,QAAQqvB,GAAOA,EAAG5oB,SAAWmC,EAAAsQ,qBAAqBC,YAClDnZ,QAAQqvB,GAAOA,EAAGrV,SAAS8S,OAASzT,EAAOW,SAAS8S,OACpD9sB,QACEqvB,GAAOA,EAAGuX,kBAAkB9Z,OAASzT,EAAOutB,kBAAkB9Z,QAU7Dgd,EAwBd,SAAkCJ,EAAQK,GACxC,MAAMH,EAASF,EAAOrwC,KAAKggB,IACzB,MAAM8tB,MAAEA,GAAU9tB,EAAOW,SACzB,OAAO2X,SAASwV,EAAO,OAGzB,IAAI6C,EAAUD,EACd,KAAOH,EAAO/jC,SAASmkC,IACrBA,GAAW,EAGb,OAAOA,EAnC8BC,CANZP,EAChB1pC,QAAQqvB,GAAOA,EAAG5oB,SAAWmC,EAAAsQ,qBAAqB4H,YAClD9gB,QAAQqvB,GAAOA,EAAGrV,SAAS8S,OAASzT,EAAOW,SAAS8S,OACpD9sB,QACEqvB,GAAOA,EAAGuX,kBAAkB9Z,OAASzT,EAAOutB,kBAAkB9Z,OAIjE6c,GAGIO,EAAW3sC,KAAKC,IACpBssC,EACAH,GAUF,OAPIhY,SAAStY,EAAOW,SAASmtB,MAAO,IAAM+C,EAAW,IACnD7wB,EAAO5S,OAASmC,EAAAsQ,qBAAqBE,OACrCC,EAAOvgB,IAAM,CACX+C,QAAS,iBACTsuC,KAAM,+BAGH9wB,KAIb,OAAO6hB,EAxDcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,6UCzB3B,IAAA5J,EAAAG,EAAA,UACA0S,EAAA1S,EAAA,2CAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAOlB,SAAwBqB,GAAO,IAAA4xC,EAE3B5xC,MAAAA,GADF,QAAA4xC,EACE5xC,EAAO6b,sCADT,IAAA+1B,GACEA,EAAuCC,uCAEvC7xC,EAAM6b,+BAA+Bi2B,qCAAsC,EAAAr0C,EAAAs0C,SACzE/xC,EAAM6b,+BAA+Bg2B,sCAIrC,CAACntC,EAAGxG,KAAJ,IAAA0xC,EAAAoC,EAAA,OAAA,QAAApC,EAAA,QAAAoC,EAAY1hC,EAAAw/B,uBAAuB5xC,UAAnC,IAAA8zC,OAAA,EAAYA,EAA6B70C,eAAzC,IAAAyyC,EAAAA,EAAoDqC,YAM/CjyC,EAAM6b,+BACVi2B,oCADI,eAEA9xC,EAAM6b,+BACVg2B,sCAEL,OAAO7xC,EA3BgB+qC,CAAe/qC,GAC7BqH,gBAIX,MAAM4qC,EAAuB,6RCnB7B,IAAAx0C,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MACMy7B,EAMV,SAAwB1iC,GACtB,GAAIA,EAAMiY,sBAAuB,CAC/B,MAAMi6B,qBAAEA,GAAyBlyC,EAAMiY,sBACnCi6B,IAAyBvyC,kBACpBK,EAAMiY,sBAAsBi6B,qBAGvC,OAAOlyC,EAbY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,mSCfX,IAAA5J,EAAAG,EAAA,UAIA,SAASu0C,EAAgBC,GACvB,MACsB,iBAAbA,GACc,iBAAbA,GAAyBA,EAASC,MAAM,qBAQrC,CACbprC,QAdc,GAedvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAjBP,GAkBZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAEjB,IAAK0iC,EAAS1lC,sBACZ,OAAO0lC,EAGT,MAEM4P,GAFS5P,EAAS1lC,sBAAsB8lB,QAAU,IAE7Btb,QAAO,EAAG4qC,SAAAA,KACnCD,EAAgBC,KAElB,IAAK,MAAMnG,KAASqG,EAEY,iBAAnBrG,EAAMmG,WAEfnG,EAAMmG,SAAWjZ,SAAS8S,EAAMmG,WAGpC1P,EAAS1lC,sBAAsB8lB,OAASwvB,EAExC,MAAM9G,cAAEA,GAAkB9I,EAAS1lC,sBACnC,GAAIwuC,GAA0C,iBAAlBA,EAC1B,IAAK,MAAM3tB,KAAW9f,OAAO+B,KAAK0rC,GAAgB,CAChD,MAAMY,EAAgBZ,EAAc3tB,GACpC,GAAIuuB,GAA0C,iBAAlBA,EAC1B,IAAK,MAAM12B,KAAW3X,OAAO+B,KAAKssC,GAAgB,CAChD,MAEMmG,GAFkBnG,EAAc12B,IAAY,IAELlO,QAAO,EAAG4qC,SAAAA,KACrDD,EAAgBC,KAGlB,IAAK,MAAMnG,KAASsG,EACY,iBAAnBtG,EAAMmG,WAEfnG,EAAMmG,SAAWjZ,SAAS8S,EAAMmG,WAGpChG,EAAc12B,GAAW68B,GAOjC,OAFA7P,EAAS1lC,sBAAsBwuC,cAAgBA,EAExC9I,EApDYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,mSCvBX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,EAAQ,IAC9B,GAAIA,EAAMhD,sBAAuB,CAAA,IAAAw1C,EAC/B,MAAMC,cACJA,EADIpyB,yBAEJA,EAFI6xB,qBAGJA,GACElyC,EAAMhD,sBACVgD,EAAMiY,sBAAN,QAAAu6B,EAA8BxyC,EAAMiY,6BAApC,IAAAu6B,EAAAA,EAA6D,GAEzDC,IAAkB9yC,YACpBK,EAAMiY,sBAAsBw6B,cAAgBA,SACrCzyC,EAAMhD,sBAAsBy1C,eAGjCpyB,IAA6B1gB,YAC/BK,EAAMiY,sBAAsBoI,yBAA2BA,SAChDrgB,EAAMhD,sBAAsBqjB,0BAGjC6xB,IAAyBvyC,YAC3BK,EAAMiY,sBAAsBi6B,qBAAuBA,SAC5ClyC,EAAMhD,sBAAsBk1C,sBAGvC,OAAOlyC,EA7BgB+qC,CAAe/qC,GAC7BqH,mSCdX,IAAA5J,EAAAG,EAAA,UAEA,MAEM80C,EAA4B,mBAKnB,CACbzrC,QARc,GASdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAXP,GAYZ,MACMy7B,EAMV,SAAwB1iC,GAAO,IAAA2yC,EAC7B,MAAMC,EAAgB5yC,MAAAA,GAAH,QAAA2yC,EAAG3yC,EAAOob,8BAAV,IAAAu3B,OAAA,EAAGA,EAA+BC,cACnB,IAAAC,GAA9B,EAAAp1C,EAAA6wC,eAAcsE,KAEd,QAAAC,EAAAD,EAtB2B,UAsB3B,IAAAC,OAAA,EAAAA,EAAyC1O,QACzCuO,UAEO1yC,EAAMob,uBAAuBw3B,cAzBT,GA8B/B,OAAO5yC,EAlBY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,gVCjBX,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,yCAEA,MAEMk1C,EAAa,kBAKJ,CACb7rC,QARc,GASdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAXP,GAYZ,MACMy7B,EAMV,SAAwB1iC,GAAO,IAAAkuC,EAC7B,MAAMvX,EAAe32B,MAAAA,GAAH,QAAAkuC,EAAGluC,EAAOyf,6BAAV,IAAAyuB,OAAA,EAAGA,EAA8BvX,aACnD,IAAI,EAAAl5B,EAAA6wC,eAAc3X,GAChB,IAAK,MAAME,KAAM94B,OAAO64B,OAAOD,GACzBE,EAAG1xB,OAAS2tC,IACdjc,EAAG1xB,KAAOiL,EAAAkR,kBAAkByxB,aAE1Blc,EAAGmc,SACLnc,EAAGmc,QAAQnyC,KAAKoyC,IACVA,EAAQ9tC,MAAQ8tC,EAAQ9tC,OAAS2tC,IACnCG,EAAQ9tC,KAAOiL,EAAAkR,kBAAkByxB,aAE5BE,KAKf,OAAOjzC,EAvBY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,mSClBX,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAA2tC,EACzB3tC,MAAAA,GAAJ,QAAA2tC,EAAI3tC,EAAOhD,6BAAX,IAAA2wC,GAAIA,EAA8BuF,0BACzBlzC,EAAMhD,sBAAsBk2C,kBAErC,OAAOlzC,EATgB+qC,CAAe/qC,GAC7BqH,kSCRX,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAGjB,cAFO0iC,EAASyQ,eACTzQ,EAAS0Q,sBACT1Q,EAbcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,mSCvB3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,EAKdW,QAAQP,GACN,MAAMgsC,GAAoB,EAAA51C,EAAAC,WAAU2J,GACpCgsC,EAAkB3rC,KAAKT,QAPX,EAQZ,IACE,GAAoD,QAAhDosC,EAAkB10C,KAAK5B,OAAOmP,SAAS/G,KACzC,OAAOjF,QAAQC,QAAQkzC,GAEzB,OAAQA,EAAkB10C,KAAK5B,OAAOmP,SAASy+B,WAC7C,IAAK,+BACH0I,EAAkB10C,KAAK5B,OAAOmP,SAAW,CACvC/G,KAAM,WAER,MACF,IAAK,2BACHkuC,EAAkB10C,KAAK5B,OAAOmP,SAAW,CACvC/G,KAAM,YAKZ,MAAOT,IAGT,OAAOxE,QAAQC,QAAQkzC,oSCvB3B,IAAA51C,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAGhC,OAFArjC,EAAcK,KAAKT,QAPP,GAQZI,EAAc1I,KAKlB,SAAwBqB,GAEpBA,EAAMhD,uBACNgD,EAAMhD,sBAAsBs2C,YAAc3zC,kBAEnCK,EAAMhD,sBAAsBs2C,UAErC,OAAOtzC,EAZgB+qC,CAAe1jC,EAAc1I,MAC3C0I,wUClBX,IAAA5J,EAAAG,EAAA,UACA+S,EAAA/S,EAAA,uCAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MACMy7B,EAMV,SAAwB1iC,GAAO,IAAAuzC,EAC7B,GAAiE,iBAAtDvzC,MAAAA,GAAP,QAAAuzC,EAAOvzC,EAAOye,iCAAd,IAAA80B,OAAA,EAAOA,EAAkCC,iBAA8B,CACzE,MACE/0B,2BAA2B+0B,gBAAEA,IAC3BxzC,EAGJjC,OAAO64B,OAAO4c,GAAiBv1C,SAASw1C,IAEpCA,GACoB,iBAAbA,IACN7Z,MAAMuS,QAAQsH,KAEfA,EAAS9V,YAAc8V,EAAStU,YAC5BxuB,EAAAktB,cAAcC,UACdntB,EAAAktB,cAAcE,YAIxB,OAAO/9B,EAzBY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,mSCVX,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAGjB,cAFO0iC,EAASgR,2BACThR,EAASiR,aACTjR,EAbcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,oSCvB3B,IAAA5J,EAAAG,EAAA,gBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MACMy7B,EAMV,SAAwB1iC,GACtB,GAAIA,EAAMhD,sBAAuB,CAAA,IAAA42C,EAC/B,MAAMtuB,oBACJA,EADIuuB,kBAEJA,GACE7zC,EAAMhD,sBACVgD,EAAMoc,qBAAN,QAAAw3B,EAA6B5zC,EAAMoc,4BAAnC,IAAAw3B,EAAAA,EAA2D,GAEvDtuB,IAAwB3lB,YAC1BK,EAAMoc,qBAAqBkJ,oBAAsBA,SAC1CtlB,EAAMhD,sBAAsBsoB,qBAEjCuuB,IAAsBl0C,YACxBK,EAAMoc,qBAAqBy3B,kBAAoBA,SACxC7zC,EAAMhD,sBAAsB62C,mBAIvC,OAAO7zC,EAxBY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,kSCTX,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EAMjB,OALA0iC,EAASsL,iBAAiB8F,YAAY71C,SAAS81C,IACzCA,EAAOC,OACTD,EAAOE,KAAO,OAGXvR,EAhBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,oSCf3B,IAAA5J,EAAAG,EAAA,gBAIe,CACbqJ,QAHc,GAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,GAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAW1iC,EACb,aAAc0iC,KAAc,kBAAmBA,EAASwR,YAC1DxR,EAASwR,SAAShQ,cAAgB,CAChCj9B,QAAS,SACTk9B,KAAMC,KAAKC,QAGf,OAAO3B,EAjBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,yBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,iUCzB3B,IAAA5J,EAAAG,EAAA,UACAqS,EAAArS,EAAA,+BASe,CACbqJ,QARc,GASdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAXP,GAYZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GACtB,GAAIA,EAAMgf,sBAAuB,CAC/B,MAAMm1B,EAAKn0C,EAAMgf,sBAAsBukB,YAEjC6Q,EAAW,IAAI91B,IACf+1B,EAAiB,GAGvBt2C,OAAO64B,OAAOud,GAAIl2C,SAASq2C,IACzBF,EAASG,IAAID,EAAEn3C,YAIjB,IAAK,MAAMiH,KAAMgwC,EAASxd,SAAU,CAElCyd,EAAejwC,GAAM,GACrB,IAAK,MAAMyZ,KAAWs2B,EAChBA,EAAGt2B,GAAS1gB,UAAYiH,IAC1B+vC,EAAGt2B,GAAS22B,OAAQ,EAChBvkC,EAAAwkC,KAAKC,iBAAiBP,EAAGt2B,GAAS1Q,QACpCgnC,EAAGt2B,GAAS22B,OAAQ,GAEtBH,EAAejwC,GAAIyZ,GAAWs2B,EAAGt2B,IAKvC7d,EAAMgf,sBAAsBukB,YAAc8Q,EAG5C,OAAOr0C,EAnCgB+qC,CAAe/qC,GAC7BqH,8eCjBX5J,EAAAG,EAAA,2lBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GACtB,MAAQyvC,iBAAkBkF,EAAwB,IAAO30C,GACnD40C,QAAEA,EAAU,IAAOD,EAEzB,GAAIC,EAAQC,kBACV,OAAO70C,EAGT,OAAAiC,EAAAA,EAAA,GACKjC,GADL,GAAA,CAEEyvC,iBAAgBxtC,EAAAA,EAAA,GACX0yC,GADW,GAAA,CAEdC,QAAO3yC,EAAAA,EAAA,GACF2yC,GADE,GAAA,CAELC,kBAAmB,gBAnBF9J,CAAe/qC,GAC7BqH,+bCbX,IAAA+I,EAAAxS,EAAA,yCACAk3C,EAAA/1C,EAAAnB,EAAA,oBAgBe,CACbqJ,QAfc,GAiBdW,SAAS,EAAAktC,EAAAx1C,SAjBK,GAmBZ,yCACCuhB,IACC,MAAMk0B,EAAal0B,EAAO5S,SAAWmC,EAAAsQ,qBAAqBs0B,SACpDC,EAAcp0B,EAAOgtB,cACrBxJ,EAAMD,KAAKC,MACjB,OAAO0Q,GAAc1Q,EAAM4Q,EAlBP,6bCV1B,IAAAx3C,EAAAG,EAAA,UACAs3C,EAAAn2C,EAAAnB,EAAA,4CAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAAkuC,EAE3BluC,MAAAA,GAAA,QAAAkuC,EAAAluC,EAAOyf,6BAAP,IAAAyuB,GAAAA,EAA8BvX,cAC9BiD,MAAMuS,QAAQnsC,EAAMyf,sBAAsBkX,gBACzC32B,EAAMyf,sBAAsBkX,aAAaoY,MACvC3Y,GACiB,iBAATA,QAA8C,IAAlBA,EAAK5U,aAG5CxhB,EAAMyf,sBAAsBkX,cAAe,EAAAl5B,EAAAyxC,OACzClvC,EAAMyf,sBAAsBkX,cAG3BE,SACsB,IAAVA,EAAGzyB,IAAgC,OAAVyyB,EAAGzyB,KAGrCyyB,EAAGzyB,IAAK,EAAA8wC,EAAA51C,YAEHu3B,EAAGzyB,OAIhB,OAAOpE,EA5BgB+qC,CAAe/qC,GAC7BqH,6eCTX5J,EAAAG,EAAA,2lBAIe,CACbqJ,QAHc,EAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,EAQZ,IACE,MACMy7B,EASZ,SAA4C1iC,GAC1C,MAAMjD,OAAEA,GAAWiD,EACb0iC,EAAQzgC,EAAAA,EAAA,GACTjC,GADS,GAAA,CAEZyc,kBAAmB,CACjBoM,MAAO7oB,EAAM6oB,MACbssB,gBAAiBp4C,EAAOo4C,gBACxB5J,gBAAiBvrC,EAAMurC,mBAO3B,cAJO7I,EAAS7Z,aACT6Z,EAAS6I,uBACT7I,EAAS3lC,OAAOo4C,gBAEhBzS,EAvBc0S,CADH/tC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,wBAAuB7N,EAAI0qC,SAE3C,OAAO9qC,QAAQC,QAAQkH,8eCjB3B5J,EAAAG,EAAA,2lBAIe,CACbqJ,QAHc,EAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,EAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAQzgC,EAAAA,EAAA,GACTjC,GADS,GAAA,CAEZ0f,mBAAoB,CAClBiX,aAAc32B,EAAM22B,cAAgB,GACpC0e,cAAer1C,EAAMq1C,eAAiB,KAM1C,cAHO3S,EAAS/L,oBACT+L,EAAS2S,cAET3S,EApBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,wBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,+eCvB3B5J,EAAAG,EAAA,2lBAgBe,CACbqJ,QAfc,GAgBdvH,cAAAgrC,GACE,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAaK,KAAbT,QAlBY,GAmBZ,MAAMjH,EAAQqH,EAAa1I,KAE3B,OADA0I,EAAa1I,KAQjB,SAAwBqB,EAAQ,IAAI,IAAA2vC,EAAA2F,EAAAC,EAAAC,EAAAtH,EAAAuH,EAAA7D,EAAA8D,EAAA/H,EAElC,QAAAgC,EAAO3vC,EAAKiV,yBAAZ,IAAA06B,UAAOA,EAAAgG,SAGP,MAAMzpC,GAAW,QAAAopC,EAAAt1C,EAAKiV,yBAAL,IAAAqgC,OAAA,EAAAA,EAAAppC,WAAqC,GAKtD,IAHoB,QAAlBA,EAAQ/G,MACqB,iBAArB+G,EAAQ/O,SACby4C,EAAY3X,KAAM/xB,EAAQ/O,WACwB,cAAlB+O,EAAQ/G,MAStC,GAAA,QAAAowC,EAAIv1C,EAAKiV,yBAAT,IAAAsgC,GAAIA,EAAArpC,SAAmC,CAAA,IAAA2pC,EAAAC,EAC5C,GAAI,cAAe91C,EAAKiV,kBAAL/I,SAAkC,CACnD,MAAMhP,EAAS8C,EAAKiV,kBAAL/I,SAAAy+B,UACf3qC,EAAKiV,kBAAL/I,SAAAhP,OAA0CA,EAE5C,QAAA24C,EAAO71C,EAAKiV,yBAAZ,IAAA4gC,IAAA,QAAAC,EAAOD,EAAA3pC,gBAAP,IAAA4pC,UAAOA,EAAAnL,iBAbP3qC,EAAKiV,kBAAL/I,SAAmC,CACjC/G,KAAM,UACNjI,OAAQ,GACRC,QAAS,MACTE,SAAU,GACVC,SAAU,GACVF,OAAQ,OAWP4C,EAAKhD,wBACRgD,EAAKhD,sBAAyB,IAE3BgD,EAAKhD,sBAALC,wBACH+C,EAAKhD,sBAALC,sBAAoD,IAEtD+C,EAAKhD,sBAALC,sBAAA4qC,QAA0D,CACxD3qC,OAAQ,wBACRC,QAAS,QACTC,OAAQ,MACRC,SAAU,iBACVC,SAAU,KAIZ,QAAAk4C,EAAOx1C,EAAKkc,gCAAZ,IAAAs5B,UAAOA,EAAAO,eAGP,MAAMpf,EAAY,QAAAuX,EAAGluC,EAAKyf,6BAAR,IAAAyuB,OAAA,EAAGA,EAAAvX,aACjBiD,MAAKuS,QAASxV,IAChBA,EAAY14B,SAAUkwC,IACpB,MAAMC,EAAoBD,MAAAA,OAAH,EAAGA,EAAWC,kBAEN,iBAAtBA,GACP4H,EAAQ/X,KAAMmQ,KAEdD,EAAWC,kBAAqBjV,SAC9BiV,EACA,IAF8B9R,SAGrB,QAMjB,MAAMiH,GAAc,QAAAkS,EAAAz1C,EAAKgf,6BAAL,IAAAy2B,OAAA,EAAAA,EAAAlS,cAA4C,GAChExlC,OAAM+B,KAAMyjC,GAAZtlC,SAAkCg4C,IAChC,GAAI,UAAAhY,KAAegY,GAAa,CAC9B,MAAM94C,EAAW,KAAIg8B,SAAS8c,EAAY,IAArB3Z,SAAkC,OA0F7D,SAAA4Z,EAAA/4C,GACEY,OAAM64B,OAAQsf,GAAdj4C,SAAuCulC,IACjCA,GAA0B,iBAAVA,IAClBA,EAAKrmC,QAAWA,MA5FhBg5C,CAAe5S,EAAY0S,GAAa94C,GAEpComC,EAAYpmC,GA6CtB,SAAAomC,EAAA0S,EAAAG,GACE,MAAMC,EAAoB9S,EAAY0S,IAAe,GAE/CK,EAAUr0C,EAAA,GAAQshC,EAAY6S,IAGpCr4C,OAAM+B,KAAMu2C,GAAZp4C,SAAwC4f,IACtC,GAAIy4B,EAAWz4B,IAA2C,iBAAxBy4B,EAAWz4B,GAAuB,CAClE,MAAM04B,EAAc,GAIpB,IAAIj4B,IAAI,IACHvgB,OAAM+B,KAAMw2C,EAAWz4B,OACvB9f,OAAM+B,KAAMu2C,EAAkBx4B,IAAY,MAF/C5f,SAGYC,IAAQ,IAAAs4C,EAElBD,EAAYr4C,GACVo4C,EAAWz4B,GAAS3f,KAApB,QAAAs4C,EAA4BH,EAAkBx4B,UAA9C,IAAA24B,OAAA,EAA4BA,EAA6Bt4C,KAAQ,MAGrEo4C,EAAWz4B,GAAW04B,OAEtBF,EAAkBx4B,IACoB,iBAA/Bw4B,EAAkBx4B,KAIzBy4B,EAAWz4B,GAAWw4B,EAAkBx4B,OAI5C0lB,EAAY6S,GAAcE,EA5EpBG,CAAqBlT,EAAa0S,EAAY94C,GAE9ComC,EAAYpmC,GAAWomC,EAAY0S,UAE9B1S,EAAY0S,OAKvB,QAAArE,EAAO5xC,EAAK6b,sCAAZ,IAAA+1B,GAAA,QAAA8D,EAAO9D,EAAAC,4CAAP,IAAA6D,UAAOA,EAAAgB,UAIP,MAAMlL,EAAa,QAAAmC,EAAG3tC,EAAKhD,6BAAR,IAAA2wC,OAAA,EAAGA,EAAAnC,cAClBA,GACFztC,OAAM+B,KAAM0rC,GAAZvtC,SAAoCkxC,IAAY,IAAAwH,EAAAC,EAC9C,MAAMC,GAAkB,QAAAF,EAAAnL,EAAc2D,UAAd,IAAAwH,OAAA,EAAAA,EAAAD,YAAqC,GAE7D,GAAIG,EAAe92C,OAAU,EAAG,CAC9B,MAAM+2C,EAAYtL,EAAc2D,GAAdhuB,KAA8B,GAE5C21B,EAAS/2C,OAAU,EACrByrC,EAAc2D,GAAdhuB,IAgFV,SAAA01B,EAAAC,GACE,MAAMC,EAAqBC,EAAgBH,GACrCI,EAAeD,EAAgBF,GAE/BI,EAAe,GAWrB,OAVA,IAAI54B,IAAI,IACHvgB,OAAM+B,KAAMi3C,MACZh5C,OAAM+B,KAAMm3C,KAFjBh5C,SAGYk5C,IACVD,EAAYhX,KAAZj+B,EAAAA,EAAA,GACK80C,EAAmBI,IACnBF,EAAaE,QAIbD,EAEP,SAAAF,EAAAI,GACE,OAAOA,EAAKnhB,QAAQ,CAAAp1B,EAAAorC,KACdA,MAAAA,GAAAA,EAAKpuB,SAAuC,iBAAnBouB,MAAAA,OAAP,EAAOA,EAAKpuB,WAChChd,EAAIorC,EAAKpuB,SAAYouB,GAEhBprC,IACN,KAvGgCw2C,CAC3BR,EACAC,GAGFtL,EAAc2D,GAAdhuB,IAA6B01B,EAGjC,QAAAD,EAAOpL,EAAc2D,UAArB,IAAAyH,UAAOA,EAAAF,aAIX,OAAO12C,EAhHgB+qC,CAAe/qC,GAC7BqH,gBAIX,MAAM2uC,EAAW,kBACXJ,EAAe,yfC5BrBn4C,EAAAG,EAAA,2lBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MACMy7B,EAMV,SAAwB1iC,GAAO,IAAA2tC,EAAA2J,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAC7B,MAAMpM,EAAgBxrC,MAAAA,GAAH,QAAA2tC,EAAG3tC,EAAOhD,6BAAV,IAAA2wC,OAAA,EAAGA,EAA8BnC,cAC9Cc,EAAsBtsC,MAAAA,GAAH,QAAAs3C,EAAGt3C,EAAOhD,6BAAV,IAAAs6C,OAAA,EAAGA,EAA8BhL,oBAEpDuL,EAAe,GACjBrM,GACFztC,OAAO+B,KAAK0rC,GAAevtC,SAASq3B,IAClCv3B,OAAO+B,KAAK0rC,EAAclW,IAAiBr3B,SAASd,IAClD,MAAM26C,EAActM,EAAclW,GAAgBn4B,GAC9C06C,EAAa16C,KAAawC,UAC5Bk4C,EAAa16C,GAAW,CAAEm4B,CAACA,GAAiBwiB,GAE5CD,EAAa16C,GAAb8E,EAAAA,EAAA,GACK41C,EAAa16C,IADlB,GAAA,CAEEm4B,CAACA,GAAiBwiB,UAO5B,MAAMC,EAAsB,GACxBzL,GACFvuC,OAAO+B,KAAKwsC,GAAqBruC,SAASq3B,IACxCv3B,OAAO+B,KAAKwsC,EAAoBhX,IAAiBr3B,SAASd,IACxD,MAAM66C,EAAqB1L,EAAoBhX,GAAgBn4B,GAC3D46C,EAAoB56C,KAAawC,UACnCo4C,EAAoB56C,GAAW,CAC7Bm4B,CAACA,GAAiB0iB,GAGpBD,EAAoB56C,GAApB8E,EAAAA,EAAA,GACK81C,EAAoB56C,IADzB,GAAA,CAEEm4B,CAACA,GAAiB0iB,UAOxBh4C,EAAM6V,kBACR7V,EAAM6V,iBAAiBuf,UAAYyiB,EACnC73C,EAAM6V,iBAAiBkhB,iBAAmBghB,GAE1C/3C,EAAM6V,iBAAmB,CACvBuf,UAAWyiB,EACX9gB,iBAAkBghB,GAWtB,OAPO/3C,MAAAA,IAAP,QAAAu3C,EAAOv3C,EAAOhD,6BAAd,IAAAu6C,UAAOA,EAA8BjL,qBAC9BtsC,MAAAA,GAAP,QAAAw3C,EAAOx3C,EAAOhD,6BAAd,IAAAw6C,UAAOA,EAA8BhM,cAC9BxrC,MAAAA,GAAP,QAAAy3C,EAAOz3C,EAAOhD,6BAAd,IAAAy6C,UAAOA,EAA8BpI,YAC9BrvC,MAAAA,GAAP,QAAA03C,EAAO13C,EAAOhD,6BAAd,IAAA06C,UAAOA,EAA8BO,aAC9Bj4C,MAAAA,GAAP,QAAA23C,EAAO33C,EAAOhD,6BAAd,IAAA26C,UAAOA,EAA8B70B,OAC9B9iB,MAAAA,GAAP,QAAA43C,EAAO53C,EAAOhD,6BAAd,IAAA46C,UAAOA,EAA8BM,gBAE9Bl4C,EA/DY+qC,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,6eCTX5J,EAAAG,EAAA,2lBAIe,CACbqJ,QAHc,EAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,EAQZ,IACE,MACMy7B,EASZ,SAAwB1iC,GACtB,MAAM0iC,EAAQzgC,EAAAA,EAAA,GACTjC,GADS,GAAA,CAEZguC,iBAAkB,CAChB8F,YAAa9zC,EAAM8zC,aAAe,MAKtC,cAFOpR,EAASoR,YAETpR,EAlBcqI,CADH1jC,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,wBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,iiBCvB3B5J,EAAAG,EAAA,UACA2S,EAAA3S,EAAA,+nBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MACMy7B,EAMV,SAAwB1iC,GAAO,IAAA2tC,EAC7B,MAAMwK,EAAuBrzC,OAAOszC,UAAUC,IAC1C9nC,EAAA+nC,uBAAuBC,OACvBhoC,EAAA+nC,uBAAuBE,IACrBC,EAAgBp5C,QAAO,QAAAsuC,EAAC3tC,EAAMhD,6BAAP,IAAA2wC,OAAA,EAACA,EAA6B8K,eACrD/V,EAAQzgC,EAAAA,EAAA,GACTjC,GADS,GAAA,CAEZhD,sBAAqBiF,EAAAA,EAAA,GAChBjC,MAAAA,OADgB,EAChBA,EAAOhD,uBADS,GAAA,CAEnB07C,oBAAqBD,EACjBloC,EAAA+nC,uBAAuBK,KACvBR,MAIR,cADOzV,EAAS1lC,sBAAsBy7C,cAC/B/V,EArBYqI,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,4lBChBX5J,EAAAG,EAAA,mrBAQe,CACbqJ,QAPc,GAQdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAVP,GAWZ,MACMy7B,EAMV,SAAwB1iC,GACtB,MAAM44C,sBACJA,EAAwB,GADpBC,oBAEJA,EAAsB,IAEpB74C,EADC84C,GAHL,EAAAC,EAAAz5C,SAIIU,EAJJg5C,IAMMC,eACJA,EAAiB,GADbC,mBAEJA,EAAqB,GAFjBC,eAGJA,EAAiB,IACfN,EAEJ,OAAA52C,EAAAA,EAAA,GACK62C,GADL,GAAA,CAEE57B,qBAAsBk8B,EAA6BR,GACnDx6B,wBAAyB,CACvBi7B,sBAAuBF,EACvBG,kBAAmBJ,GAErBz6B,0BAA2B86B,EACzBN,KA3BelO,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,IA8BX,SAAS+xC,EAA6BR,GACpC,MAAMY,QAAEA,EAAU,IAAOZ,EAkEzB,MAAO,CACLa,SAhCe17C,OAAOC,QAAQw7C,GAASvjB,QACvC,CAACyjB,GAAc1zB,EAAQ2zB,MACrB,MACEC,aAAcC,IACZF,EAIEG,EAAYD,EAAsBE,QAAQ94C,MAC7C+4C,GAXiB,oBAWNA,EAAO7sC,OAGf8sC,EAAah4C,EAAAA,EAAA,GACd43C,GADc,GAAA,CAEjBE,QAAS,CAAC,CAAE50C,KAjBM,2BAiBiBxH,MAAOm8C,EAAUn8C,UAYtD,cAROs8C,EAAc,YAErBP,EAAY1zB,GAAU,CACpBA,OAAAA,EACA4zB,YAAa,CACX5f,aAAgBigB,IAGbP,IAET,KAQJ,SAASH,EAAkCN,GAuCzC,MAAO,CACLzF,gBA5BsBz1C,OAAOC,QAAQi7C,GAAgBhjB,QACrD,CAACyjB,GAAc1zB,EAAQytB,MACrB,MAAMtmC,KACJA,EAAO,KADH+sC,KAEJA,EAAO,KAFH/a,YAGJA,EAAc,MAEZsU,EADC0G,GAJL,EAAApB,EAAAz5C,SAKIm0C,EALJ2G,GAoBA,cAZOD,EAAME,mBACNF,EAAMG,KAETt0B,IACF0zB,EAAY1zB,GAAZ/jB,EAAAA,EAAA,CACEkL,KAAAA,EACAotC,QAASL,EACT/a,YAAAA,GACGgb,GAJL,GAAA,CAKEn0B,OAAAA,KAGG0zB,IAET,4hBC1JJj8C,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,0nBAOe,CACbqJ,QANc,GAOdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QATP,GAUZ,MAAMjH,EAAQqH,EAAc1I,KAE5B,OADA0I,EAAc1I,KAKlB,SAAwBqB,GAAO,IAAAkuC,EAAA0D,EAC7B,MAAMjb,EAAe32B,MAAAA,GAAH,QAAAkuC,EAAGluC,EAAOyf,6BAAV,IAAAyuB,OAAA,EAAGA,EAA8BvX,aAC7C6jB,EACJx6C,MAAAA,GADwB,QAAA4xC,EACxB5xC,EAAO6b,sCADiB,IAAA+1B,OAAA,EACxBA,EAAuC4I,qBACrC5gB,MAAMuS,QAAQxV,IAChBA,EAAa14B,SAASkwC,IAChBA,IAEAA,EAAYhpC,OAASiL,EAAAkR,kBAAkB2tB,OACvCd,EAAYhpC,OAASiL,EAAAkR,kBAAkB0tB,SAEvCb,EAAYhpC,KAAOgpC,EAAYsM,4BAE1BtM,EAAYsM,wBAIzB,GAAID,EAAsB,CACYz8C,OAAOC,QAAQw8C,GACvBv8C,SAAQ,EAAEC,EAAKiwC,MACrCA,WACKA,EAAYsM,oBACnBz6C,EAAM6b,+BAA+B2+B,qBAAqBt8C,GAA1D+D,EAAAA,EAAA,GACKksC,GADL,GAAA,CAEEhpC,KAAMiL,EAAAkR,kBAAkBo5B,eAKhC,OAAO16C,EAlCgB+qC,CAAe/qC,GAC7BqH,2iBCfX5J,EAAAG,EAAA,UACA+8C,EAAA57C,EAAAnB,EAAA,iBACA0S,EAAA1S,EAAA,gnBAEA,MAAMg9C,EAA8BC,GAClC,IAAIF,EAAAr7C,QAAUu7C,GAAa,MAAO,IAAIC,GAAG,SAQ5B,CACb7zC,QAPc,GAQdvH,cAAcgrC,GACZ,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAVP,GAWZ,MACMy7B,EAMV,SAAwB1iC,GAAO,IAAAkuC,EAAAyB,EAAA6F,EAC7B,MAAMx4C,GAAwBgD,MAAAA,OAAA,EAAAA,EAAOhD,wBAAyB,GACxD4hB,EAAc5hB,EAAsB4hB,aAAe,GAEzD,GAAIA,EAAYm8B,iBACd,OAAO/6C,EAGT,MAAM22B,GAAe32B,MAAAA,GAAA,QAAAkuC,EAAAluC,EAAOyf,6BAAP,IAAAyuB,OAAA,EAAAA,EAA8BvX,eAAgB,GAC7DzqB,GAAW,QAAAyjC,EAAA3vC,EAAMiV,yBAAN,IAAA06B,OAAA,EAAAA,EAAyBzjC,WAAY,GAChD6pC,GAAiB,QAAAP,EAAAx1C,EAAMkc,gCAAN,IAAAs5B,OAAA,EAAAA,EAAgCO,iBAAkB,GAEnEiF,EAA4B1qC,EAAA2qC,YAAY5tC,SAASnB,MAAAA,OAArB,EAAqBA,EAAU/O,SAC3D+9C,EAAiCn9C,OAAO64B,OAC5CD,GACAoY,MAAK,EAAG5xC,QAAAA,KAAcmT,EAAA2qC,YAAY5tC,SAASlQ,KACvCg+C,EAAkC7qC,EAAA2qC,YAAYlM,MAAM5xC,GACzBY,OAAO64B,OAAOmf,EAAe54C,IAAY,IACC4xC,KACvE6L,KAIEQ,EACJJ,GACAE,GACAC,EAaF,OAXcl5C,EAAAA,EAAA,GACTjC,GADS,GAAA,CAEZhD,sBAAqBiF,EAAAA,EAAA,GAChBjF,GADgB,GAAA,CAEnB4hB,YAAW3c,EAAAA,EAAA,GACN2c,GADM,GAAA,CAETm8B,iBAAkBK,QAxCLrQ,CADH1jC,EAAc1I,MAG5B,OADA0I,EAAc1I,KAAO+jC,EACdr7B,6eCfX5J,EAAAG,EAAA,2lBAIe,CACbqJ,QAHc,EAKdW,QAAQ8iC,GACN,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAPP,EAQZ,IACE,MACMy7B,EASZ,SAAsB1iC,GACpB,MAAMq7C,EAAkBr7C,EAAMyc,kBAGxBimB,EAAQzgC,EAAAA,EAAA,GACTjC,GADS,GAAA,CAEZhD,sBAAuB,CACrBwpB,gBAAiB60B,EAAgBlG,mBAOrC,cAFOzS,EAASjmB,kBAAkB04B,gBAE3BzS,EAvBc4Y,CADHj0C,EAAc1I,MAE5B0I,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,wBAAgC7N,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,iWCjB3B,IAAA5J,EAAAG,EAAA,UACA29C,EAAA39C,EAAA,kEAOe,CACbqJ,QAHc,GAKdW,QAAO8iC,GACL,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAaK,KAAbT,QAPY,GAQZ,IACE,MACMy7B,EASZ,SAAA1iC,GACE,MAAM0iC,EAAW1iC,GACXyf,yBAA4BijB,EAClC,GAAIjjB,GAAyBA,EAAqBkX,aAAe,CAC/D,MAAMA,gBAAmB+L,EAAQjjB,sBACjCijB,EAAQjjB,sBAARkX,aAA8CA,EAAY91B,KAAMggB,IAE9D,IAAKA,EAAMmyB,SAAsC,IAA1BnyB,EAAMmyB,QAANjzC,OAA6B,CAClD,MAAMy7C,GAAW,EAAAD,EAAAE,oBAAmB56B,GAEpC,OADAA,EAAMmyB,QAAW,CAACwI,GACX36B,EAGT,MAAM66B,GAAa,EAAAH,EAAAI,6BAA4B96B,EAAMmyB,iBAE1CxP,IACC5J,MAAKuS,QAAS3I,IAAUA,EAAKzjC,OAAU,IAGnD,OADA8gB,EAAMmyB,QAAW0I,EACV76B,KAGX,OAAO6hB,EA/BcqI,CADH1jC,EAAa1I,MAE3B0I,EAAa1I,KAAQ+jC,EACrB,MAAApiC,GACA4N,QAAOC,KAAO,yBAAgC7N,EAAG0qC,SAEnD,OAAO9qC,QAAOC,QAASkH,2OC3B3B,IAAAu0C,EAAAh+C,EAAA,gBAMAU,EAAAC,QAAA,SAAAI,EAAAk9C,EAAAptC,GAEA,IAAAqtC,EAAAC,EAEA,OAHAttC,EAAAA,GAAA,GAGAotC,GACA,IAAA,UACA,IAAA,UACAC,EAXA,mCAYAC,GAAA,EACA,MACA,IAAA,cACAD,EAdA,mCAeAC,GAAA,EACA,MACA,IAAA,YACAD,EAjBA,mCAkBAC,GAAA,EACA,MACA,QACA,MAAA,IAAAl0C,MAAA,2BAAAg0C,GAUA,IAPA,IAAAntC,EAAAD,EAAAC,UAAA/O,UAAA8O,EAAAC,QAAAqtC,EACAC,EAAAJ,EAAAj9C,GAEAs9C,EAAA,EACAt+C,EAAA,EACAiB,EAAA,GAEA4oC,EAAA,EAAAA,EAAAwU,EAAAE,WAAA1U,IAIA,IAHA7pC,EAAAA,GAAA,EAAAq+C,EAAAG,SAAA3U,GACAyU,GAAA,EAEAA,GAAA,GACAr9C,GAAAk9C,EAAAn+C,IAAAs+C,EAAA,EAAA,IACAA,GAAA,EAQA,GAJAA,EAAA,IACAr9C,GAAAk9C,EAAAn+C,GAAA,EAAAs+C,EAAA,KAGAvtC,EACA,KAAA9P,EAAAmB,OAAA,GAAA,GACAnB,GAAA,IAIA,OAAAA,8gBChDec,gBAAyCwM,oBACtD,MAAMkwC,EAAM,IAAIC,EAAA/8C,QAAI4M,GACd0B,EAAO0uC,EAAAh9C,QAAAsO,KAAcT,GACrBovC,EAAW,IAAIC,EAAAl9C,QAAY88C,GAE3Bj/C,EAAU+yC,OAAM/W,eAAgBijB,EAAGK,cAAgB,IACnDC,EA+DR,SAAAv/C,GACE,OAAQA,QACD,OACA,OACA,OACA,EAEH,MAAO,qDAEP,OAAO,MAxEaw/C,CAAsBx/C,GAC9C,IAAKu/C,EACH,MAAM,IAAI70C,MACP,6DAA4D1K,MAGjE,MAAMy/C,EAAWL,EAASM,EAAAv9C,SAATw9C,GAAyBJ,GAGpCK,SAD6BH,EAAQI,SAAUpvC,IACR,GAC7C,GAAIqvC,EAAgBF,GAClB,MAAM,IAAIl1C,MAAO,iDAAgDsF,MAEnE,MAAM+vC,EAAWX,EAAS7uC,EAAApO,SAATw9C,GAAyBC,GAEpCI,QAA2BD,EAAQE,kBAAmB,cACtDC,QAAyBH,EAAQE,kBAAmB,cAC1D,GAAID,EAAmB,GAAI,CACzB,MACMG,SAD4BJ,EAAQK,YAAa3vC,IACZ,GAC3C,IAAI4vC,EAAqBC,EAAAn+C,QAAAo+C,OAAmBJ,GAC5C,MAAMn4C,EAAOs4C,EAAAn+C,QAAAq+C,SAAqBL,GAQlC,MANa,YAATn4C,GAA+B,YAATA,IACxBq4C,EAAqBC,EAAAn+C,QAAAs+C,QAAAC,gBACnBL,IAIG,CAAEr4C,KAAAA,EAAMyI,KAAM4vC,GAEvB,GAAIH,EAAiB,GAAI,CAEvB,MACMS,SAD4BZ,EAAQY,QAASlwC,IACf,GACpC,GAAIqvC,EAAgBa,GAClB,MAAM,IAAIj2C,MACP,mDAAkDsF,MAGvD,MAAO,CAAEhI,KAAM,WAAYyI,KAAMkwC,EAAO32C,MAAO,IAEjD,MAAM,IAAIU,MACP,4CAA2CsF,6EAxDhD,IAAAmvC,EAAAv9C,EAAAnB,EAAA,qBACAy+C,EAAAt9C,EAAAnB,EAAA,gBACA4+C,EAAAz9C,EAAAnB,EAAA,mBACA6/C,EAAA1+C,EAAAnB,EAAA,6BACAi/C,EAAA99C,EAAAnB,EAAA,yBACA8P,EAAA3O,EAAAnB,EAAA,yBAuDA,SAAAq/C,EAAAt/C,GACE,MAAO,CACLgC,UACA,KACA,KACA,MACA,sEALK0N,SAMI1P,2QC7DE,SAA+BqE,GAC5C,OAAO,SACcg5B,EACAt2B,EACKq5C,GAExB/iB,EAAIjuB,MAAQ/K,EAAK+K,MACjBgxC,iRCPW,SAAgC/7C,GAC7C,OAAO,SACcg5B,EACAt2B,EACKq5C,GAExB/iB,EAAIhV,OAAShkB,EAAKgkB,OAClB+3B,yNCeJ,IARA,IAAAC,EAAAC,KAAAD,QAAAC,KAAAC,SAKAphD,EAAA,KAEA0qC,EAAA,GACAA,KAGA1qC,GAAA0qC,EAAAlL,SAAA,IAIA,IADAkL,EAAA,GACAA,IAAA,IACA1qC,GAAA0qC,EAAAlL,SAAA,IAAApD,cAGA56B,EAAAC,QAAA,SAAA4/C,GACA,IAAA/5C,EAAA,GACAg6C,EAAAJ,EAAAK,gBAAA,IAAAC,WAAAH,GAAA,KAIA,IAHA3W,EAAA2W,GAAA,GAGA3W,KAKApjC,GAAAtH,EAAA,GAAAshD,EAAA5W,IAEA,OAAApjC,sSCpDA,IAAAmL,EAAA3R,EAAA,wBAE6B,CAACihC,EAAKD,IAC1Bl/B,MAAAA,IACL,GAAIk/B,EAAUG,eAAeC,MAC3B,OAEF,IAAKH,EAAIlgC,EAAKqP,QAQZ,YAPA4wB,EAAUD,MAAM,CACdM,QAAS,MACTx/B,MAAO8P,EAAA6rB,UAAUja,IAAIo9B,eAAe,CAClCl7C,QAAU,GAAE1E,EAAKqP,qBAEnB5J,GAAIzF,EAAKyF,KAKb,IAAIxE,EACAH,EACJ,IACEG,QAAei/B,EAAIlgC,EAAKqP,WAAWrP,EAAK0nB,QACxC,MAAO/lB,GACPb,EAAQa,EAGNs+B,EAAUG,eAAeC,MACvBv/B,GACFyO,QAAQzO,MAAMA,GAKdA,EACFm/B,EAAUD,MAAM,CACdM,QAAS,MACTx/B,OAAO,EAAA8P,EAAAivC,gBAAe/+C,EAAO,CAAEg/C,oBAAoB,IACnDr6C,GAAIzF,EAAKyF,KAGXw6B,EAAUD,MAAM,CACdM,QAAS,MACTr/B,OAAAA,EACAwE,GAAIzF,EAAKyF,yPC3CjB,MAAAs6C,EAAA9gD,EAAA,mBAAAoqC,OAEA1pC,EAAAC,QAEA,UAAA8gC,OAAAA,IACA,IAAAA,EAAA,MAAA,IAAAx3B,MAAA,6BACA,MAAA2+B,EAAA,IAAAkY,EAAA,CAAAx8C,YAAA,EAAA8xC,KASA,WACA,OAAA,GAVArV,MAYA,SAAA3D,EAAAz4B,EAAAqY,GACAykB,EAAAsf,OAAA3jB,GAAA,CAAA16B,EAAA+8B,KACAl+B,KAAA+gC,KAAA7C,MAEAziB,OAdAykB,EAAAznB,IACAynB,EAAAznB,GAAA,gBAAAvU,IACAmjC,EAAAtG,KAAA78B,MAGA,OAAAmjC,wZCZA,IAAA1gC,EAAA3G,MAAAA,KAAA2G,kBAAA/H,OAAAgI,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAnI,OAAAqI,eAAAJ,EAAAG,EAAA,CAAAE,YAAA,EAAAhG,IAAA,WAAA,OAAA4F,EAAAC,OACA,SAAAF,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAF,EAAAG,GAAAF,EAAAC,KAEAI,EAAAnH,MAAAA,KAAAmH,cAAA,SAAAL,EAAA1H,GACA,IAAA,IAAAgI,KAAAN,EAAA,YAAAM,GAAAxI,OAAAyI,UAAAC,eAAAC,KAAAnI,EAAAgI,IAAAT,EAAAvH,EAAA0H,EAAAM,IAEAxI,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACA2I,EAAA1I,EAAA,uBAAAW,GACA+H,EAAA1I,EAAA,2BAAAW,GACA+H,EAAA1I,EAAA,8BAAAW,GACA+H,EAAA1I,EAAA,iBAAAW,GACA+H,EAAA1I,EAAA,mBAAAW,GACA+H,EAAA1I,EAAA,qBAAAW,oaCRe,UAAoC6hC,SACjDA,EADiDC,mBAEjDA,IAEA,OAAO3gC,eAAgCs7B,EAAKqC,EAAK0gB,EAAM3X,GACrD,IACE,GAAmB,8BAAfpL,EAAIhtB,OAEN,YADA+vC,IAGE/iB,EAAIjuB,OAASiuB,EAAIjuB,QAAUjO,EAAAQ,QAAUkO,KAAKoxC,kBACtCve,EAAmBD,EAAUpF,EAAIjuB,OAEvC/N,EAAAM,QAAI8D,MACD,4CAA2Cg9B,kCAGhD/C,EAAIz9B,QAAS,EACbwmC,IACA,MAAO3mC,GACP2mC,EAAI3mC,MA7BV,IAAAT,EAAAD,EAAAnB,EAAA,aACAkB,EAAAC,EAAAnB,EAAA,2iBCDAmR,EAAAnR,EAAA,uBACAqS,EAAArS,EAAA,omBAUe,MAAMihD,UAAkC9vC,EAAAwZ,gBAsBrDrpB,aAAYnC,OAAEA,EAAFgX,oBAAUA,EAAV/T,MAA+BA,EAA/BkU,QAAsCA,IAChD/R,MAAMnC,IADqD,EAAA4C,EAAAtD,SAAAH,KAAA,SAbpD,IAePA,KAAK+U,QAAUA,EACf/U,KAAK4U,oBAAsBA,EACvBhX,GACFoC,KAAKulB,gBAAgB3nB,GAYzB2nB,gBAAgB3nB,GACdoC,KAAKpC,OAASA,EACdoC,KAAK2/C,qBACL,IAAK,MAAM5gD,KAAOH,OAAO+B,KAAK/C,GAAS,CACrC,IAAKA,EAAOmB,GACV,MAAM,IAAI2J,MAAO,cAAa3J,MAEhC,MAAM+V,EAAQlX,EAAOmB,GACjB+V,EAAM8B,UACRhZ,EAAOmB,GAAK6X,WAAW/V,IACrBb,KAAKkrC,YAAY,CAAEnsC,CAACA,GAAM8B,OAG5Bb,KAAK4U,oBAAoBgC,UACtB,GAAE9B,EAAM9G,oBACRnN,IACC,IAAI++C,EAAe/+C,EACfb,KAAK+U,UACP6qC,GAAe,EAAA9uC,EAAA+uC,oBAAmBh/C,EAAOjD,EAAOmB,GAAKu1C,WAEvDt0C,KAAKkrC,YAAY,CAAEnsC,CAACA,GAAM6gD,QAapCh2B,eACE,IAAK5pB,KAAKpC,OACR,MAAO,GAET,IAAIkiD,EAAY,GAChB,IAAK,MAAM/gD,KAAOH,OAAO+B,KAAKX,KAAKpC,QAAS,CAC1C,MAAMmiD,EAAa//C,KAAKpC,OAAOmB,GACzB8B,EAAQk/C,EAAWxkC,SACrBwkC,EAAWxkC,WACXwkC,EAAWl/C,MACfi/C,EAASh9C,EAAAA,EAAA,GAAQg9C,GAAcj/C,GAEjC,OAAOi/C,uoBC/FX,IAAAt4C,EAAA5H,EAAAnB,EAAA,WACAmR,EAAAnR,EAAA,uBACA6R,EAAA7R,EAAA,mBACA2R,EAAA3R,EAAA,kBACA+S,EAAA/S,EAAA,iCACAuhD,EAAAvhD,EAAA,0BACAs3C,EAAAn2C,EAAAnB,EAAA,sCAkBe,MAAMinB,UAAuBle,EAAArH,QAO1CJ,aAAYkkB,aAAEA,IACZjhB,QACAhD,KAAKwd,SAAW,IAAI5N,EAAAwZ,gBAAgB,CAClC62B,eAAgB,GAChBC,mBAAoB,IAEtBlgD,KAAKmgD,SAAW,GAChBngD,KAAKikB,aAAeA,EAQlBi8B,yBACF,OAAOthD,OAAO+B,KAAKX,KAAKogD,qBAAqBx/C,OAQ/Cw/C,oBACE,OAAOpgD,KAAKmgD,SACT93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SACpBgoB,QAAO,CAACr2B,EAAQm8B,KACfn8B,EAAOm8B,EAAI33B,IAAM23B,EACVn8B,IACN,IAWwBF,gCAACu7B,EAAWD,GACzC,MAAMQ,EAAQr8B,KAAKqgD,qBAAqBvkB,EAAWD,GACnD,aAAa,IAAI96B,SAAQ,CAACC,EAASC,KAEjCjB,KAAKsgD,KAAM,GAAEjkB,cAAmB78B,IAC9B,OAAQA,EAAKsP,QACX,IAAK,SACH,OAAO9N,EAAQxB,EAAKi9B,QACtB,IAAK,WACH,OAAOx7B,EACLmP,EAAA6rB,UAAUlvB,SAASwzC,oBACjB,+DAGN,IAAK,UACH,OAAOt/C,EACL,IAAIyH,MAAO,+BAA8BlJ,EAAKc,UAElD,QACE,OAAOW,EACL,IAAIyH,MACD,gDAA+Cu0B,KAAK2N,UACnD9O,cAiBhBukB,qBAAqBvkB,EAAWD,GAE1BA,IACFC,EAAUjV,OAASgV,EAAIhV,QAEzBiV,EAAUt8B,KAAOu8B,EAAiBD,EAAUt8B,MAE5C,MAAMghD,GAAO,IAAIvb,MAAO0J,UAClBtS,GAAQ,EAAA0Z,EAAA51C,WACRsgD,EAAU,CACdx7C,GAAIo3B,EACJP,UAAAA,EACA0kB,KAAAA,EACA1xC,OAAQ,aACR9I,KAAMwL,EAAAkvC,aAAaC,UAMrB,OAJA3gD,KAAK4gD,OAAOH,GAGZzgD,KAAKqG,KAAK,UACHg2B,EASTukB,OAAOhkB,GACL58B,KAAKmgD,SAASpf,KAAKnE,GACnB58B,KAAK6gD,eASPhkB,OAAOR,GACL,OAAOr8B,KAAKmgD,SAASr+C,MAAM86B,GAAQA,EAAI33B,KAAOo3B,IAWhDG,eAAeV,GAEb,OADA97B,KAAK8gD,qBAAqBhlB,EAAUQ,YAC7Bt8B,KAAK+gD,kBAAkBjlB,GAQhCglB,qBAAqBzkB,GACnBr8B,KAAKghD,cAAc3kB,EAAO,YAU5BK,mBAAmBL,EAAOI,GACxB,MAAMG,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIH,OAASA,EACbz8B,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,UAS5B0kB,kBAAkBjlB,GAEhB,cADOA,EAAUQ,WACVv7B,QAAQC,QAAQ86B,GASzBa,UAAUN,EAAOhnB,EAAS7U,WACxB,GAAI6U,EAAQ,CACV,MAAMunB,EAAM58B,KAAK68B,OAAOR,GACxBr8B,KAAKikB,aAAa,CAChBb,MAAO/N,EACPgO,SAAU,eACVC,WAAY,CACVC,OAAQ,eACRvd,KAAM42B,EAAI52B,QAIhBhG,KAAKghD,cAAc3kB,EAAO,YAS5B7Y,aAAa6Y,EAAO/7B,GAClB,MAAMs8B,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIt8B,MAAQA,EACZN,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,WAM5BjX,kBACEplB,KAAKmgD,SAAWngD,KAAKmgD,SAAS93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SAClD9O,KAAK6gD,eAcPG,cAAc3kB,EAAOvtB,GACnB,MAAM8tB,EAAM58B,KAAK68B,OAAOR,GACxB,IAAKO,EACH,MAAM,IAAIl0B,MAAO,+CAA8C2zB,OAEjEO,EAAI9tB,OAASA,EACb9O,KAAKq9B,WAAWT,GAChB58B,KAAKqG,KAAM,GAAEg2B,KAASvtB,IAAU8tB,GACjB,aAAX9tB,GAAoC,WAAXA,GAC3B9O,KAAKqG,KAAM,GAAEg2B,aAAkBO,GAWnCS,WAAWT,GACT,MAAM/C,EAAQ75B,KAAKmgD,SAAS9O,WAAWntC,GAAYA,EAAQe,KAAO23B,EAAI33B,MACvD,IAAX40B,IACF75B,KAAKmgD,SAAStmB,GAAS+C,GAEzB58B,KAAK6gD,eASPA,eACE,MAAMZ,EAAiBjgD,KAAKogD,oBACtBF,EAAqBthD,OAAO+B,KAAKs/C,GAAgBr/C,OACvDZ,KAAKwd,SAAS0tB,YAAY,CAAE+U,eAAAA,EAAgBC,mBAAAA,IAC5ClgD,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,eAUlC,SAASmoB,EAAiBv8B,GAC/B,MAAyB,OAArBA,EAAKwI,MAAM,EAAG,GAETxI,GAGF,EAAA8Q,EAAA4wC,aAAYhsB,EAAOC,KAAK31B,EAAM,ikBCrTvCoQ,EAAAnR,EAAA,uBACAoB,EAAAD,EAAAnB,EAAA,kmBAiBe,MAMbsB,YAAY8C,EAAO,KAAI,EAAAY,EAAAtD,SAAAH,KAAA,sBA8CFO,MAAO0gC,EAAUrzB,KACpC,GAAI5N,KAAKmmB,oBAEP,YADAtmB,EAAAM,QAAI8D,MAAM,uDAGZ,MAAMk9C,EAAcr+C,EAAA,GAAQ9C,KAAK8U,MAAMyG,WAAW4lC,gBAC7CA,EAAelgB,IAAakgB,EAAelgB,KAAcrzB,IAC5D/N,EAAAM,QAAI8D,MACD,2CAA0Cg9B,kBAAyBrzB,MAEtEuzC,EAAelgB,GAAYrzB,EAC3B5N,KAAK8U,MAAMo2B,YAAY,CAAEiW,eAAAA,QAxD3B,MAGM7sC,EAASxR,EAAAA,EAAA,CACbs+C,mBAAoB,KACpB1M,kBAAmB,KACnBvuB,qBAAqB,GAClBtjB,EAAKyR,WAPoB,CAC5B6sC,eAAgB,KASlBnhD,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAgB9U,GAGnC6b,sBAAsBkxB,GACpBrhD,KAAK8U,MAAMo2B,YAAY,CACrBkW,mBAAoBC,IAQxBjxB,qBAIE,OAHApwB,KAAK8U,MAAMo2B,YAAY,CACrB/kB,qBAAqB,IAEhBplB,QAAQC,SAAQ,GAQzBqvB,qBAAqBrqB,GACnBhG,KAAK8U,MAAMo2B,YAAY,CAAEwJ,kBAAmB1uC,4nBC7DhD,IAAAwB,EAAA5H,EAAAnB,EAAA,WACAmR,EAAAnR,EAAA,uBACA6R,EAAA7R,EAAA,mBACA2R,EAAA3R,EAAA,kBACAoB,EAAAD,EAAAnB,EAAA,aACA+S,EAAA/S,EAAA,iCACAuhD,EAAAvhD,EAAA,0BACAs3C,EAAAn2C,EAAAnB,EAAA,sCACAqB,EAAArB,EAAA,UAEA,MAAM6iD,EAAQ,mBAmBC,MAAM37B,UAA+Bne,EAAArH,QAOlDJ,aAAYkkB,aAAEA,IACZjhB,QACAhD,KAAKwd,SAAW,IAAI5N,EAAAwZ,gBAAgB,CAClCm4B,uBAAwB,GACxBC,2BAA4B,IAE9BxhD,KAAKmgD,SAAW,GAChBngD,KAAKikB,aAAeA,EAQlBu9B,iCACF,OAAO5iD,OAAO+B,KAAKX,KAAKogD,qBAAqBx/C,OAS/Cw/C,oBACE,OAAOpgD,KAAKmgD,SACT93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SACpBgoB,QAAO,CAACr2B,EAAQm8B,KACfn8B,EAAOm8B,EAAI33B,IAAM23B,EACVn8B,IACN,IAYP07B,0BAA0BL,EAAWD,GACnC,OAAO,IAAI96B,SAAQ,CAACC,EAASC,KAC3B,IAAK66B,EAAU3G,KAIb,YAHAl0B,EACE,IAAIyH,MAAM,wDAId,MAAM2zB,EAAQr8B,KAAKqgD,qBAAqBvkB,EAAWD,GACnD77B,KAAKsgD,KAAM,GAAEjkB,cAAmB78B,IAC9B,OAAQA,EAAKsP,QACX,IAAK,SAEH,YADA9N,EAAQxB,EAAKi9B,QAEf,IAAK,WAMH,YALAx7B,EACEmP,EAAA6rB,UAAUlvB,SAASwzC,oBACjB,+DAIN,IAAK,UAEH,YADAt/C,EAAO,IAAIyH,MAAO,+BAA8BlJ,EAAKc,UAEvD,QACEW,EACE,IAAIyH,MACD,gDAA+Cu0B,KAAK2N,UACnD9O,cAkBhBukB,qBAAqBvkB,EAAWD,GAC9Bh8B,EAAAM,QAAI8D,MACD,gDAA+Cg5B,KAAK2N,UACnD9O,MAIAD,IACFC,EAAUjV,OAASgV,EAAIhV,QAEzBiV,EAAUt8B,KAAOQ,KAAK+7B,iBAAiBD,EAAUt8B,MAEjD,MAAMghD,GAAO,IAAIvb,MAAO0J,UAClBtS,GAAQ,EAAA0Z,EAAA51C,WACRsgD,EAAU,CACdx7C,GAAIo3B,EACJP,UAAAA,EACA0kB,KAAAA,EACA1xC,OAAQ,aACR9I,KAAMwL,EAAAkvC,aAAae,eAMrB,OAJAzhD,KAAK4gD,OAAOH,GAGZzgD,KAAKqG,KAAK,UACHg2B,EASTukB,OAAOhkB,GACL58B,KAAKmgD,SAASpf,KAAKnE,GACnB58B,KAAK6gD,eAUPhkB,OAAOR,GACL,OAAOr8B,KAAKmgD,SAASr+C,MAAM86B,GAAQA,EAAI33B,KAAOo3B,IAWhDG,eAAeV,GAEb,OADA97B,KAAK8gD,qBAAqBhlB,EAAUQ,YAC7Bt8B,KAAK+gD,kBAAkBjlB,GAQhCglB,qBAAqBzkB,GACnBr8B,KAAKghD,cAAc3kB,EAAO,YAU5BK,mBAAmBL,EAAOI,GACxB,MAAMG,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIH,OAASA,EACbz8B,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,UAS5B0kB,kBAAkBjlB,GAEhB,cADOA,EAAUQ,WACVv7B,QAAQC,QAAQ86B,GASzBa,UAAUN,EAAOhnB,EAAS7U,WACxB,GAAI6U,EAAQ,CACV,MAAMunB,EAAM58B,KAAK68B,OAAOR,GACxBr8B,KAAKikB,aAAa,CAChBb,MAAO/N,EACPgO,SAAU,eACVC,WAAY,CACVC,OAAQ,eACRvd,KAAM42B,EAAI52B,QAIhBhG,KAAKghD,cAAc3kB,EAAO,YAS5B7Y,aAAa6Y,EAAO/7B,GAClB,MAAMs8B,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIt8B,MAAQA,EACZN,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,WAM5BjX,kBACEplB,KAAKmgD,SAAWngD,KAAKmgD,SAAS93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SAClD9O,KAAK6gD,eAePG,cAAc3kB,EAAOvtB,GACnB,MAAM8tB,EAAM58B,KAAK68B,OAAOR,GACxB,IAAKO,EACH,MAAM,IAAIl0B,MACP,uDAAsD2zB,OAG3DO,EAAI9tB,OAASA,EACb9O,KAAKq9B,WAAWT,GAChB58B,KAAKqG,KAAM,GAAEg2B,KAASvtB,IAAU8tB,GACjB,aAAX9tB,GAAoC,WAAXA,GAC3B9O,KAAKqG,KAAM,GAAEg2B,aAAkBO,GAYnCS,WAAWT,GACT,MAAM/C,EAAQ75B,KAAKmgD,SAAS9O,WAAWntC,GAAYA,EAAQe,KAAO23B,EAAI33B,MACvD,IAAX40B,IACF75B,KAAKmgD,SAAStmB,GAAS+C,GAEzB58B,KAAK6gD,eASPA,eACE,MAAMU,EAAyBvhD,KAAKogD,oBAC9BoB,EAA6B5iD,OAAO+B,KAAK4gD,GAC5C3gD,OACHZ,KAAKwd,SAAS0tB,YAAY,CACxBqW,uBAAAA,EACAC,2BAAAA,IAEFxhD,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,cASvCmoB,iBAAiBv8B,GACf,IACE,MAAMs9B,GAAW,EAAAxsB,EAAAysB,gBAAev9B,GAChC,GAAIs9B,EAASoW,MAAMoO,GACjB,OAAO,EAAAxhD,EAAA2xC,cAAa3U,GAEtB,MAAOt7B,GACP3B,EAAAM,QAAI8D,MAAO,sDAGb,OAAO,EAAAqM,EAAA4wC,aAAYhsB,EAAOC,KAAK31B,EAAM,8eCpVzC,IAAA2Q,EAAAvQ,EAAAnB,EAAA,2BACAoB,EAAAD,EAAAnB,EAAA,mBAE2B,CAazB8B,qBAAqBmhD,EAAiBC,GACpC,IAAKD,GAAmBA,EAAgB9gD,OAAS,EAC/C,MAAM,IAAI8H,MAAM,gCAGlB,MAOMmuB,EAAU,IAPU,IAAI1mB,EAAAhQ,QAAkB,IACdyhD,uBAAuB,eAMzC,CALH,CACXzpB,SAAUwpB,EACV/9B,iBAAkB89B,EAAgB9gD,SAI9BihD,QAAyBhrB,EAAQvY,cAIvC,GAHAze,EAAAM,QAAI8D,MAAO,qBAAoBg5B,KAAK2N,UAAU8W,MAC9C7hD,EAAAM,QAAI8D,MAAO,sBAAqBg5B,KAAK2N,UAAUiX,MAE3CA,EAAiBjhD,SAAW8gD,EAAgB9gD,OAE9C,MAAM,IAAI8H,MAAM,4BAGlB,IAAK,IAAI2/B,EAAI,EAAGA,EAAIwZ,EAAiBjhD,OAAQynC,IAC3C,GACEwZ,EAAiBxZ,GAAGzmC,gBAAkB8/C,EAAgBrZ,GAAGzmC,cAEzD,MAAM,IAAI8G,MACP,qCAAoCg5C,EAAgBrZ,iBAAiBwZ,EAAiBxZ,6lBC3CjG,IAAAyZ,EAAAliD,EAAAnB,EAAA,SACAoB,EAAApB,EAAA,YACAsjD,EAAAniD,EAAAnB,EAAA,oCACAujD,EAAAvjD,EAAA,0BACA6E,EAAA7E,EAAA,kCACAqB,EAAArB,EAAA,kCACA0S,EAAA1S,EAAA,qCAGA,MAAMwjD,EAA4B,EAAT3+C,EAAA4+C,iBAMV,MAYbniD,aAAYsZ,SACVA,EAAW4oC,EADDxiC,YAEVA,EAFUlJ,QAGVA,EAHUmJ,gBAIVA,EAJUC,UAKVA,EALUlJ,iBAMVA,GACE,IAAI,IAAA0rC,EAAAC,EAAAC,EACNriD,KAAKyW,iBAAmBA,EACxBzW,KAAKyf,YAAcA,EACnBzf,KAAKqZ,SAAWA,EAChBrZ,KAAKuW,QAAUA,EACfvW,KAAK0f,gBAAkBA,EACvB1f,KAAK2f,UAAYA,EACjB3f,KAAKqnB,gBAAL,QAAA86B,EAAuBniD,KAAKyf,mBAA5B,IAAA0iC,OAAA,EAAuBA,EAAkBrtC,MAAMyG,WAAW8L,gBAC1DrnB,KAAKsiD,eAAL,QAAAF,EAAsBpiD,KAAKyW,wBAA3B,IAAA2rC,OAAA,EAAsBA,EAAuBvhD,MAAM8iB,OAAOjiB,KAAKorC,GACtDA,EAAMpuB,UAEf1e,KAAK84C,aAAL,QAAAuJ,EAAoBriD,KAAKyW,wBAAzB,IAAA4rC,OAAA,EAAoBA,EAAuBxhD,MAAM0hD,cAEjD9iC,MAAAA,GAAAA,EAAa3K,MAAM8B,WAAU,EAAGyQ,gBAAAA,EAAiB7L,kBAAAA,MAE7Cxb,KAAKqnB,kBAAoBA,GACzBrnB,KAAKwb,oBAAsBA,IAE3Bxb,KAAKqnB,gBAAkBA,EACvBrnB,KAAKwb,kBAAoBA,EACzBxb,KAAKwiD,4BAGT/rC,MAAAA,GAAAA,EAAkBG,WAAU,EAAG+M,OAAAA,EAAS,GAAI4+B,cAAAA,EAAgB,OAC1DviD,KAAKsiD,eAAiB3+B,EAAOjiB,KAAKorC,GACzBA,EAAMpuB,UAEf1e,KAAK84C,aAAeyJ,KAIDhiD,wBAACojB,GACtB,MAAM8+B,EAAcziD,KAAK0iD,KAAKzF,IAC3BG,SAAS2E,EAAA5hD,SACTw9C,GAAGqE,EAAAW,8BACN,OAAO,IAAI5hD,SAAQ,CAACC,EAASC,KAC3BwhD,EAAYG,SAAS,CAAC5iD,KAAKqnB,iBAAkB1D,GAAQ,CAACrjB,EAAOG,IACvDH,EACKW,EAAOX,GAETU,EAAQP,QAQAF,wBACnB,IAAKP,KAAK6iD,SACR,OAGF,MAAMljC,UAAEA,GAAc3f,KAAK8iD,WAAWjiD,MAItC,GACEb,KAAKmR,SAAS2D,MAAMyG,WAAWxO,SAAS/O,UAAYmT,EAAA6I,kBAClB,IAAlCpb,OAAO+B,KAAKgf,GAAW/e,OAEvB,OAGF,MAAMmiD,EAAiB,GACvB/iD,KAAK0iD,KAAKM,YAAYhjD,KAAKmR,SAAS8xC,WACpC,IAAK,MAAMjL,KAAgBr4B,EAEtB3f,KAAKsiD,eAAexgD,MAAM4c,IACzB,EAAA5e,EAAAgjB,wBAAuBpE,EAASs5B,MAEjCh4C,KAAK84C,aAAah3C,MAAM4c,IACvB,EAAA5e,EAAAgjB,wBAAuBpE,EAASs5B,MAGlC+K,EAAehiB,KAAKiX,GAGxB,MAAMkL,EAAwB,CAC5BH,EAAe/6C,MAAM,EAAG,KACxB+6C,EAAe/6C,MAAM,IAAM+6C,EAAeniD,OAAS,IAErD,IAAK,MAAMuiD,KAAeD,EAAuB,CAC/C,IAAIziD,EACJ,IACEA,QAAeT,KAAKojD,kBAAkBD,GACtC,MAAO7iD,GAKP,YAJA,EAAAT,EAAAmP,MACG,qEACD1O,GAKJ,MAAM+iD,EAAoBF,EAAY96C,QAAO,CAAC9C,EAAGs0B,KAC/C,MAAM/D,EAAUr1B,EAAOo5B,GACvB,OAAO/D,IAAYA,EAAQwtB,kBAGvBviD,QAAQ61B,IACZysB,EAAkB3hD,KAAKs2C,GACdh4C,KAAKyW,iBAAiBiW,SAC3BsrB,EACAr4B,EAAUq4B,GAAcjL,OACxBptB,EAAUq4B,GAAc/E,cAYlCuP,wBACQxiD,KAAK6iD,UAAY7iD,KAAKqnB,kBAG5BrnB,KAAKu0B,kBACLv0B,KAAKqZ,SAAW4oC,GAOd5oC,aAASA,GACXrZ,KAAKujD,SAAWC,cAAcxjD,KAAKujD,SAC9BlqC,IAGLrZ,KAAKujD,QAAUE,aAAY,KACzBzjD,KAAKu0B,oBACJlb,IAMD9C,YAAQA,GACLA,IAGLvW,KAAKmR,SAAWoF,EAChBvW,KAAK0iD,KAAO,IAAIZ,EAAA3hD,QAAKoW,EAAQ0sC,YAQ3BvjC,oBAAgBA,GACbA,IAGL1f,KAAK0jD,iBAAmBhkC,EACxB1f,KAAK0jD,iBAAiB9sC,WAAU,EAAG0D,WAAAA,MAC7Bta,KAAKsa,aAAeA,IACtBta,KAAKsa,WAAaA,EACdA,GACFta,KAAKwiD,6BAST7iC,cAAUA,GACPA,IAGL3f,KAAK8iD,WAAanjC,GAQhBkjC,eACF,OAAO7iD,KAAKqlC,QAAUrlC,KAAKsa,mgBC3N/B1K,EAAAnR,EAAA,4mBAae,MAMbsB,YAAY8C,EAAO,IACjB,MAAM8Z,eAAEA,EAAF9O,kBAAkBA,GAAsBhL,EAE9C7C,KAAK2c,eAAiBA,EACtB3c,KAAK6N,kBAAoBA,EAEzB,MAAMyG,EAASxR,EAAA,CAAK8zC,eAAgB,IAAO/zC,EAAKyR,WAChDtU,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAgB9U,GAEjCtU,KAAK2jD,mBAWmBpjD,4BAACie,SAAEA,IAC3B,MAAMxgB,EAAUgC,KAAK6N,oBACf+1C,QAAwB5jD,KAAK6jD,yBACjCrlC,EACAxgB,GAEFgC,KAAK8U,MAAMo2B,YAAY,CACrB0L,eAAgBgN,IAIpBC,yBAAyB/8B,EAAa9oB,GACpC,MAAM44C,eAAEA,GAAmB52C,KAAK8U,MAAMyG,WAChCuoC,EAA2BhhD,EAAA,GAAQ8zC,EAAe54C,IAExDY,OAAO+B,KAAKmmB,GAAahoB,SAASilD,IAChC,MAAM/T,EAAUlpB,EAAYi9B,GAExB/T,EAAQla,UACVguB,EAA4BC,GAAa/T,EAAQla,YAQrD,OALqBhzB,EAAAA,EAAA,GAChB8zC,GADgB,GAAA,CAEnB54C,CAACA,GAAU8lD,IAUfxuB,sBACEt1B,KAAK8U,MAAMo2B,YAAY,CAAE0L,eAAgB,KAU3C+M,mBACE,MAAMr1C,EAAStO,KAAKgkD,qBAAqBr/C,KAAK3E,MAC9CA,KAAK2c,eAAe7H,MAAM8B,UAAUtI,0YC9EzB,SAAgCzL,GAC7C,OAAO,SACcg5B,EACAqC,EACK0gB,GAExBA,GAA8BnjC,IACxByiB,EAAI59B,OACNT,EAAAM,QAAIG,MAAM,2BAA4B49B,GAEpCrC,EAAIooB,qBAGRpkD,EAAAM,QAAIi8B,KAAM,QAAOv5B,EAAKgkB,WAAYgV,EAAK,KAAMqC,GAC7CziB,UAtBN,IAAA5b,EAAAD,EAAAnB,EAAA,itBCAAH,EAAAG,EAAA,UACAmR,EAAAnR,EAAA,uBACA6R,EAAA7R,EAAA,mBACAylD,EAAAzlD,EAAA,UACA+S,EAAA/S,EAAA,iCACA+U,EAAA/U,EAAA,yCAIA6E,EAAA7E,EAAA,6mBAEA,MAAM0lD,EAA2BhjD,IAG/BqlC,YAAW,KACT,MAAMrlC,MAIJijD,EAAqB,CACzB,wDAA0D,aAyB7C,MAkBbrkD,aAAYuY,QACVA,EADUC,iBAEVA,EAFUC,mBAGVA,EAHU3K,kBAIVA,EAJU+K,qBAKVA,EALU9Q,QAMVA,EANU+Q,YAOVA,EAPUvE,UAQVA,EARUyE,iBASVA,EAAmBorC,IAEnBnkD,KAAKqkD,kBAAqBljD,IAGnBijD,EAAmBjjD,EAAI+C,UAC1B6U,EAAiB5X,IAGrB,MAAMmjD,EAAY/rC,EAAiBgD,WACnCvb,KAAKhC,QAAU6P,IACf7N,KAAKuW,QAAUqC,IACf5Y,KAAKsC,OAASgiD,EAAUvuB,cAAcl0B,QAAQ,IAAK,KACnD7B,KAAK8H,QACa,eAAhB+Q,EAA+B/Q,EAAW,GAAEA,KAAW+Q,IAEzD,MAAM0rC,GAAqB,EAAAjmD,EAAAkmD,QAAOlwC,MAAAA,OAAP,EAAOA,EAAWmwC,UAAW,WAExDzkD,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAJtmB,EAAAA,EAAA,CACXoe,yBAA0B,KAC1BoyB,cAAe,MACZh/B,GAHQ,GAAA,CAIXmwC,UAAS3hD,EAAA,GACJwR,MAAAA,OADI,EACJA,EAAWmwC,cAIlBlsC,EAAiB3B,WAAU,EAAGmf,cAAAA,MAC5B/1B,KAAKsC,OAASyzB,EAAcl0B,QAAQ,IAAK,QAG3C2W,GAAmB,KACjBxY,KAAKhC,QAAU6P,IACf7N,KAAKuW,QAAUqC,OAEjB5Y,KAAKsY,QAAUA,EAQf1Z,OAAO64B,OAAO8sB,GAAoBzlD,SAAS8P,IACzC5O,KAAK+gB,sBAAsBnS,EAAS3J,GAAI,CAAEy/C,WAAW,OAQvDjB,aAAY,KACV7kD,OAAO64B,OAAOz3B,KAAK8U,MAAMyG,WAAWkpC,WAAW3lD,SAAS8P,IAEpDA,EAASu3B,SACTlB,KAAKC,MAAQt2B,EAASssC,YAAc,IAAOtsC,EAASu3B,SAEpDnmC,KAAK+gB,sBAAsBnS,EAAS3J,GAAI,CAAEy/C,WAAW,SAG/C,GAATphD,EAAAE,QAGLmhD,wBACE,OAAO,EAAAr0C,EAAA4wC,cACL,EAAA5wC,EAAAs0C,QACE1vB,EAAOC,KACL0vB,OAAO5f,KAAKC,OACV2f,OAAOj/C,KAAKk/C,MAAMl/C,KAAKm/C,SAAWhU,OAAOiU,sBAanDnkC,oBAAoBvR,GAAS,IAAA21C,EAC3B,IAAK31C,EAAQ41C,eAAiB51C,EAAQ+T,SACpC,MAAM,IAAI3a,MACP,+DACC4G,EAAQ8T,wBACS9T,EAAQ+T,gCAAgCzkB,OAAO+B,KAChE2O,OAE8B,iBAAvBA,EAAQgU,WACV,+BAA8B1kB,OAAO+B,KAAK2O,EAAQgU,cACnD,MAIV,MAAMmhC,UAAEA,GAAczkD,KAAK8U,MAAMyG,WAE3BtW,EAAE,QAAAggD,EAAG31C,EAAQ61C,wBAAX,IAAAF,EAAAA,GAA+B,EAAAf,EAAAkB,gBACjCx2C,EAAQ9L,EAAAA,EAAA,CACZmC,GAAAA,GACGqK,GAFS,GAAA,CAGZ4rC,YAAajW,KAAKC,QAwBpB,OAtBAllC,KAAK8U,MAAMo2B,YAAY,CACrBuZ,UAAS3hD,EAAAA,EAAA,GACJ2hD,GADI,GAAA,CAEPx/C,CAACA,GAAK2J,MAINU,EAAQ+1C,cACVrlD,KAAKogB,WAAW,CACdgD,MAAOxU,EAASy2C,aAChBhiC,SAAUzU,EAASyU,SACnBC,WAAY1U,EAAS0U,WACrBgiC,oBAAqB12C,EAAS02C,oBAC9BlsB,KAAMxqB,EAASwqB,KACfmsB,SAAU32C,EAAS22C,SACnBC,QAAS52C,EAAS42C,QAClBhnD,MAAOoQ,EAASpQ,MAChBinD,SAAU72C,EAAS62C,SACnB/f,gBAAiB92B,EAAS82B,kBAIvB92B,EAUToS,qBAAqB/b,GACnB,MAAMw/C,UAAEA,GAAczkD,KAAK8U,MAAMyG,WAIjC,OAFiBkpC,EAAUx/C,GAY7B6b,oBAAoB7b,EAAI+9B,GACtB,MAAMyhB,UAAEA,GAAczkD,KAAK8U,MAAMyG,WAIjC,IAFiBkpC,EAAUx/C,GAGzB,MAAM,IAAIyD,MAAO,0BAAyBzD,qBAG5CjF,KAAK8U,MAAMo2B,YAAY,CACrBuZ,UAAS3hD,EAAAA,EAAA,GACJ2hD,GADI,GAAA,CAEPx/C,CAACA,IAAK,EAAA3G,EAAAmtC,OAAMgZ,EAAUx/C,GAAhBnC,EAAAA,EAAA,GACDkgC,GADC,GAAA,CAEJkY,YAAajW,KAAKC,aAoB1BnkB,sBAAsB9b,GAAIy/C,UAAEA,GAAY,EAAdtrB,KAAqBA,EAArBmsB,SAA2BA,GAAa,IAAI,IAAAG,EACpE,MAAM92C,EAAW5O,KAAK8U,MAAMyG,WAAWkpC,UAAUx/C,GACjD,IAAK2J,EACH,MAAM,IAAIlG,MAAO,kBAAiBzD,qBAGpC,MAAM0gD,EAAYjB,EAAY91C,EAASg3C,aAAeh3C,EAASs2C,aAE/DllD,KAAKogB,WAAW,CACdgD,MAAOuiC,EACPtiC,SAAUzU,EAASyU,SACnBC,WAAY1U,EAAS0U,WACrBgiC,oBAAqB12C,EAAS02C,oBAC9BlsB,KAAMA,MAAAA,EAAAA,EAAQxqB,EAASwqB,KACvBmsB,SAAQ,QAAAG,EAAE92C,EAAS22C,gBAAX,IAAAG,EAAAA,EAAuBH,EAC/BC,QAAS52C,EAAS42C,QAClBhnD,MAAOoQ,EAASpQ,MAChBinD,SAAU72C,EAAS62C,SACnB/f,gBAAiB92B,EAAS82B,kBAE5B,MAAM+e,UAAEA,GAAczkD,KAAK8U,MAAMyG,kBAC1BkpC,EAAUx/C,GACjBjF,KAAK8U,MAAMo2B,YAAY,CAAEuZ,UAAAA,IAW3Bn6B,4BAA4BpJ,GAC1B,IAAIoyB,cAAEA,GAAkBtzC,KAAKa,MAO7B,OANIqgB,IAA6BoyB,EAC/BA,EAAgBtzC,KAAK2kD,yBACiB,IAA7BzjC,IACToyB,EAAgB,MAElBtzC,KAAK8U,MAAMo2B,YAAY,CAAEhqB,yBAAAA,EAA0BoyB,cAAAA,IAC5CA,EAGLzyC,YACF,OAAOb,KAAK8U,MAAMyG,WAapBsqC,cAAcN,EAAUnsB,EAAO5lB,EAAAsyC,oCAC7B,MAAO,CACLC,IAAK,CACH/3C,KAAM,qBACNlG,QAAS9H,KAAK8H,SAEhBk+C,UAAWrgD,OAAOszC,UAAU+M,UAC5B5sB,KAAAA,EACAmsB,SAAAA,GAcJU,mBAAmBC,GAAY,IAAAC,EAAAC,EAC7B,MAAMhjC,MACJA,EADIE,WAEJA,EAFIkiC,QAGJA,EAHIhnD,MAIJA,EAJIinD,SAKJA,EALIpiC,SAMJA,EANI+V,KAOJA,EAPImsB,SAQJA,EARI7f,gBASJA,EAAkBl0B,EAAA60C,6BAChBH,EACJ,MAAO,CACL9iC,MAAAA,EACAE,WAAUxgB,EAAAA,EAAA,IAOL,EAAAxE,EAAAgoD,MAAKhjC,EAAY,CAAC,UAAW,SAAU,WAAY,WAP9C,GAAA,CAQRkiC,QAAAA,EACAhnD,MAAAA,EACAinD,SAAAA,EACApiC,SAAAA,EACA9M,QAAO,QAAA4vC,EAAE7iC,MAAAA,OAAF,EAAEA,EAAY/M,eAAd,IAAA4vC,EAAAA,EAAyBnmD,KAAKuW,QACrCjU,OAAQtC,KAAKsC,OACbikD,SAAQ,QAAAH,EAAE9iC,MAAAA,OAAF,EAAEA,EAAYijC,gBAAd,IAAAH,EAAAA,EAA0BpmD,KAAKhC,QACvCwoD,iBAAkB9gB,IAEpBU,QAASpmC,KAAK6lD,cAAcN,EAAUnsB,IAe1CqtB,OAAOzjB,EAAS1zB,GAAS,IAAAo3C,EACvB,MAAMC,QACJA,EACArT,cAAesT,EAFX/iC,YAGJA,EAHIgjC,iBAIJA,GACEv3C,GAAW,GACf,IAAIw3C,EAAS,SACTC,EAAU/mD,KAAKa,MAAMyyC,cACrB0T,EAAoB,QAAAN,EAAGp3C,MAAAA,OAAH,EAAGA,EAAS03C,4BAAZ,IAAAN,GAAAA,EAoCxB,OAhCmBxmD,QAAQ8iC,EAAQ5f,MAAM8vB,MAAM,uBAE7C8T,GAAuB,GAYrBA,GAAyBL,IAAYC,GACvCE,EAAS,cACTC,EAAUvzC,EAAAyzC,0BACDN,GAAWC,IACpBG,EAAUH,GAEZ5jB,EAAQ8jB,GAAUC,GAIE,IAAhBljC,IACFmf,EAAQ1f,WAAW4jC,cAAe,GAO7B,IAAInmD,SAAQ,CAACC,EAASC,KAc3BjB,KAAKsY,QAAQ6uC,MAAMnkB,GAbD7hC,IAChB,GAAIA,EAAK,CAKP,MAAMimD,EAAY,IAAI1+C,MAAMvH,EAAI+C,SAEhC,OADAkjD,EAAUvb,MAAQ1qC,EAAI0qC,MACf5qC,EAAOmmD,GAEhB,OAAOpmD,OAIL6lD,GACF7mD,KAAKsY,QAAQyuB,WAYnBvT,WAAUxlB,KAAEA,EAAFkZ,OAAQA,EAARwe,gBAAgBA,EAAhBtM,KAAiCA,EAAjCmsB,SAAuCA,GAAYj2C,GAC3D,IACE,IAA4C,IAAxCtP,KAAKa,MAAMqgB,yBACb,OAGF,GAC0C,OAAxClhB,KAAKa,MAAMqgB,2BACV5R,MAAAA,IAAAA,EAAS+3C,aAEV,OAEF,MAAM/T,cAAEA,GAAkBtzC,KAAKa,MACzBymD,EAAUhU,EAAgB,SAAW,cACrCyT,EAAUzT,MAAAA,EAAAA,EAAiB9/B,EAAAyzC,yBACjCjnD,KAAKsY,QAAQ8gB,KAAK,CAChBkuB,CAACA,GAAUP,EACX/4C,KAAAA,EACAsV,WAAY,CACV4D,OAAAA,EACA5kB,OAAQtC,KAAKsC,OACbiU,QAASvW,KAAKuW,QACdgwC,SAAUvmD,KAAKhC,QACfwoD,iBAAkB9gB,GAEpBU,QAASpmC,KAAK6lD,cAAcN,EAAUnsB,KAExC,MAAOj4B,GACPnB,KAAKqkD,kBAAkBljD,IAU3Bif,WAAW4iB,EAAS1zB,GAElBtP,KAAKunD,gBAAgBvkB,GACrBhjC,KAAKwnD,YAAYxkB,EAAS1zB,GAASw1B,OAAO3jC,GACxCnB,KAAKqkD,kBAAkBljD,KAcVZ,kBAACyiC,EAAS1zB,GAGzB,GAFAtP,KAAKunD,gBAAgBvkB,KAEhBhjC,KAAKa,MAAMqgB,0BAA6B5R,MAAAA,GAAAA,EAASq3C,SACpD,OAKF,MAAM7lB,EAAS,GAEf,GAAIkC,EAAQsiB,oBAAqB,CAI/B,IAAsC,KAAlCh2C,MAAAA,OAAA,EAAAA,EAAS03C,sBACX,MAAM,IAAIt+C,MACR,qGAIJ,MAAM++C,GAAqB,EAAAnpD,EAAAmtC,OACzBzI,EAAQsiB,oBACRtiB,EAAQ1f,YAGVwd,EAAOC,KACL/gC,KAAKymD,OACHzmD,KAAKimD,mBAALnjD,EAAAA,EAAA,GACKkgC,GADL,GAAA,CAEE1f,WAAYmkC,KAHhB3kD,EAAAA,EAAA,GAKOwM,GALP,GAAA,CAKgB03C,sBAAsB,MAK1ClmB,EAAOC,KAAK/gC,KAAKymD,OAAOzmD,KAAKimD,mBAAmBjjB,GAAU1zB,UAEpDvO,QAAQ61B,IAAIkK,GAQpBymB,gBAAgBvkB,GAEd,IAAKA,EAAQ5f,QAAU4f,EAAQ3f,SAC7B,MAAM,IAAI3a,MACP,+CACCs6B,EAAQ5f,wBACS4f,EAAQ3f,gCAAgCzkB,OAAO+B,KAChEqiC,OAE8B,iBAAvBA,EAAQ1f,WACV,+BAA8B1kB,OAAO+B,KAAKqiC,EAAQ1f,cACnD,4qBC1jBd,IAAA9b,EAAA5H,EAAAnB,EAAA,WACAmR,EAAAnR,EAAA,uBACA6R,EAAA7R,EAAA,mBACA2R,EAAA3R,EAAA,kBACAoB,EAAAD,EAAAnB,EAAA,aACA+S,EAAA/S,EAAA,iCACAuhD,EAAAvhD,EAAA,0BACAs3C,EAAAn2C,EAAAnB,EAAA,sCACAqB,EAAArB,EAAA,UAEA,MAAM6iD,EAAQ,mBAkBC,MAAM17B,UAA8Bpe,EAAArH,QAOjDJ,YAAY8C,GACVG,QACAhD,KAAKwd,SAAW,IAAI5N,EAAAwZ,gBAAgB,CAClCs+B,sBAAuB,GACvBC,0BAA2B,IAE7B3nD,KAAKmgD,SAAW,GAChBngD,KAAKikB,aAAephB,EAAKohB,aAQvB0jC,gCACF,OAAO/oD,OAAO+B,KAAKX,KAAKogD,qBAAqBx/C,OAS/Cw/C,oBACE,OAAOpgD,KAAKmgD,SACT93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SACpBgoB,QAAO,CAACr2B,EAAQm8B,KACfn8B,EAAOm8B,EAAI33B,IAAM23B,EACVn8B,IACN,IAYP07B,0BAA0BL,EAAWD,GACnC,OAAO,IAAI96B,SAAQ,CAACC,EAASC,KAC3B,IAAK66B,EAAU3G,KAEb,YADAl0B,EAAO,IAAIyH,MAAM,iDAGnB,MAAM2zB,EAAQr8B,KAAKqgD,qBAAqBvkB,EAAWD,GACnD77B,KAAKsgD,KAAM,GAAEjkB,cAAmB78B,IAC9B,OAAQA,EAAKsP,QACX,IAAK,YAEH,YADA9N,EAAQxB,EAAK49B,SAEf,IAAK,WAMH,YALAn8B,EACEmP,EAAA6rB,UAAUlvB,SAASwzC,oBACjB,yDAIN,IAAK,UAEH,YADAt/C,EAAO,IAAIyH,MAAM,qCAEnB,QACEzH,EACE,IAAIyH,MACD,yCAAwCu0B,KAAK2N,UAC5C9O,cAkBhBukB,qBAAqBvkB,EAAWD,GAC9Bh8B,EAAAM,QAAI8D,MACD,+CAA8Cg5B,KAAK2N,UAClD9O,MAIAD,IACFC,EAAUjV,OAASgV,EAAIhV,QAEzBiV,EAAUt8B,KAAOQ,KAAK+7B,iBAAiBD,EAAUt8B,MAEjD,MAAMghD,GAAO,IAAIvb,MAAO0J,UAClBtS,GAAQ,EAAA0Z,EAAA51C,WACRsgD,EAAU,CACdx7C,GAAIo3B,EACJP,UAAAA,EACA0kB,KAAAA,EACA1xC,OAAQ,aACR9I,KAAMwL,EAAAkvC,aAAakH,aAMrB,OAJA5nD,KAAK4gD,OAAOH,GAGZzgD,KAAKqG,KAAK,UACHg2B,EASTukB,OAAOhkB,GACL58B,KAAKmgD,SAASpf,KAAKnE,GACnB58B,KAAK6gD,eAUPhkB,OAAOR,GACL,OAAOr8B,KAAKmgD,SAASr+C,MAAM86B,GAAQA,EAAI33B,KAAOo3B,IAWhDG,eAAeV,GAEb,OADA97B,KAAK8gD,qBAAqBhlB,EAAUQ,YAC7Bt8B,KAAK6nD,qBAAqB/rB,GAQnCglB,qBAAqBzkB,GACnBr8B,KAAKghD,cAAc3kB,EAAO,YAU5BkB,sBAAsBlB,EAAOe,GAC3B,MAAMR,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIQ,QAAUA,EACdp9B,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,aAS5BwrB,qBAAqB/rB,GAEnB,cADOA,EAAUQ,WACVv7B,QAAQC,QAAQ86B,GASzBa,UAAUN,EAAOhnB,EAAS7U,WACpB6U,GACFrV,KAAKikB,aAAa,CAChBb,MAAO/N,EACPgO,SAAU,WACVC,WAAY,CACVC,OAAQ,6BAIdvjB,KAAKghD,cAAc3kB,EAAO,YAS5B7Y,aAAa6Y,EAAO/7B,GAClB,MAAMs8B,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIt8B,MAAQA,EACZN,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,WAM5BjX,kBACEplB,KAAKmgD,SAAWngD,KAAKmgD,SAAS93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SAClD9O,KAAK6gD,eAePG,cAAc3kB,EAAOvtB,GACnB,MAAM8tB,EAAM58B,KAAK68B,OAAOR,GACxB,IAAKO,EACH,MAAM,IAAIl0B,MACP,sDAAqD2zB,OAG1DO,EAAI9tB,OAASA,EACb9O,KAAKq9B,WAAWT,GAChB58B,KAAKqG,KAAM,GAAEg2B,KAASvtB,IAAU8tB,GAEnB,aAAX9tB,GACW,cAAXA,GACW,YAAXA,GAEA9O,KAAKqG,KAAM,GAAEg2B,aAAkBO,GAYnCS,WAAWT,GACT,MAAM/C,EAAQ75B,KAAKmgD,SAAS9O,WAAWntC,GAAYA,EAAQe,KAAO23B,EAAI33B,MACvD,IAAX40B,IACF75B,KAAKmgD,SAAStmB,GAAS+C,GAEzB58B,KAAK6gD,eASPA,eACE,MAAM6G,EAAwB1nD,KAAKogD,oBAC7BuH,EAA4B/oD,OAAO+B,KAAK+mD,GAAuB9mD,OACrEZ,KAAKwd,SAAS0tB,YAAY,CACxBwc,sBAAAA,EACAC,0BAAAA,IAEF3nD,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,cASvCmoB,iBAAiBv8B,GACf,IACE,MAAMs9B,GAAW,EAAAxsB,EAAAysB,gBAAev9B,GAChC,GAAIs9B,EAASoW,MAAMoO,GACjB,OAAO,EAAAxhD,EAAA2xC,cAAa3U,GAEtB,MAAOt7B,GACP3B,EAAAM,QAAI8D,MAAO,sDAGb,OAAO,EAAAqM,EAAA4wC,aAAYhsB,EAAOC,KAAK31B,EAAM,mmBClVzCoQ,EAAAnR,EAAA,uBACAqpD,EAAArpD,EAAA,+mBAmBA,MAAMspD,EAAe,CACnBC,iBAAkBF,EAAAG,uBAAuBnxB,QACvC,CAACkxB,EAAkBE,KACjBF,EAAiBE,IAAa,EACvBF,IAET,IAEFG,oCAAqC,GACrCC,qBAAsB,cAMT,MAIbroD,YAAY8C,EAAO,IACjB,MAAMyR,UAAEA,EAAY,GAAdiE,iBAAkBA,GAAqB1V,EACvChC,EAAKiC,EAAAA,EAAA,GACNilD,GADM,GAAA,CAETC,iBAAgBllD,EAAAA,EAAA,GACXilD,EAAaC,kBACb1zC,EAAU0zC,oBAIjBhoD,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAgBvoB,GAEjCb,KAAKqnB,gBAAkB9O,EAAiBgD,WAAW8L,gBAEnD9O,EAAiB3B,WAAU,EAAGyQ,gBAAAA,MACPrnB,KAAK8U,MAAMyG,WAEjB4sC,qCACbnoD,KAAKqnB,kBAAoBA,IAEzBrnB,KAAKqnB,gBAAkBA,EACvBrnB,KAAK8U,MAAMo2B,YAAY,CAAEid,oCAAqC,SAKpE73B,oBAAoB+3B,EAASC,GAC3B,IAAIN,iBAAEA,GAAqBhoD,KAAK8U,MAAMyG,WACtCysC,EAAgBllD,EAAA,GAAQklD,GACxBA,EAAiBK,GAAWC,EAC5BtoD,KAAK8U,MAAMo2B,YAAY,CAAE8c,iBAAAA,IAQ3Bz3B,gCAAgC1J,GAC9B,IAAIshC,oCAAEA,GAAwCnoD,KAAK8U,MAAMyG,WACzD4sC,EAAmCrlD,EAAA,GAC9BqlD,GAELA,EAAoCthC,IAAU,EAC9C7mB,KAAK8U,MAAMo2B,YAAY,CAAEid,oCAAAA,IAU3B3lB,sBAAsB3b,GACpB,OAAO7mB,KAAK8U,MAAMyG,WAAW6sC,qBAAqBvhC,GAQpD4b,yBAAyB5b,GACvB7mB,KAAKuoD,uBAAuB1hC,EAAQihC,EAAAU,6BAA6BC,UASnEj4B,+BAA+B3J,GAC7B7mB,KAAKuoD,uBAAuB1hC,EAAQihC,EAAAU,6BAA6BE,WAQnEH,uBAAuB1hC,EAAQroB,GAC7B,IAAI4pD,qBAAEA,GAAyBpoD,KAAK8U,MAAMyG,WAC1C6sC,EAAoBtlD,EAAA,GACfslD,GAELA,EAAqBvhC,GAAUroB,EAC/BwB,KAAK8U,MAAMo2B,YAAY,CAAEkd,qBAAAA,wvBC/H7Bx4C,EAAAnR,EAAA,uBACAoB,EAAAD,EAAAnB,EAAA,aACAkqD,EAAA/oD,EAAAnB,EAAA,UACAs3C,EAAAn2C,EAAAnB,EAAA,sCACAqB,EAAArB,EAAA,eACAiR,EAAA9P,EAAAnB,EAAA,+CAEAwS,EAAAxS,EAAA,yCAIA0S,EAAA1S,EAAA,qCASA6E,EAAA7E,EAAA,6mBAEA,MAAM8E,GAAmB,EAAAmM,EAAAvP,SAA6B,GAATmD,EAAAE,QAiCvColD,EAA6B,CACjCz3C,EAAA48B,gBACA58B,EAAA88B,eACA98B,EAAA6I,iBACA7I,EAAA08B,iBACA18B,EAAAw8B,kBAiQF,SAASkb,EAAwBC,EAAYC,GAC3C,IACIC,EADAC,GAAQ,EAEZ,OAAQzqD,IACN,IACE,OAAIyqD,GACFA,GAAQ,EACDH,EAAWC,MAAAA,EAAAA,EAAgBvqD,EAAOA,IAEpCsqD,EAAWE,EAAOxqD,GAL3B,QAOEwqD,EAAQxqD,cAzQC,MACbuB,YAAY8C,EAAO,IACjB,MAAMsT,aACJA,EADIqC,mBAEJA,EAFI3K,kBAGJA,EAHIuI,sBAIJA,GACEvT,EACJ7C,KAAKmW,aAAeA,EACpBnW,KAAK6N,kBAAoBA,EACzB7N,KAAKoW,sBAAwBA,EAE7BpW,KAAKkpD,eAAiB3oD,MAAAA,IACpB,MAAM8mB,EAAkBrnB,KAAKoW,sBAAsB4R,qBAC7CmhC,EAAoBnvB,SAASovB,EAAmB,UAChDppD,KAAKqpD,QAAQhiC,EAAiB8hC,IAGtC,MAAM70C,EAASxR,EAAA,CACbu4C,qBAAsB,GACtB1I,oCAAqC,CACnC,CAACxhC,EAAA48B,iBAAkB,KACnB,CAAC58B,EAAA88B,gBAAiB,KAClB,CAAC98B,EAAA6I,kBAAmB,KACpB,CAAC7I,EAAA08B,kBAAmB,KACpB,CAAC18B,EAAAw8B,kBAAmB,OAEnB9qC,EAAKyR,WAEVtU,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAgB9U,GAEjCtU,KAAKoW,sBAAsBtB,MAAM8B,UAC/BiyC,GAAwB,CAACS,EAAWC,KAClC,MACE7c,cACE8c,yBAA0BC,GACxB,IACFH,GAEF5c,cACE8c,yBAA0BE,GACxB,IACFH,EAEAG,IAAiCD,KAIjCA,GAAiCC,EAKrC1pD,KAAK4c,QAJH5c,KAAK6c,UAKN7c,KAAKoW,sBAAsBtB,MAAMyG,aAGtCvb,KAAKoW,sBAAsBtB,MAAM8B,UAC/BiyC,GAAwBtoD,MAAO+oD,EAAWC,KACxC,MAAQliC,gBAAiBsiC,GAAwBL,GACzCjiC,gBAAiBuiC,GAAwBL,EAE7CK,IAAwBD,SAGtB3pD,KAAKqpD,QAAQO,KAClB5pD,KAAKoW,sBAAsBtB,MAAMyG,aAGtC/C,GAAmBjY,UACjB,MAAMme,EAAU1e,KAAKoW,sBAAsB4R,2BACrChoB,KAAKqpD,QAAQ3qC,MAIvB9B,QACE,MAAM8vB,aAAEA,EAAe,IAAO1sC,KAAKoW,sBAAsBtB,MAAMyG,YACzDiuC,yBAAEA,GAA6B9c,EAEhC8c,IAILxpD,KAAKmW,aAAazI,eAAe,SAAU1N,KAAKkpD,gBAChDlpD,KAAKmW,aAAa9I,YAAY,SAAUrN,KAAKkpD,iBAG/CrsC,OACE7c,KAAKmW,aAAazI,eAAe,SAAU1N,KAAKkpD,gBAarC3oD,cAACme,EAASyqC,GACrB,MAAMnrD,EAAUgC,KAAK6N,oBACrB,GAAK+6C,EAA2B16C,SAASlQ,IAAa0gB,EAGtD,IAAI,IAAAmrC,EACF,MAAMC,EAAe9pD,KAAK8U,MAAMyG,WAC1BwuC,EAAe/vB,SAASh6B,KAAKmW,aAAa6zC,kBAAmB,IAE7DC,EACJH,EAAanX,oCAAoC30C,GAC7CksD,EAAgB,QAAAL,EACpBI,MAAAA,EAAAA,EAA4Bd,SADR,IAAAU,EAAAA,EAC6BE,EAE7CI,QAAuBnqD,KAAKoqD,4BAChC1rC,EACAwrC,EACAlsD,GAGF,IAAIqsD,EAA8BH,EAElCC,EAAerrD,SAAS44B,IAEpBA,EAAG4yB,aACHtwB,SAASqwB,EAA6B,IACpCrwB,SAAStC,EAAG4yB,YAAa,MAE3BD,EAA8BrwB,SAAStC,EAAG4yB,YAAa,QAI3DtqD,KAAK8U,MAAMo2B,YAAY,CACrByH,oCAAmC7vC,EAAAA,EAAA,GAC9BgnD,EAAanX,qCADiB,GAAA,CAEjC30C,CAACA,GAAUqsD,EAA8B,IAE3ChP,qBAAsB8O,EAAerzB,QACnC,CAACU,EAAcE,KACbF,EAAaE,EAAGjpB,MAAQipB,EACjBF,IAHW10B,EAAA,GAMfgnD,EAAazO,yBAItB,MAAOl6C,GACPtB,EAAAM,QAAIG,MAAMa,IAcmBZ,kCAACme,EAAS6rC,EAAWvsD,GAOpD,IAAIL,EAAO,GADK,WAJdK,IAAYmT,EAAA6I,iBACR,MACC,OAAM7I,EAAAq5C,qBAAqBxsD,gEAG8B0gB,sBAE5D6rC,IACF5sD,GAAQ,eAAcq8B,SAASuwB,EAAW,OAE5C,MAAMzmD,QAAiBP,EAAiB5F,IAClCmR,OAAEA,EAAFrO,OAAUA,SAAiBqD,EAASE,OAC1C,IAAImmD,EAAiB,GACrB,GAAe,MAAXr7C,GAAkB2rB,MAAMuS,QAAQvsC,IAAWA,EAAOG,OAAS,EAAG,CAChE,MAAM6pD,EAAe,GACfC,EAAY,GAClBjqD,EAAO3B,SAAS44B,IACT+yB,EAAa/yB,EAAGjpB,QACnBi8C,EAAU3pB,KAAK/gC,KAAK2qD,0BAA0BjzB,EAAI15B,IAClDysD,EAAa/yB,EAAGjpB,MAAQ,MAI5B07C,EAAiBO,EAAUriD,QACxBqvB,IAAD,IAAA4X,EAAAsb,EAAA,OAAQ,QAAAtb,EAAA5X,EAAGrV,gBAAH,IAAAitB,GAAA,QAAAsb,EAAAtb,EAAaoC,UAAb,IAAAkZ,OAAA,EAAAA,EAAiBhpD,iBAAkB8c,EAAQ9c,iBAErDuoD,EAAexiD,MAAK,CAACC,EAAGC,IAAOD,EAAE44C,KAAO34C,EAAE24C,MAAQ,EAAI,IAExD,OAAO2J,EAUTQ,0BAA0BE,EAAsB7sD,GAC9C,MAAMwiD,EAAsD,IAA/CxmB,SAAS6wB,EAAqBC,UAAW,IAChDh8C,EAC6B,MAAjC+7C,EAAqBE,QACjB95C,EAAAsQ,qBAAqBC,UACrBvQ,EAAAsQ,qBAAqBE,OACrBY,EAAW,CACf8S,KAAM01B,EAAqB11B,KAC3Bwc,KAAK,EAAA7xC,EAAAkrD,SAAQ,IAAIrC,EAAAxoD,QAAG0qD,EAAqBlZ,MACzCnC,OAAO,EAAA1vC,EAAAkrD,SAAQ,IAAIrC,EAAAxoD,QAAG0qD,EAAqBrb,QAC3CkC,GAAImZ,EAAqBnZ,GACzBlzC,OAAO,EAAAsB,EAAAkrD,SAAQ,IAAIrC,EAAAxoD,QAAG0qD,EAAqBrsD,SAc7C,OAXIqsD,EAAqBjZ,SACvBvvB,EAASuvB,UAAW,EAAA9xC,EAAAkrD,SAAQ,IAAIrC,EAAAxoD,QAAG0qD,EAAqBjZ,WAC/CiZ,EAAqBI,eAC9B5oC,EAAS4oC,cAAe,EAAAnrD,EAAAkrD,SACtB,IAAIrC,EAAAxoD,QAAG0qD,EAAqBI,eAE9B5oC,EAAS6oC,sBAAuB,EAAAprD,EAAAkrD,SAC9B,IAAIrC,EAAAxoD,QAAG0qD,EAAqBK,wBAIzB,CACLZ,YAAaO,EAAqBP,YAClCrlD,IAAI,EAAA8wC,EAAA51C,WACJnC,QAAAA,EACAixC,kBAAmB99B,EAAAg6C,2BAA2BntD,GAC9C8Q,OAAAA,EACA0xC,KAAAA,EACAn+B,SAAAA,EACA5T,KAAMo8C,EAAqBp8C,KAC3BzI,KAAMiL,EAAAkR,kBAAkBo5B,qkBC5S9B,IAAA/zC,EAAA5H,EAAAnB,EAAA,WACAmR,EAAAnR,EAAA,uBACA2R,EAAA3R,EAAA,kBACAoB,EAAAD,EAAAnB,EAAA,aACA+S,EAAA/S,EAAA,iCACAuhD,EAAAvhD,EAAA,0BACAs3C,EAAAn2C,EAAAnB,EAAA,sCAkBe,MAAMonB,UAAmCre,EAAArH,QAOtDJ,YAAY8C,GACVG,QACAhD,KAAKwd,SAAW,IAAI5N,EAAAwZ,gBAAgB,CAClCgiC,kCAAmC,GACnCC,sCAAuC,IAEzCrrD,KAAKmgD,SAAW,GAChBngD,KAAKikB,aAAephB,EAAKohB,aAQvBonC,4CACF,OAAOzsD,OAAO+B,KAAKX,KAAKogD,qBAAqBx/C,OAS/Cw/C,oBACE,OAAOpgD,KAAKmgD,SACT93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SACpBgoB,QAAO,CAACr2B,EAAQm8B,KACfn8B,EAAOm8B,EAAI33B,IAAM23B,EACVn8B,IACN,IAYP07B,0BAA0Bzd,EAASmd,GACjC,OAAO,IAAI96B,SAAQ,CAACC,EAASC,KAC3B,IAAKyd,EAEH,YADAzd,EAAO,IAAIyH,MAAM,iDAGnB,MAAM2zB,EAAQr8B,KAAKqgD,qBAAqB3hC,EAASmd,GACjD77B,KAAKsgD,KAAM,GAAEjkB,cAAmB78B,IAC9B,OAAQA,EAAKsP,QACX,IAAK,WAEH,YADA9N,EAAQxB,EAAK49B,SAEf,IAAK,WAMH,YALAn8B,EACEmP,EAAA6rB,UAAUlvB,SAASwzC,oBACjB,2EAIN,QACEt/C,EACE,IAAIyH,MACD,kDAAiDu0B,KAAK2N,UACrDlsB,cAkBhB2hC,qBAAqB3hC,EAASmd,GAC5Bh8B,EAAAM,QAAI8D,MAAO,4DAEX,MAAMu8C,GAAO,IAAIvb,MAAO0J,UAClBtS,GAAQ,EAAA0Z,EAAA51C,WACRsgD,EAAU,CACdx7C,GAAIo3B,EACJP,UAAWpd,EACX8hC,KAAAA,EACA1xC,OAAQ,aACR9I,KAAMwL,EAAAkvC,aAAa4K,+BAWrB,OARIzvB,IACF4kB,EAAQ55B,OAASgV,EAAIhV,QAGvB7mB,KAAK4gD,OAAOH,GAGZzgD,KAAKqG,KAAK,UACHg2B,EASTukB,OAAOhkB,GACL58B,KAAKmgD,SAASpf,KAAKnE,GACnB58B,KAAK6gD,eAUPhkB,OAAOR,GACL,OAAOr8B,KAAKmgD,SAASr+C,MAAM86B,GAAQA,EAAI33B,KAAOo3B,IAWhDG,eAAeV,GAEb,OADA97B,KAAK8gD,qBAAqBhlB,EAAUQ,YAC7Bt8B,KAAKurD,8BAA8BzvB,GAQ5CglB,qBAAqBzkB,GACnBr8B,KAAKghD,cAAc3kB,EAAO,YAU5BsB,qBAAqBtB,EAAOe,GAC1B,MAAMR,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIQ,QAAUA,EACdp9B,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,YAS5BkvB,8BAA8BzvB,GAE5B,cADOA,EAAUQ,WACVv7B,QAAQC,QAAQ86B,GASzBa,UAAUN,EAAOhnB,EAAS7U,WACpB6U,GACFrV,KAAKikB,aAAa,CAChBb,MAAO/N,EACPgO,SAAU,WACVC,WAAY,CACVC,OAAQ,mCAIdvjB,KAAKghD,cAAc3kB,EAAO,YAS5B7Y,aAAa6Y,EAAO/7B,GAClB,MAAMs8B,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIt8B,MAAQA,EACZN,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,WAM5BjX,kBACEplB,KAAKmgD,SAAWngD,KAAKmgD,SAAS93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SAClD9O,KAAK6gD,eAePG,cAAc3kB,EAAOvtB,GACnB,MAAM8tB,EAAM58B,KAAK68B,OAAOR,GACxB,IAAKO,EACH,MAAM,IAAIl0B,MACP,2DAA0D2zB,OAG/DO,EAAI9tB,OAASA,EACb9O,KAAKq9B,WAAWT,GAChB58B,KAAKqG,KAAM,GAAEg2B,KAASvtB,IAAU8tB,GACjB,aAAX9tB,GAAoC,aAAXA,GAC3B9O,KAAKqG,KAAM,GAAEg2B,aAAkBO,GAYnCS,WAAWT,GACT,MAAM/C,EAAQ75B,KAAKmgD,SAAS9O,WAAWntC,GAAYA,EAAQe,KAAO23B,EAAI33B,MACvD,IAAX40B,IACF75B,KAAKmgD,SAAStmB,GAAS+C,GAEzB58B,KAAK6gD,eASPA,eACE,MAAMuK,EAAoCprD,KAAKogD,oBACzCiL,EAAwCzsD,OAAO+B,KACnDyqD,GACAxqD,OACFZ,KAAKwd,SAAS0tB,YAAY,CACxBkgB,kCAAAA,EACAC,sCAAAA,IAEFrrD,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,umBClTzCpM,EAAA5H,EAAAnB,EAAA,WACAmR,EAAAnR,EAAA,uBACAuhD,EAAAvhD,EAAA,0BACA6E,EAAA7E,EAAA,6mBAEe,MAAM8b,UAA2B/S,EAAArH,QAI9CJ,YAAY8C,EAAO,IACjB,MAAMwX,kBACJA,EADIC,WAEJA,EAFIhG,UAGJA,EAHIkG,kBAIJA,EAJIE,kBAKJA,EALInC,iBAMJA,EANIoC,gBAOJA,GACE9X,EACJG,QAEAhD,KAAKwa,kBAAoBA,GAAiB,KAAWha,WACrDR,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAJtmB,EAAAA,EAAA,CACX0oD,eAAgB,EAChB5c,oCAAoC,EACpC6c,yBAA0B,KAC1BC,mBAAoB,GACpBC,mBAAoB,GACpBC,0BAA2B,GAC3BC,wBAAyB,GACzBhb,oCAAoC,EACpCC,iCAAiC,IAAI7L,MAAO0J,UAC5Cmd,sCAAsC,EACtCC,gCAAgC,EAChCC,8BAA8B,EAC9BC,YAAa,MACV33C,GAdQ,GAAA,CAeX43C,WAAY,GACZC,0BAA2B,MAE7BnsD,KAAKosD,MAAQ,KAEbpsD,KAAKsa,WAAaA,EAClBta,KAAKqsD,iBAAmB,GACxBhyC,EAAkBra,KAAKssD,aAAa3nD,KAAK3E,OAEzCA,KAAKusD,mBAAqB7xC,EAE1BnC,EAAiB3B,WAAU,EAAG6I,YAAAA,MACPzf,KAAK8U,MAAMyG,WACfiwC,iBAAmB/rC,EAAY6uB,mBAC9CtuC,KAAKwsD,oBAAoB/sC,EAAY6uB,sBAIzC3zB,EAAgB/D,WAAW/V,IACzBb,KAAK8U,MAAMo2B,YAAY,CAAEghB,WAAYrrD,OAGvC,MAAM4e,YAAEA,GAAgBlH,EAAiBgD,WACzCvb,KAAKwsD,oBAAoB/sC,EAAY6uB,mBAYvCjN,iBAAiBorB,GACf,OAAO,IAAI1rD,SAASC,IACdhB,KAAKsa,aACPtZ,IAEAhB,KAAK0sD,cAAc1rD,EAASyrD,MAclCC,cAAc1rD,EAASyrD,GACrBzsD,KAAKqsD,iBAAiBtrB,KAAK,CAAE//B,QAAAA,IAC7BhB,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,cACjC64C,GACFzsD,KAAKusD,qBAOTD,eACE,GAAItsD,KAAKqsD,iBAAiBzrD,OAAS,EAAG,CACpC,KAAOZ,KAAKqsD,iBAAiBzrD,OAAS,GACpCZ,KAAKqsD,iBAAiB7kB,QAAQxmC,UAEhChB,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,eASzCqa,4BAA4Bw9B,GAC1BzrD,KAAK8U,MAAMo2B,YAAY,CACrBugB,yBAAAA,IAOJv9B,wCACEluB,KAAK8U,MAAMo2B,YAAY,CACrB0D,oCAAoC,IAOxCzgB,wCACEnuB,KAAK8U,MAAMo2B,YAAY,CACrB2F,oCAAoC,IASxCziB,mCAAmCu+B,GACjC3sD,KAAK8U,MAAMo2B,YAAY,CACrB4F,gCAAiC6b,IAOrC3+B,oBACEhuB,KAAK4sD,cASPJ,oBAAoBhB,GAClBxrD,KAAK8U,MAAMo2B,YAAY,CACrBsgB,eAAAA,IAGFxrD,KAAK4sD,cAWPA,cACE,MAAMpB,eAAEA,GAAmBxrD,KAAK8U,MAAMyG,WAElCvb,KAAKosD,OACPtlB,aAAa9mC,KAAKosD,OAGfZ,IAILxrD,KAAKosD,MAAQ5lB,YACX,IAAMxmC,KAAKwa,qBACXgxC,EAAiBloD,EAAA4+C,SAUrB57B,sBAAsBC,EAAIsmC,GACxB7sD,KAAK8U,MAAMo2B,YAAY,CAAEwgB,mBAAoB,CAAEnlC,GAAAA,EAAIsmC,QAAAA,KASrDz4B,gBAAgByR,EAAcinB,GAC5B,MAAMxD,EAAYtpD,KAAK8U,MAAMyG,WAAWuxC,GACxC9sD,KAAK8U,MAAMo2B,YAAY,CACrB4hB,CAACA,GAAmB,IAAIxD,EAAWzjB,KAUvCvR,mBAAmBuR,EAAcinB,GAC/B,MAAMxD,EAAYtpD,KAAK8U,MAAMyG,WAAWuxC,GACxC9sD,KAAK8U,MAAMo2B,YAAY,CACrB4hB,CAACA,GAAmBxD,EAAUjhD,QAAQykC,GAAUA,IAAUjH,MAO9DL,qBACExlC,KAAK8U,MAAMo2B,YAAY,CACrBygB,mBAAoB,GACpBC,0BAA2B,GAC3BC,wBAAyB,KAS7Bx9B,gCAAgC29B,GAC9BhsD,KAAK8U,MAAMo2B,YAAY,CAAE8gB,6BAAAA,IAQ3B/yB,eAAegzB,GACbjsD,KAAK8U,MAAMo2B,YAAY,CAAE+gB,YAAAA,IAQ3B39B,wCACEw9B,GAEA9rD,KAAK8U,MAAMo2B,YAAY,CACrB4gB,qCAAAA,IASJv9B,kCAAkCw9B,GAChC/rD,KAAK8U,MAAMo2B,YAAY,CACrB6gB,+BAAAA,IASJv9B,+BAA+B29B,GAC7BnsD,KAAK8U,MAAMo2B,YAAY,CACrBihB,0BAAAA,6pBCrSN,IAAA3kD,EAAA5H,EAAAnB,EAAA,WACAsuD,EAAAtuD,EAAA,UACAmR,EAAAnR,EAAA,uBACA2R,EAAA3R,EAAA,kBACAuuD,EAAAvuD,EAAA,gBACAoB,EAAAD,EAAAnB,EAAA,aACAwuD,EAAArtD,EAAAnB,EAAA,eACA+S,EAAA/S,EAAA,iCACAuhD,EAAAvhD,EAAA,0BACAs3C,EAAAn2C,EAAAnB,EAAA,sCACA8S,EAAA9S,EAAA,2CAmBe,MAAMyuD,UAA4B1lD,EAAArH,QAQ/CJ,aAAY8N,kBAAEA,EAAFoW,aAAqBA,IAC/BjhB,QACAhD,KAAKmtD,mBAAqBt/C,EAC1B7N,KAAKwd,SAAW,IAAI5N,EAAAwZ,gBAAgB,CAClCgkC,wBAAyB,GACzBC,6BAA8B,IAEhCrtD,KAAKmgD,SAAW,GAChBngD,KAAKikB,aAAeA,EAQlBopC,mCACF,OAAOzuD,OAAO+B,KAAKX,KAAKogD,qBAAqBx/C,OAS/Cw/C,oBACE,OAAOpgD,KAAKmgD,SACT93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SACpBgoB,QAAO,CAACr2B,EAAQm8B,KACfn8B,EAAOm8B,EAAI33B,IAAM23B,EACVn8B,IACN,IAaP07B,0BAA0BL,EAAWD,EAAK/zB,GACxC,OAAO,IAAI/G,SAAQ,CAACC,EAASC,KAC3B,MAAMo7B,EAAQr8B,KAAKqgD,qBAAqBvkB,EAAWD,EAAK/zB,GACxD9H,KAAKsgD,KAAM,GAAEjkB,cAAmB78B,IAC9B,OAAQA,EAAKsP,QACX,IAAK,SACH,OAAO9N,EAAQxB,EAAKi9B,QACtB,IAAK,WACH,OAAOx7B,EACLmP,EAAA6rB,UAAUlvB,SAASwzC,oBACjB,+DAGN,IAAK,UACH,OAAOt/C,EACL,IAAIyH,MAAO,+BAA8BlJ,EAAKc,UAElD,QACE,OAAOW,EACL,IAAIyH,MACD,gDAA+Cu0B,KAAK2N,UACnD9O,cAmBhBukB,qBAAqBvkB,EAAWD,EAAK/zB,GACnCg0B,EAAUh0B,QAAUA,EAChB+zB,IACFC,EAAUjV,OAASgV,EAAIhV,QAEzB7mB,KAAKstD,eAAexxB,GAEpBj8B,EAAAM,QAAI8D,MACD,6CAA4Cg5B,KAAK2N,UAAU9O,MAI9D,MAAM0kB,GAAO,IAAIvb,MAAO0J,UAClBtS,GAAQ,EAAA0Z,EAAA51C,WACRsgD,EAAU,CACdx7C,GAAIo3B,EACJP,UAAAA,EACA0kB,KAAAA,EACA1xC,OAAQ,aACR9I,KAAMwL,EAAAkvC,aAAa6M,qBAMrB,OAJAvtD,KAAK4gD,OAAOH,GAGZzgD,KAAKqG,KAAK,UACHg2B,EAQTixB,eAAepmC,GAab,OAZA6lC,EAAAS,OAAOzpD,GACLmjB,GAA4B,iBAAXA,EACjB,6BAEF6lC,EAAAS,OAAOzpD,GAAG,SAAUmjB,EAAQ,uCAC5B6lC,EAAAS,OAAOzpD,GAAG,SAAUmjB,EAAQ,uCAC5B6lC,EAAAS,OAAOzpD,GACkB,iBAAhBmjB,EAAOiO,OACZ,EAAA5jB,EAAAk8C,mBAAkBvmC,EAAOiO,KAAM,CAAEu4B,kBAAkB,IACrD,iFAGMxmC,EAAOpf,SACb,IAAK,KACHilD,EAAAS,OAAOzpD,GACL02B,MAAMuS,QAAQ9lB,EAAO1nB,MACrB,mCAEFutD,EAAAS,OAAOG,cAAa,MAClB,EAAAX,EAAAY,oBAAmB1mC,EAAO1nB,QACzB,kDACH,MACF,IAAK,KACL,IAAK,KAAM,CAMT,IAAIA,EALJutD,EAAAS,OAAOK,aACE3mC,EAAO1nB,KACd,SACA,mCAGFutD,EAAAS,OAAOG,cAAa,KAClBnuD,EAAOy9B,KAAKC,MAAMhW,EAAO1nB,QACxB,uCACH,MAAMsuD,EAAab,EAAA9sD,QAAW4tD,SAASvuD,EAAMwtD,EAAAgB,sBAC7CjB,EAAAS,OAAOzpD,GACLvE,EAAKyuD,eAAezuD,EAAKgO,MACxB,oBAAmBhO,EAAKyuD,wCAE3BlB,EAAAS,OAAOK,MACLC,EAAWI,OAAOttD,OAClB,EACA,0EAEF,IAAI5C,QAAEA,GAAYwB,EAAK2uD,OACvB,GAAInwD,EAAS,CACX,MAAMowD,EAAgBp0B,SAASh6B,KAAKmtD,qBAAsB,IAC1DJ,EAAAS,OAAOzpD,IACJgtC,OAAOC,MAAMod,GACb,qCAAoCpwD,+CAEhB,iBAAZA,IACTA,EAAUg8B,SAASh8B,EAASA,EAAQqwD,WAAW,MAAQ,GAAK,KAE9DtB,EAAAS,OAAOK,MACL7vD,EACAowD,EACC,qBAAoBpwD,qCAA2CowD,MAGpE,MAEF,QACErB,EAAAS,OAAOc,KAAM,+BAA8BpnC,EAAOpf,aAUxD84C,OAAOhkB,GACL58B,KAAKmgD,SAASpf,KAAKnE,GACnB58B,KAAK6gD,eAUPhkB,OAAOR,GACL,OAAOr8B,KAAKmgD,SAASr+C,MAAM86B,GAAQA,EAAI33B,KAAOo3B,IAWhDG,eAAeV,GAEb,OADA97B,KAAK8gD,qBAAqBhlB,EAAUQ,YAC7Bt8B,KAAK+gD,kBAAkBjlB,GAQhCglB,qBAAqBzkB,GACnBr8B,KAAKghD,cAAc3kB,EAAO,YAU5BK,mBAAmBL,EAAOI,GACxB,MAAMG,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIH,OAASA,EACbz8B,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,UAS5B0kB,kBAAkBjlB,GAGhB,cAFOA,EAAUQ,kBACVR,EAAUh0B,QACV/G,QAAQC,QAAQ86B,GASzBa,UAAUN,EAAOhnB,EAAS7U,WACxB,GAAI6U,EAAQ,CACV,MAAMunB,EAAM58B,KAAK68B,OAAOR,GACxBr8B,KAAKikB,aAAa,CAChBb,MAAO/N,EACPgO,SAAU,eACVC,WAAY,CACVC,OAAQ,eACRzb,QAAS80B,EAAId,UAAUh0B,QACvB9B,KAAM42B,EAAI52B,QAIhBhG,KAAKghD,cAAc3kB,EAAO,YAS5B7Y,aAAa6Y,EAAO/7B,GAClB,MAAMs8B,EAAM58B,KAAK68B,OAAOR,GACxBO,EAAIt8B,MAAQA,EACZN,KAAKq9B,WAAWT,GAChB58B,KAAKghD,cAAc3kB,EAAO,WAM5BjX,kBACEplB,KAAKmgD,SAAWngD,KAAKmgD,SAAS93C,QAAQu0B,GAAuB,eAAfA,EAAI9tB,SAClD9O,KAAK6gD,eAmBPG,cAAc3kB,EAAOvtB,GACnB,MAAM8tB,EAAM58B,KAAK68B,OAAOR,GACxB,IAAKO,EACH,MAAM,IAAIl0B,MACP,oDAAmD2zB,OAGxDO,EAAI9tB,OAASA,EACb9O,KAAKq9B,WAAWT,GAChB58B,KAAKqG,KAAM,GAAEg2B,KAASvtB,IAAU8tB,GACjB,aAAX9tB,GAAoC,WAAXA,GAAkC,YAAXA,GAClD9O,KAAKqG,KAAM,GAAEg2B,aAAkBO,GAYnCS,WAAWT,GACT,MAAM/C,EAAQ75B,KAAKmgD,SAAS9O,WAAWntC,GAAYA,EAAQe,KAAO23B,EAAI33B,MACvD,IAAX40B,IACF75B,KAAKmgD,SAAStmB,GAAS+C,GAEzB58B,KAAK6gD,eASPA,eACE,MAAMuM,EAA0BptD,KAAKogD,oBAC/BiN,EAA+BzuD,OAAO+B,KAAKysD,GAC9CxsD,OACHZ,KAAKwd,SAAS0tB,YAAY,CACxBkiB,wBAAAA,EACAC,6BAAAA,IAEFrtD,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,kqBC5YzC26C,EAAA3uD,EAAAnB,EAAA,sBACAmR,EAAAnR,EAAA,uBACAoB,EAAAD,EAAAnB,EAAA,aACA0S,EAAA1S,EAAA,wCACA8S,EAAA9S,EAAA,8CACA2T,EAAAxS,EAAAnB,EAAA,+lBAKe,MACbsB,aAAYyuD,IAAEA,EAAFzhD,SAAOA,EAAPyL,mBAAiBA,EAAjB3K,kBAAqCA,GAAsB,IACrE,MAAMyG,EAAY,CAChBm6C,wBAAyB,IAI3B,GADAzuD,KAAKoS,KAAOo8C,GACPxuD,KAAKoS,KAAM,CACd,MAAMpU,EAAU6P,IACV0I,EAAUpF,EAAAg6C,2BAA2BntD,GACvCoU,EAAAjS,QAAIuuD,qBAAqBn4C,KAC3BvW,KAAKoS,KAAO,IAAIA,EAAAjS,QAAI,CAClBoW,QAAAA,EACAxJ,SAAAA,KAKN/M,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAgB9U,GACjCkE,GAAmB,KACjBxY,KAAK8U,MAAMwU,SAAShV,GACpB,MAAMtW,EAAU6P,IACV0I,EAAUpF,EAAAg6C,2BAA2BntD,GACvCoU,EAAAjS,QAAIuuD,qBAAqBn4C,GAC3BvW,KAAKoS,KAAO,IAAIA,EAAAjS,QAAI,CAClBoW,QAAAA,EACAxJ,SAAAA,WAGK/M,KAAKoS,QAKlBsc,sBAAsBhQ,GACpB,OAAO1e,KAAK2uD,wBAAuB,EAAAp9C,EAAA8kB,sBAAqB3X,IAG9Bne,6BAACme,GAC3B,IAAK1e,KAAKoS,KACR,OAAO5R,UAGT,MAAMK,EAAQb,KAAK8U,MAAMyG,WACzB,GAAI1a,EAAM4tD,wBAAwB/vC,GAChC,OAAO7d,EAAM4tD,wBAAwB/vC,GAGvC,IAAIyvC,EAQAS,EAPJ,IACET,QAAenuD,KAAKoS,KAAK8+B,QAAQxyB,GACjC,MAAOpe,GAEP,OADAT,EAAAM,QAAI8D,MAAM3D,GACHE,UAIT,IACEouD,QAA0B5uD,KAAKoS,KAAKy8C,OAAOV,GAC3C,MAAO7tD,GAEP,OADAT,EAAAM,QAAI8D,MAAM3D,GACHE,UAGT,MAnEiB,+CAoEfouD,GAnEuB,OAoEvBA,IAKE,EAAAr9C,EAAA8kB,sBAAqBu4B,KAAuBlwC,EAHvCle,WAOTR,KAAK8uD,4BAA4BpwC,EAAS6vC,EAAApuD,QAAS4uD,QAAQZ,IACpDA,GAGTW,4BAA4BpwC,EAASyvC,GACnC,MAAMa,EAAWhvD,KAAK8U,MAAMyG,WAC5Bvb,KAAK8U,MAAMwU,SAAS,CAClBmlC,wBAAuB3rD,EAAAA,EAAA,GAClBksD,EAASP,yBADS,GAAA,CAErB/vC,CAACA,GAAUyvC,2XC9FnB,IAAAc,EAAAxwD,EAAA,qBAAAG,OAAA+B,KAAAsuD,GAAAnwD,SAAA,SAAAC,GAAA,YAAAA,GAAA,eAAAA,IAAAA,KAAAK,GAAAA,EAAAL,KAAAkwD,EAAAlwD,IAAAH,OAAAqI,eAAA7H,EAAAL,EAAA,CAAAmI,YAAA,EAAAhG,IAAA,WAAA,OAAA+tD,EAAAlwD,UACA,IAAAmwD,EAAAzwD,EAAA,oBAAAG,OAAA+B,KAAAuuD,GAAApwD,SAAA,SAAAC,GAAA,YAAAA,GAAA,eAAAA,IAAAA,KAAAK,GAAAA,EAAAL,KAAAmwD,EAAAnwD,IAAAH,OAAAqI,eAAA7H,EAAAL,EAAA,CAAAmI,YAAA,EAAAhG,IAAA,WAAA,OAAAguD,EAAAnwD,UACA,IAAAowD,EAAA1wD,EAAA,WAAAG,OAAA+B,KAAAwuD,GAAArwD,SAAA,SAAAC,GAAA,YAAAA,GAAA,eAAAA,IAAAA,KAAAK,GAAAA,EAAAL,KAAAowD,EAAApwD,IAAAH,OAAAqI,eAAA7H,EAAAL,EAAA,CAAAmI,YAAA,EAAAhG,IAAA,WAAA,OAAAiuD,EAAApwD,UACA,IAAAqwD,EAAA3wD,EAAA,oBAAAG,OAAA+B,KAAAyuD,GAAAtwD,SAAA,SAAAC,GAAA,YAAAA,GAAA,eAAAA,IAAAA,KAAAK,GAAAA,EAAAL,KAAAqwD,EAAArwD,IAAAH,OAAAqI,eAAA7H,EAAAL,EAAA,CAAAmI,YAAA,EAAAhG,IAAA,WAAA,OAAAkuD,EAAArwD,UACA,IAAAswD,EAAA5wD,EAAA,oBAAAG,OAAA+B,KAAA0uD,GAAAvwD,SAAA,SAAAC,GAAA,YAAAA,GAAA,eAAAA,IAAAA,KAAAK,GAAAA,EAAAL,KAAAswD,EAAAtwD,IAAAH,OAAAqI,eAAA7H,EAAAL,EAAA,CAAAmI,YAAA,EAAAhG,IAAA,WAAA,OAAAmuD,EAAAtwD,UACA,IAAAuwD,EAAA7wD,EAAA,eAAAG,OAAA+B,KAAA2uD,GAAAxwD,SAAA,SAAAC,GAAA,YAAAA,GAAA,eAAAA,IAAAA,KAAAK,GAAAA,EAAAL,KAAAuwD,EAAAvwD,IAAAH,OAAAqI,eAAA7H,EAAAL,EAAA,CAAAmI,YAAA,EAAAhG,IAAA,WAAA,OAAAouD,EAAAvwD,u6CCLAoF,EAAAvE,EAAAnB,EAAA,uBACAmR,EAAAnR,EAAA,uBACA6R,EAAA7R,EAAA,mBACAy+C,EAAAt9C,EAAAnB,EAAA,gBACA2R,EAAA3R,EAAA,kBACA8wD,EAAA3vD,EAAAnB,EAAA,6BACA+wD,EAAA5vD,EAAAnB,EAAA,uBACAgxD,EAAAhxD,EAAA,kBACAixD,EAAAjxD,EAAA,UACAkxD,EAAA/vD,EAAAnB,EAAA,kBACAoB,EAAAD,EAAAnB,EAAA,aACA+8C,EAAA57C,EAAAnB,EAAA,iBACAmxD,EAAAhwD,EAAAnB,EAAA,8BACAqB,EAAArB,EAAA,kBAOAoxD,EAAApxD,EAAA,+CACAyS,EAAAzS,EAAA,yCACAgT,EAAAhT,EAAA,iDAIAwS,EAAAxS,EAAA,4CAMAkT,EAAAlT,EAAA,iDACAuhD,EAAAvhD,EAAA,6BACAqxD,EAAArxD,EAAA,oCAOAsxD,EAAAtxD,EAAA,+CACA0S,EAAA1S,EAAA,wCAMAuxD,EAAAvxD,EAAA,gDACAwxD,EAAAxxD,EAAA,6CACAyxD,EAAAzxD,EAAA,qCACA0xD,EAAAvwD,EAAAnB,EAAA,uBACA2xD,EAAAxwD,EAAAnB,EAAA,mBACA4xD,EAAAzwD,EAAAnB,EAAA,yBACA6xD,8bAAAh+C,CAAA7T,EAAA,ytBAEA,MAAM8xD,EAAe,IAAIb,EAAAc,OAAOC,MAAMC,UAAUnB,EAAApvD,SAI1CwwD,EAAyB,CAC7B1/C,EAAAkR,kBAAkByuC,KAClB3/C,EAAAkR,kBAAkB0uC,eAQdC,EAAwB,kBAuCf,MAAMxwC,UAA8Bnc,EAAAhE,QACjDJ,YAAY8C,GACVG,QACAhD,KAAK0gB,aAAe7d,EAAK6d,cAAgB,IAAI9Q,EAAAwZ,gBAAgB,IAC7DppB,KAAKmtD,mBAAqBtqD,EAAKgL,kBAC/B7N,KAAKygB,kBAAoB5d,EAAK4d,kBAC9BzgB,KAAK+wD,uCACHluD,EAAK4W,sCACPzZ,KAAKgxD,uCACHnuD,EAAK8W,sCACP3Z,KAAKuY,iBAAmB1V,EAAK0V,kBAAoB,IAAI3I,EAAAwZ,gBAAgB,IACrEppB,KAAK+M,SAAWlK,EAAKkK,SACrB/M,KAAKwgB,qBAAuB3d,EAAK2d,qBACjCxgB,KAAKmW,aAAetT,EAAKsT,aACzBnW,KAAKixD,UAAYpuD,EAAK+d,gBACtB5gB,KAAKkxD,mBAAqB,IAAI/xC,IAC9Bnf,KAAKmxD,uBAAyBtuD,EAAKsd,sBACnCngB,KAAKoxD,yBAA2BvuD,EAAKoe,wBACrCjhB,KAAKqxD,2BAA6BxuD,EAAKse,0BACvCnhB,KAAK6gB,oBAAsBhe,EAAKge,oBAChC7gB,KAAK8gB,oBAAsBje,EAAKie,oBAChC9gB,KAAK+gB,sBAAwBle,EAAKke,sBAClC/gB,KAAKghB,qBAAuBne,EAAKme,qBAEjChhB,KAAKwd,SAAW,IAAI5N,EAAAwZ,gBAAgB,IACpCppB,KAAKi+B,MAAQ,IAAIif,EAAA/8C,QAASH,KAAK+M,UAE/B/M,KAAKwkB,UAAY,IAAI4rC,EAAAjwD,QAAUH,KAAK+M,UACpC/M,KAAKsxD,cACLtxD,KAAK2hB,eAAiB,IAAIwuC,EAAAhwD,QAAwB,CAChDmU,UAAWzR,EAAKyR,UAChBqM,eAAgB9d,EAAK8d,eACrBgE,WAAY3kB,KAAK2kB,WAAWhgB,KAAK3E,MACjC6N,kBAAmBhL,EAAKgL,oBAE1B7N,KAAKuxD,iBAELvxD,KAAK8U,MAAQ9U,KAAK2hB,eAAe7M,MACjC9U,KAAK8kB,aAAe,IAAI6qC,EAAAxvD,QAAa,CACnC4M,SAAU/M,KAAK+M,SACfoJ,aAAcnW,KAAKmW,aACnBq7C,uBAAwB,IAAI/1B,IAOnB,IANqBz7B,KAAK2hB,eAAe6vC,0BAC3C/1B,MAE+B54B,EAAKwe,kCACpCoa,IAIPg2B,yBAA0BzxD,KAAK2hB,eAAe8vC,yBAAyB9sD,KACrE3E,KAAK2hB,kBAIT3hB,KAAK0xD,iBAAmB,IAAIrB,EAAAlwD,QAA0B,CACpD4M,SAAU/M,KAAK+M,SACf+X,aAAc9kB,KAAK8kB,aACnB6sC,mBAAqBC,GAAU5xD,KAAKi+B,MAAM4zB,mBAAmBD,GAC7DJ,uBAAwB,IAGf,IAFSxxD,KAAK2hB,eAAe6vC,4BACnBxxD,KAAK2hB,eAAemwC,2BAGvCC,mBAAoB/xD,KAAK+xD,mBAAmBptD,KAAK3E,MACjDgyD,yBAA0BhyD,KAAK2hB,eAAe8vC,yBAAyB9sD,KACrE3E,KAAK2hB,kBAIT3hB,KAAK2hB,eAAe7M,MAAM8B,WAAU,IAClC5W,KAAKqG,KAAK25C,EAAAiB,2BAA2BrtC,gBAEvC5T,KAAKiyD,kBAELjyD,KAAKkyD,kBACLlyD,KAAK2hB,eAAe7M,MAAM8B,WAAU,IAAM5W,KAAKkyD,oBAC/ClyD,KAAK0gB,aAAa9J,WAAU,KAC1B5W,KAAKuxD,iBACLvxD,KAAKkyD,qBAIPlyD,KAAKmyD,mCASPl4C,aACE,MAAMyB,EAAe1b,KAAK0gB,aAAanF,WACjCvd,EAAUgC,KAAKmtD,qBACfiF,EAAiBp4B,SAASh8B,EAAS,IACzC,MAAqB,YAAjB0d,GAA8Bq1B,OAAOC,MAAMohB,GACtC,EAEFA,EAGoB7xD,8BAAC8xD,GAC5B,MAAMC,QAAmCtyD,KAAK+wD,yCACxCwB,QAAgCvyD,KAAKgxD,uCACzCqB,GAEF,OAAOC,GAA8BC,EAaXhyD,6BAAC8xD,GAC3B,MAAMrsD,KAAEA,EAAM9H,SAAU8P,GAAShO,KAAKygB,oBAMhC+xC,QALwBxyD,KAAK0Z,wBAAwB24C,GAKxBlhD,EAAAshD,UAAUC,OAASvhD,EAAAshD,UAAUE,OAKhE,GAAI3sD,IAASmL,EAAAm8B,iBACX,OAAO,IAAIkiB,EAAArvD,QAAO,CAChB8vC,MAAOjqC,EACPwsD,SAAAA,IAQJ,MAAMx0D,EAAUg8B,SAASh6B,KAAKmtD,qBAAsB,IAC9CyF,EAAY5yD,KAAK0gB,aAAanF,WAE9Bs3C,EAAoB,CACxB7kD,KAAAA,EACAhQ,QAAAA,EAUA40D,UAAyB,YAAdA,EAA0B,EAAI54B,SAAS44B,EAAW,KAG/D,OAAOpD,EAAArvD,QAAO2yD,eAAe3hD,EAAAs8B,QAASolB,EAAmBL,GAS3DO,eAAerxC,GACb1hB,KAAK2hB,eAAeoxC,eAAerxC,GACnC1hB,KAAKqG,KAAM,GAAEqb,EAAOzc,gBAAiByc,GACrC1hB,KAAKgzD,8BAA8BtxC,EAAQzQ,EAAAgiD,mBAAmBC,OAQhEx4B,iBAAiBhc,GACf1e,KAAK2hB,eAAe+Y,iBAAiBhc,GAUTne,+BAAC8hB,EAAUxf,EAAO,IAC9ChD,EAAAM,QAAI8D,MACD,+CAA8Cg5B,KAAK2N,UAAUvoB,MAGhE,MAAM8wC,QAAsBnzD,KAAKsvB,yBAC/BjN,EACAxf,EAAKgkB,QAIP,OAAO,IAAI9lB,SAAQ,CAACC,EAASC,KAC3BjB,KAAK2hB,eAAe2+B,KACjB,GAAE6S,EAAcluD,eAChBmuD,IACC,OAAQA,EAAetkD,QACrB,KAAKmC,EAAAsQ,qBAAqB4H,UACxB,OAAOnoB,EAAQoyD,EAAe3kD,MAChC,KAAKwC,EAAAsQ,qBAAqBirB,SACxB,OAAOvrC,GACL,EAAA2uD,EAAAzvD,SACEiQ,EAAA6rB,UAAUlvB,SAASwzC,oBACjB,+DAIR,KAAKtvC,EAAAsQ,qBAAqBE,OACxB,OAAOxgB,GACL,EAAA2uD,EAAAzvD,SACEiQ,EAAA6rB,UAAUja,IAAIqxC,SAASD,EAAejyD,IAAI+C,WAGhD,QACE,OAAOjD,GACL,EAAA2uD,EAAAzvD,SACEiQ,EAAA6rB,UAAUja,IAAIqxC,SACX,2CAA0Cp2B,KAAK2N,UAC9CwoB,EAAe/wC,sBAoBL9hB,+BAAC8hB,EAAUwE,EAAQysC,GAC/C,GACEA,IAAoB9yD,YACnBmwD,EAAuBziD,SAASolD,GAEjC,MAAM,IAAI5qD,MACP,0DAAyD4qD,KAK9D,MAAMzhB,EAAqBye,EAAQxe,kBAAkBzvB,GAC/CkxC,QAA6BvzD,KAAK0Z,0BAExC42C,EAAQkD,iBAAiB3hB,EAAoB0hB,GAQ7C,IAAI7xC,EAAS1hB,KAAK2hB,eAAe8xC,eAAe,CAC9CpxC,SAAUwvB,EACVhrB,OAAAA,IAGF,GAAe,aAAXA,GAEF,GAAIgrB,EAAmB1c,OAASn1B,KAAKgoB,qBACnC,MAAM5X,EAAA6rB,UAAUja,IAAIqxC,SAAS,CAC3BnvD,QAAU,6DACV1E,KAAM,CACJqnB,OAAAA,EACAwrC,YAAaxgB,EAAmB1c,KAChC9N,gBAAiBrnB,KAAKgoB,4BAIvB,CAIL,WADiChoB,KAAKwgB,qBAAqBqG,IACnC3Y,SAAS2jC,EAAmB1c,MAClD,MAAM/kB,EAAA6rB,UAAUlvB,SAASguB,aAAa,CAAEv7B,KAAM,CAAEqnB,OAAAA,KAIpD,MAAM7gB,KAAEA,EAAF0tD,gBAAQA,SAA0B1zD,KAAK2zD,0BAC3CtxC,GAEFX,EAAO1b,KAAOstD,GAAmBttD,EAGjC0b,EAAOW,SAAS7jB,MAAQkjB,EAAOW,SAAS7jB,OACpC,EAAAsB,EAAA2xC,cAAa/vB,EAAOW,SAAS7jB,OAC7B,MAEJwB,KAAK+yD,eAAerxC,GACpB1hB,KAAKqG,KAAK,kBAAmBqb,GAE7B,IACEA,QAAe1hB,KAAK4zD,iBAAiBlyC,EAAQgyC,GAC7C,MAAOpzD,GAQP,MAPAT,EAAAM,QAAI6O,KAAK1O,GACTohB,EAAS1hB,KAAK2hB,eAAeC,eAAeF,EAAOzc,IACnDyc,EAAOmyC,iBAAkB,EACzB7zD,KAAK2hB,eAAeoN,kBAClBrN,EACA,qCAEIphB,EAUR,OAPAohB,EAAOmyC,iBAAkB,EAEzB7zD,KAAK2hB,eAAeoN,kBAClBrN,EACA,qCAGKA,EAUanhB,uBAACmhB,EAAQgyC,GAC7B,MAAMH,EACJ7xC,EAAOW,SAASrc,OAASiL,EAAA6iD,2BAA2BC,cAC7C/zD,KAAK0Z,2BAEZk4B,SAAUoiB,EACV/I,aAAcgJ,EACd/I,qBAAsBgJ,SACdl0D,KAAKm0D,mBAAmBzyC,EAAQ6xC,IAExCa,SAAUC,EADN5wC,gBAEJA,SACQzjB,KAAKs0D,oBAAoB5yC,EAAQgyC,GAQ3C,GALAhyC,EAAS1hB,KAAK2hB,eAAeC,eAAeF,EAAOzc,IAC/Cwe,IACF/B,EAAO+B,gBAAkBA,GAGvB8vC,EAAsB,CACxB,MAAMgB,iBAAEA,GAAqBv0D,KAAKuY,iBAAiBgD,WAC7Ci5C,EAA8Bx0D,KAAKy0D,oBAEvCF,GACAr0D,QAAQs0D,KACP7D,EAAuBziD,SAASwT,EAAO1b,OAExC0b,EAAOgzC,aAAe5E,EAAA6E,oBACtBjzC,EAAOW,SAAS4oC,cAAe,EAAA8E,EAAA6E,iBAC7BJ,EAA4BK,YAE9BnzC,EAAOW,SAAS6oC,sBAAuB,EAAA6E,EAAA6E,iBACrCJ,EAA4BM,eAG9BpzC,EAAOW,SAASuvB,UACflwB,EAAOW,SAAS4oC,cAChBvpC,EAAOW,SAAS6oC,sBAad+I,GACCC,IACCxyC,EAAOW,SAAS4oC,eAChBvpC,EAAOW,SAAS6oC,sBACD,aAAlBxpC,EAAOmF,OAEPnF,EAAOgzC,aAAe5E,EAAAiF,oBAAoBC,OAE1CtzC,EAAOgzC,aADEH,EACazE,EAAAmF,gBAAgBC,eAEhBpF,EAAA6E,oBAGpBV,IAAwBvyC,EAAOW,SAAS4oC,eAG1CvpC,EAAOW,SAAS4oC,aAAegJ,GAI/BC,IACCxyC,EAAOW,SAAS6oC,uBAIjBxpC,EAAOW,SAAS6oC,qBAAuBgJ,GAGrCF,IAAoBtyC,EAAOW,SAAS4oC,eAItCvpC,EAAOW,SAAS4oC,aAAe+I,GAI/BtyC,EAAOW,SAAS4oC,eACfvpC,EAAOW,SAAS6oC,uBAMjBxpC,EAAOW,SAAS6oC,qBAAuBxpC,EAAOW,SAAS4oC,gBApDzDvpC,EAAOW,SAAS4oC,aAAevpC,EAAOW,SAASuvB,SAC/ClwB,EAAOW,SAAS6oC,qBAAuBxpC,EAAOW,SAASuvB,SACnD2iB,GAAsC,aAAlB7yC,EAAOmF,OAC7BnF,EAAOgzC,aAAe5E,EAAAmF,gBAAgBC,eAEtCxzC,EAAOgzC,aAAe5E,EAAA6E,4BAqDnBjzC,EAAOW,SAASuvB,qBAKhBlwB,EAAOW,SAAS6oC,4BAChBxpC,EAAOW,SAAS4oC,aA2BzB,OAnBE+I,GACCtyC,EAAOW,SAASuvB,UAChBlwB,EAAOW,SAAS6oC,sBAChBxpC,EAAOW,SAAS4oC,eAEjBvpC,EAAOW,SAASuvB,SAAWoiB,GAGzBK,IAAoB3yC,EAAOW,SAASsvB,MACtCjwB,EAAOW,SAASsvB,IAAM0iB,EACtB3yC,EAAOyzC,oBAAsBd,GAE/B3yC,EAAO0zC,oBAAsB,CAC3BC,aAAc3zC,EAAOgzC,aACrB/iB,IAAKjwB,EAAOW,SAASsvB,IACrBC,SAAUlwB,EAAOW,SAASuvB,SAC1BqZ,aAAcvpC,EAAOW,SAAS4oC,aAC9BC,qBAAsBxpC,EAAOW,SAAS6oC,sBAEjCxpC,EAUenhB,yBAACmhB,EAAQ6xC,GAC/B,IACIA,GAAwB7xC,EAAOW,SAASuvB,UACzC2hB,GACC7xC,EAAOW,SAAS4oC,cAChBvpC,EAAOW,SAAS6oC,qBAElB,MAAO,GAGT,IACE,MAAMoK,gBACJA,EADIC,gBAEJA,SACQv1D,KAAKqxD,6BACf,GACEkC,GACAgC,IAAoBzF,EAAA0F,mBAAmBC,WACvC,CACA,MACEC,QAAQC,8BAAEA,EAAFC,sBAAiCA,GAA0B,IACjEN,EAEJ,GAAIK,GAAiCC,EACnC,MAAO,CACL3K,cAAc,EAAA8E,EAAA6E,iBAAgBgB,GAC9B1K,sBAAsB,EAAA6E,EAAA6E,iBACpBe,QAID,CAAA,GAAIJ,IAAoBzF,EAAA0F,mBAAmBzB,OAGhD,MAAO,CACLniB,UAAU,EAAAme,EAAA6E,iBAAgBU,EAAgBI,SAEvC,GAAIH,IAAoBzF,EAAA0F,mBAAmBK,aAGhD,MAAO,CACLjkB,UAAU,EAAAme,EAAA6E,iBAAgBU,EAAgB1jB,YAG9C,MAAOpwC,GACPuN,QAAQzO,MAAMkB,GAGhB,MAAMowC,QAAiB5xC,KAAKi+B,MAAM2T,WAElC,MAAO,CAAEA,SAAUA,IAAY,EAAA9xC,EAAA2xC,cAAaG,EAASzU,SAAS,MAUvC58B,0BAACmhB,EAAQgyC,GAChC,MAAM11D,EAAUgC,KAAKmtD,qBACf2I,EAAyB3kD,EAAA4kD,iCAAiC/3D,GAC1Dg4D,GAAY,EAAAl2D,EAAAm2D,cAAaj4D,GAE/B,GAAI0jB,EAAOW,SAASsvB,IAClB,MAAO,GACF,GACLjwB,EAAOW,SAASqvB,IAChBhwB,EAAO1b,OAASiL,EAAAkR,kBAAkByxB,aACpB,WAAdoiB,EACA,CAEA,GAAIt0C,EAAOW,SAAS7iB,KAAM,CACxB,MAAM2B,EAAM,IAAIuH,MACd,mEAOF,MAJAvH,EAAI+0D,SAAWrG,EAAAsG,kCAGfh1D,EAAIuyD,gBAAkBA,EAChBvyD,EAIR,MAAO,CAAEizD,SAAUtE,EAAAsG,WAAWC,QAGhC,MAAMC,cACJA,EADIC,gBAEJA,EAFI9yC,gBAGJA,SACQzjB,KAAKwkB,UAAUgyC,gBAAgB90C,GAQzC,MAAO,CAAE0yC,SALQp0D,KAAKwkB,UAAUiyC,cAC9B,EAAA32D,EAAA2xC,cAAa8kB,GACbD,EACAR,GAEiBryC,gBAAAA,GAmBrBizC,qBACEC,EACA74B,EAAoB,GACpB84B,EAAqB,IAErB,MAAMv0C,SAAEA,GAAas0C,EACfE,EAAoB,GACpBC,EAAe,GACW,IAAAC,EAA5Bj5B,EAAkBs2B,WACpB0C,EAAanlB,IAAb,QAAAolB,EAAmBj5B,MAAAA,OAAnB,EAAmBA,EAAmB6T,WAAtC,IAAAolB,EAAAA,EAA6CjH,EAAAsG,WAAWC,QA6C1D,OA1CIv4B,EAAkBk5B,oBACpBF,EAAaE,kBAAoBl5B,EAAkBk5B,mBAGjDl5B,EAAkBm5B,eACpBH,EAAaG,aAAen5B,EAAkBm5B,eAG5C,EAAAjH,EAAAkH,sBAAqBP,IACvBE,EAAkB5L,aAAe5oC,EAAS4oC,aAC1C4L,EAAkB3L,qBAAuB7oC,EAAS6oC,qBAClD4L,EAAa7L,cACXntB,MAAAA,OAAA,EAAAA,EAAmBmtB,gBACnB,EAAAnrD,EAAAkrD,UACE,EAAAlrD,EAAAq3D,uBACE,EAAAr3D,EAAAs3D,SAAQ/0C,EAAS4oC,cACjB2L,EACA,KAGNE,EAAa5L,sBACXptB,MAAAA,OAAA,EAAAA,EAAmBotB,wBACnB,EAAAprD,EAAAkrD,UACE,EAAAlrD,EAAAq3D,uBACE,EAAAr3D,EAAAs3D,SAAQ/0C,EAAS6oC,sBACjB0L,EACA,OAINC,EAAkBjlB,SAAWvvB,EAASuvB,SACtCklB,EAAallB,UACX9T,MAAAA,OAAA,EAAAA,EAAmB8T,YACnB,EAAA9xC,EAAAkrD,UACE,EAAAlrD,EAAAq3D,uBACE,EAAAr3D,EAAAs3D,SAAQ/0C,EAASuvB,UACjBglB,EACA,MAKD,CAAEC,kBAAAA,EAAmBC,aAAAA,GAeDv2D,8BAC3Bs9B,EACAC,GACAu5B,iBAAEA,GAAqB,IAEvB,MAAMV,EAAiB32D,KAAK2hB,eAAeC,eAAeic,IACpDxb,SAAEA,GAAas0C,GACfxhC,KAAEA,EAAFqa,MAAQA,GAAUntB,GAElBw0C,kBAAEA,EAAFC,aAAqBA,GAAiB92D,KAAK02D,qBAC/CC,EAD0C7zD,EAAAA,EAAA,GAGrCg7B,GAHqC,GAAA,CAOxCs2B,SAAUt2B,EAAkBs2B,UAAYtE,EAAAsG,WAAWC,UAIjDiB,EAAYt3D,KAAK2hB,eAAe8xC,eAAe,CACnDpxC,SAAQvf,EAAA,CACNqyB,KAAAA,EACAuc,GAAIvc,EACJqa,MAAAA,EACAhxC,MAAO,OACJs4D,GAELD,kBAAAA,EACAhD,iBAAiB,EACjB/kD,OAAQmC,EAAAsQ,qBAAqBs0B,SAC7B7vC,KAAMiL,EAAAkR,kBAAkB0tB,SAS1B,OANIwnB,IACFC,EAAUD,iBAAmBA,GAG/Br3D,KAAK+yD,eAAeuE,SACdt3D,KAAK+xD,mBAAmBuF,EAAUryD,IACjCqyD,EAgBqB/2D,+BAC5Bs9B,EACAC,GACAu5B,iBAAEA,GAAqB,IAEvB,MAAMV,EAAiB32D,KAAK2hB,eAAeC,eAAeic,IACpDxb,SAAEA,GAAas0C,GAEfE,kBAAEA,EAAFC,aAAqBA,GAAiB92D,KAAK02D,qBAC/CC,EACA74B,GAGIw5B,EAAYt3D,KAAK2hB,eAAe8xC,eAAe,CACnDpxC,SAAQvf,EAAAA,EAAA,GACHuf,GACAy0C,GAELD,kBAAAA,EACAhD,iBAAiB,EACjB/kD,OAAQmC,EAAAsQ,qBAAqBs0B,SAC7B7vC,KAAMiL,EAAAkR,kBAAkB2tB,QAS1B,OANIunB,IACFC,EAAUD,iBAAmBA,GAG/Br3D,KAAK+yD,eAAeuE,SACdt3D,KAAK+xD,mBAAmBuF,EAAUryD,IACjCqyD,EAQc/2D,wBAACmhB,GACtB1hB,KAAK2hB,eAAeoN,kBAClBrN,EACA,oCAS6BnhB,kCAACmhB,GAChC1hB,KAAK2hB,eAAeoN,kBAClBrN,EACA,2CAEI1hB,KAAK+xD,mBAAmBrwC,EAAOzc,IAYf1E,yBAAC+gB,GAMvB,GAAIthB,KAAKkxD,mBAAmBqG,IAAIj2C,GAC9B,OAGF,IAAIyiB,EADJ/jC,KAAKkxD,mBAAmB9b,IAAI9zB,GAE5B,IAEEthB,KAAK2hB,eAAe61C,oBAAoBl2C,GAExC,MAAMI,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAE5C+wC,EAAc3wC,EAAOW,SAAS8S,KAEpC,IAAIsiC,iBAAEA,GAAqB/1C,EAC3B+1C,EAAmB1mB,OAAO0mB,GAC1B1zB,QAAkB/jC,KAAK8kB,aAAaD,aAAawtC,GAIjD,MAAM7iB,EAAQ9tB,EAAOm1C,kBACjBn1C,EAAOW,SAASmtB,MAChBzL,EAAUC,UACR0zB,EACiB,IAArBD,EAAyBA,EAAmBA,GAAoBjoB,EAElE9tB,EAAOW,SAASmtB,OAAQ,EAAA1vC,EAAA2xC,cAAaimB,EAAcv6B,SAAS,KAE5Dzb,EAAOkiB,aAAeG,EAAUH,aAC5B6zB,IACF/1C,EAAOkiB,aAAa6zB,iBAAmBA,GAEzCz3D,KAAK2hB,eAAeoN,kBAClBrN,EACA,mCAGF,MAAMkwC,QAAc5xD,KAAK4gB,gBAAgBU,SACnCthB,KAAK2xD,mBAAmBrwC,EAAMswC,GACpC5xD,KAAKgzD,8BAA8BtxC,EAAQzQ,EAAAgiD,mBAAmBpd,UAE9D9R,EAAUtP,cACV,MAAOtzB,GAEP,IACEnB,KAAK23D,iBAAiBr2C,EAAMngB,GAC5B,MAAOy2D,GACP/3D,EAAAM,QAAIG,MAAMs3D,GAOZ,MAJI7zB,GACFA,EAAUtP,cAGNtzB,EAhDR,QAkDEnB,KAAKkxD,mBAAmBnjC,OAAOzM,IAIG/gB,uCAACs3D,EAAiB,IACtD,GAA8B,IAA1BA,EAAej3D,OACjB,MAAO,GAGT,MAAMk3D,EAAYD,EAAe,GAC3BE,QAAe/3D,KAAKg4D,uBAAuBF,EAAU3iC,MACrD8iC,EAAmBxI,EAAAyI,mBAAmBC,WAAWL,EAAW,CAChEC,OAAAA,IAEIK,GAA2B,EAAA9nD,EAAA4wC,aAAY+W,EAAiB19B,aAE9D,GAAIv6B,KAAKkxD,mBAAmBqG,IAAIa,GAC9B,MAAO,GAGT,IAAIC,EAASt0B,EADb/jC,KAAKkxD,mBAAmB9b,IAAIgjB,GAE5B,IAEE,MAAM/F,EAAcyF,EAAU3iC,KAC9B4O,QAAkB/jC,KAAK8kB,aAAaD,aAAawtC,GACjD,MAAM7iB,EAAQzL,EAAUC,UAExBq0B,QAAgBt3D,QAAQ61B,IACtBihC,EAAen2D,KAAK2gB,IAClBA,EAASmtB,OAAQ,EAAA1vC,EAAA2xC,cAAajC,EAAMrS,SAAS,KACtCn9B,KAAKs4D,wBAAwBj2C,OAGxC,MAAOlhB,GAIP,MAHAtB,EAAAM,QAAIG,MAAMa,GAGJA,EAhBR,QAkBM4iC,GACFA,EAAUtP,cAEZz0B,KAAKkxD,mBAAmBnjC,OAAOqqC,GAEjC,OAAOC,EAGoB93D,8BAACg4D,GAC5B,MAAM1mB,EAAqBye,EAAQxe,kBAAkBymB,GAE/Cv6D,EAAUgC,KAAKia,aACfjU,GAAO,EAAAgqD,EAAAkH,sBAAqB,CAAE70C,SAAUwvB,IAC1C5gC,EAAA6iD,2BAA2B2B,WAC3BxkD,EAAA6iD,2BAA2BC,OACzB1xC,EAAQvf,EAAAA,EAAA,GACT+uC,GADS,GAAA,CAEZ7rC,KAAAA,EACAouD,SAAUviB,EAAmBF,IAC7B3zC,SAAS,EAAA8B,EAAA2xC,eAAa,EAAAhgC,EAAA+mD,cAAax6D,MAG/Bq0D,EAAchwC,EAAS8S,KACvB4iC,QAAe/3D,KAAKg4D,uBAAuB3F,GAC3CoG,EAAgBhJ,EAAAyI,mBAAmBC,WAAW91C,EAAU,CAAE01C,OAAAA,IAC1DW,QAAoB14D,KAAKixD,UAAUwH,EAAepG,GAGxD,OADc,EAAA/hD,EAAA4wC,aAAYwX,EAAYn+B,aAUnBh6B,sBAAC+gB,GACpB,MAAMI,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAE5CtjB,EAAUgC,KAAKia,aACfjU,GAAO,EAAAgqD,EAAAkH,sBAAqBx1C,GAC9BzQ,EAAA6iD,2BAA2B2B,WAC3BxkD,EAAA6iD,2BAA2BC,OACzB1xC,EAAQvf,EAAAA,EAAA,GACT4e,EAAOW,UADE,GAAA,CAEZrc,KAAAA,EACAhI,QAAAA,EACAo2D,SAAU1yC,EAAOW,SAASsvB,MAGtB0gB,EAAchwC,EAAS8S,KACvB4iC,QAAe/3D,KAAKg4D,uBAAuB31C,EAAS8S,MACpDsjC,EAAgBhJ,EAAAyI,mBAAmBC,WAAW91C,EAAU,CAAE01C,OAAAA,IAC1DW,QAAoB14D,KAAKixD,UAAUwH,EAAepG,GAIxD3wC,EAAOi3C,GAAI,EAAAroD,EAAA4wC,aAAYwX,EAAYC,GACnCj3C,EAAOk3C,GAAI,EAAAtoD,EAAA4wC,aAAYwX,EAAYE,GACnCl3C,EAAOyzB,GAAI,EAAA7kC,EAAA4wC,aAAYwX,EAAYvjB,GAEnCn1C,KAAK2hB,eAAeoN,kBAClBrN,EACA,oDAIF1hB,KAAK2hB,eAAek3C,kBAAkBn3C,EAAOzc,IAE7C,OADc,EAAAqL,EAAA4wC,aAAYwX,EAAYn+B,aAWhBh6B,yBAAC+gB,EAAMswC,GAC7B,MAAMlwC,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAElD,GADAI,EAAOkwC,MAAQA,EACXlwC,EAAO1b,OAASiL,EAAAkR,kBAAkByuC,KAAM,CAC1C,MAAMkI,QAAqB94D,KAAKi+B,MAAMzI,WAAW9T,EAAOW,SAAS8S,MACjEzT,EAAOo3C,aAAeA,EAAa37B,SAAS,IAM9C,IAAI47B,EAJJ/4D,KAAK2hB,eAAeoN,kBAClBrN,EACA,mCAGF,IACEq3C,QAAe/4D,KAAKi+B,MAAM4zB,mBAAmBD,GAC7C,MAAOtxD,GACP,IAAIA,EAAM4D,QAAQtC,cAAcsM,SAAS,qBAIvC,MAAM5N,EAHNy4D,GAAS,EAAAzoD,EAAAs0C,SAAO,EAAAt0C,EAAA0oD,WAAS,EAAAl5D,EAAA2xC,cAAamgB,GAAQ,QAAQz0B,SAAS,OAC/D47B,GAAS,EAAAj5D,EAAA2xC,cAAasnB,GAK1B/4D,KAAKi5D,UAAU33C,EAAMy3C,GAErB/4D,KAAK2hB,eAAeu3C,qBAAqB53C,GAEzCthB,KAAKgzD,8BAA8BtxC,EAAQzQ,EAAAgiD,mBAAmB9pC,WAaxC5oB,yBAAC+gB,EAAMY,EAAWi3C,EAAeC,GAGvD,MAAM13C,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAElD,GAAKI,EAIL,IACE,MAAM23C,EAAU/I,EAAQgJ,0BAA0Bp3C,EAAUm3C,SAE5D33C,EAAOQ,UAAPpf,EAAAA,EAAA,GACKof,GADL,GAAA,CAEEm3C,QAAAA,IAGEF,IACFz3C,EAAOy3C,cAAgBA,GAErBC,IACF13C,EAAO03C,eAAiBA,GAG1Bp5D,KAAK2hB,eAAe43C,qBAAqBj4C,GACzCthB,KAAKw5D,4BAA4Bl4C,GAEjC,MAAMotB,cAAEA,GAAkBhtB,EACpB+3C,EAAgB,CAAEC,SAAUL,GAwBlC,GAtBI3qB,IACF+qB,EAAcE,gBAAkB35D,KAAK45D,8BACnClrB,IAIqB,QAArBxsB,EAAUpT,SACZ2qD,EAAc3qD,OAASgiD,GAIzB9wD,KAAKgzD,8BACHtxC,EACAzQ,EAAAgiD,mBAAmB4G,UACnBJ,GAGFz5D,KAAK2hB,eAAeoN,kBAClBrN,EACA,mDAGEA,EAAO1b,OAASiL,EAAAkR,kBAAkByuC,KAAM,CAC1C,MAAMkJ,QAAsB95D,KAAKi+B,MAAMzI,WAAW9T,EAAOW,SAAS8S,MAC5D4kC,EAAe/5D,KAAK2hB,eAAeC,eAAeN,GAElD04C,EAAiBD,EAAaE,aAChCj6D,KAAK2hB,eAAeC,eAAem4C,EAAaE,cAChD,KAEJF,EAAaD,cAAgBA,EAAc38B,SAAS,IAEpDn9B,KAAK2hB,eAAeoN,kBAClBgrC,EACA,uDAGF/5D,KAAKk6D,mBAAmBH,EAAcC,IAExC,MAAO74D,GACPtB,EAAAM,QAAIG,MAAMa,IAIkBZ,iCAACmhB,EAAQQ,EAAWi3C,GAIlD,SAFMn5D,KAAK2hB,eAAew4C,uBAAuBz4C,IAE5CA,EACH,OAGF,MAAMJ,EAAOI,EAAOzc,GAEpB,IACE,MAAMo0D,EAAU/I,EAAQgJ,0BAA0Bp3C,EAAUm3C,SAE5D33C,EAAOQ,UAAPpf,EAAAA,EAAA,GACKof,GADL,GAAA,CAEEm3C,QAAAA,IAGEF,IACFz3C,EAAOy3C,cAAgBA,GAGzBn5D,KAAK2hB,eAAe43C,qBAAqBj4C,GACzCthB,KAAKw5D,4BAA4Bl4C,GAEjC,MAAMotB,cAAEA,GAAkBhtB,EACpB+3C,EAAgB,CAAEC,SAAUL,GAwBlC,GAtBI3qB,IACF+qB,EAAcE,gBAAkB35D,KAAK45D,8BACnClrB,IAIqB,QAArBxsB,EAAUpT,SACZ2qD,EAAc3qD,OAASgiD,GAIzB9wD,KAAKgzD,8BACHtxC,EACAzQ,EAAAgiD,mBAAmB4G,UACnBJ,GAGFz5D,KAAK2hB,eAAeoN,kBAClBrN,EACA,mDAGEA,EAAO1b,OAASiL,EAAAkR,kBAAkByuC,KAAM,CAC1C,MAAMkJ,QAAsB95D,KAAKi+B,MAAMzI,WAAW9T,EAAOW,SAAS8S,MAC5D4kC,EAAe/5D,KAAK2hB,eAAeC,eAAeN,GAElD04C,EAAiBD,EAAaE,aAChCj6D,KAAK2hB,eAAeC,eAAem4C,EAAaE,cAChD,KAEJF,EAAaD,cAAgBA,EAAc38B,SAAS,IAEpDn9B,KAAK2hB,eAAeoN,kBAClBgrC,EACA,uDAGF/5D,KAAKk6D,mBAAmBH,EAAcC,IAExC,MAAO74D,GACPtB,EAAAM,QAAIG,MAAMa,IAUSZ,wBAAC+gB,GACtB,MAAMI,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAClDthB,KAAK2hB,eAAey4C,oBAAoB94C,GACxCthB,KAAKgzD,8BAA8BtxC,EAAQzQ,EAAAgiD,mBAAmBzmB,UAShEysB,UAAU33C,EAAMy3C,GAEd,MAAMr3C,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAClDI,EAAOjT,KAAOsqD,EACd/4D,KAAK2hB,eAAeoN,kBAAkBrN,EAAQ,0BAWZnhB,qCAAC85D,EAAej3C,GAClD,MAAM1B,EAAS1hB,KAAK2hB,eAAeC,eAAey4C,IAC5C/2C,WACJA,EADIgiC,oBAEJA,SACQtlD,KAAKs6D,8BAA8B54C,GAC7C1hB,KAAKu6D,gCACH74C,EACA0B,EACAE,EACAgiC,GAQJgM,cAEEtxD,KAAKub,SAAW,IAAMvb,KAAKwd,SAASjC,WAGpCvb,KAAK2kB,WAAa,IAAM3kB,KAAK0gB,aAAanF,WAG1Cvb,KAAKgoB,mBAAqB,IACxBhoB,KAAKuY,iBAAiBgD,WAAW8L,gBAGnCrnB,KAAKw6D,qBAAuB,IAC1B57D,OAAO+B,KAAKX,KAAK2hB,eAAe84C,uBAAuB75D,OAMzDZ,KAAK06D,kBAAqB1qB,GACxBhwC,KAAK2hB,eAAe6vC,uBAAuBxhB,GAASpvC,OAOtDZ,KAAKipB,gBAAmBpmB,GAAS7C,KAAK2hB,eAAesH,gBAAgBpmB,GAGrE7C,KAAKy0D,kBAAoB,IACvBz0D,KAAKuY,iBAAiBgD,WAAWo/C,eAICp6D,+CAE9BP,KAAKmW,aAAaykD,uBAElB56D,KAAK0xD,iBAAiBmJ,mBAS9BtJ,iBACEvxD,KAAK2hB,eACFsH,gBAAgB,CACfC,eAAgB,CACdpa,OAAQmC,EAAAsQ,qBAAqBkrB,WAC7BonB,iBAAiB,KAGpB/0D,SAAS44B,IACR13B,KAAK4zD,iBAAiBl8B,GACnBojC,MAAMp5C,IACLA,EAAOmyC,iBAAkB,EACzB7zD,KAAK2hB,eAAeoN,kBAClBrN,EACA,kDAGHojB,OAAOxkC,IACN,MAAMohB,EAAS1hB,KAAK2hB,eAAeC,eAAe8V,EAAGzyB,IACrDyc,EAAOmyC,iBAAkB,EACzB7zD,KAAK2hB,eAAeoN,kBAClBrN,EACA,+CAEF1hB,KAAK23D,iBAAiBj2C,EAAOzc,GAAI3E,SAIzCN,KAAK2hB,eACFsH,gBAAgB,CACfC,eAAgB,CACdpa,OAAQmC,EAAAsQ,qBAAqBs0B,YAGhC/2C,SAAS4iB,IACR,MAAMq5C,EAAc,IAAIryD,MACtB,+EAEF1I,KAAK23D,iBAAiBj2C,EAAOzc,GAAI81D,MAQvC9I,kBACEjyD,KAAK2hB,eAAelJ,GAClB,mBACAzY,KAAKqG,KAAK1B,KAAK3E,KAAM,qBAEvBA,KAAKg7D,6BACLh7D,KAAK0xD,iBAAiBj5C,GAAG,cAAeiJ,IACtC1hB,KAAK2hB,eAAeoN,kBAClBrN,EACA,wDAGJ1hB,KAAK0xD,iBAAiBj5C,GAAG,aAAa,CAAC6I,EAAMhhB,KAC3CN,KAAK23D,iBAAiBr2C,EAAMhhB,MAE9BN,KAAK0xD,iBAAiBj5C,GACpB,gBACA,CAAC6I,EAAM25C,EAAoB9B,EAAeC,IACxCp5D,KAAKk7D,mBACH55C,EACA25C,EACA9B,EACAC,KAGNp5D,KAAK0xD,iBAAiBj5C,GAAG,cAAe6I,IACtCthB,KAAKm7D,iBAAiB75C,MAExBthB,KAAK0xD,iBAAiBj5C,GAAG,mBAAmB,CAACiJ,EAAQ05C,KAC9C15C,EAAO25C,wBACV35C,EAAO25C,sBAAwBD,EAC/Bp7D,KAAK2hB,eAAeoN,kBAClBrN,EACA,8DAIN1hB,KAAK0xD,iBAAiBj5C,GAAG,YAAaiJ,IAC9B,eAAgBA,IACpBA,EAAOyqB,WAAa,GAEtBzqB,EAAOyqB,YAAc,EACrBnsC,KAAK2hB,eAAeoN,kBAClBrN,EACA,sDA2ByBnhB,gCAAC8hB,GAC9B,MAAM7iB,KAAEA,EAAFkyC,GAAQA,GAAOrvB,EACrB,IAAIrU,EACJ,IACEA,EAAOxO,GAAQ+wD,EAAa+K,iBAAiB,CAAE97D,KAAAA,IAAQwO,KACvD,MAAO1N,GACPT,EAAAM,QAAI8D,MAAM,oCAAqC3D,EAAOd,GAGxD,MAAM+7D,EAAkB,CACtBtqD,EAAAkR,kBAAkBq5C,qBAClBvqD,EAAAkR,kBAAkBs5C,sBAClBxqD,EAAAkR,kBAAkBC,4BAClBtgB,MAAM0mC,IAAe,EAAA0nB,EAAAptC,wBAAuB0lB,EAAYx6B,KAE1D,IAAIvN,EAOAi7D,EAEJ,GARIl8D,GAAQ+7D,EACV96D,EAAS86D,EACA/7D,IAASkyC,IAClBjxC,EAASwQ,EAAAkR,kBAAkBw5C,kBAKxBl7D,EAAQ,CACX,MACEi7D,aAAcE,EADVC,kBAEJA,SACQ,EAAA5L,EAAA6L,uBAAsB97D,KAAKi+B,MAAOyT,GAE5CgqB,EAAeE,EACfn7D,EAASo7D,EACL5qD,EAAAkR,kBAAkB45C,qBAClB9qD,EAAAkR,kBAAkByxB,YAGxB,MAAO,CAAE5tC,KAAMvF,EAAQizD,gBAAiBgI,GAS1ClC,4BAA4Bl4C,GAE1B,MAAMI,EAAS1hB,KAAK2hB,eAAeC,eAAeN,IAC5CkuB,MAAEA,EAAFra,KAASA,GAASzT,EAAOW,SACzB25C,EAAeh8D,KAAK2hB,eAAesH,gBAAgB,CACvDC,eAAgB,CAAEsmB,MAAAA,EAAOra,KAAAA,KAEtB6mC,EAAap7D,QAIlBo7D,EAAal9D,SAASm9D,IAChBA,EAAYh3D,KAAOqc,IAGvB26C,EAAYC,WAAax6C,EAAOjT,KAChCzO,KAAK2hB,eAAeoN,kBAClBrN,EACA,qGAEF1hB,KAAKm7D,iBAAiBc,EAAYh3D,QAItC+1D,6BACE,IAAImB,GAAqB,EACzB,MAAMC,EAAqBp8D,KAAKkpD,eAAevkD,KAAK3E,OAC9CmW,aAAEA,EAAFwL,eAAgBA,GAAmB3hB,KAKzC,SAASq8D,IACP,MAAMC,EAAa36C,EAAe6vC,0BAC7B2K,GAAsBG,EAAW17D,OAAS,GAC7CuV,EAAasC,GAAG,SAAU2jD,GAC1BD,GAAqB,GACZA,IAAuBG,EAAW17D,SAC3CuV,EAAazI,eAAe,SAAU0uD,GACtCD,GAAqB,GAVzBx6C,EAAelJ,GAAG,mBAAoB4jD,GACtCA,IAckB97D,qBAAC+pD,GACnB,UACQtqD,KAAK0xD,iBAAiBmJ,mBAC5B,MAAO15D,GACPtB,EAAAM,QAAIG,MAAMa,GAEZ,UACQnB,KAAK0xD,iBAAiB6K,mBAAmBjS,GAC/C,MAAOnpD,GACPtB,EAAAM,QAAIG,MAAMa,IAOd+wD,kBACE,MAAMsK,EAAgBx8D,KAAK2hB,eAAe84C,sBACpCgC,EAAuBz8D,KAAK2hB,eAAesH,gBAAgB,CAC/DyzC,MA//C4B,MAigD9B18D,KAAKwd,SAAS0tB,YAAY,CAAEsxB,cAAAA,EAAeC,qBAAAA,IAG7CvC,mBAAmBx4C,EAAQs4C,GACzB,GAAIh6D,KAAKoxD,4BAA8B1vC,EAAOi7C,aAC5C,GAAgC,QAA5Bj7C,EAAOQ,UAAUpT,OACnB9O,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,cACPkiC,oBAAmBxiD,EAAA,GAAO4e,EAAOi7C,cACjCt5C,SAAU,cAEP,CACL,MAAMu5C,GAAiB,EAAA1rD,EAAA2rD,kCACrBn7C,EAAOo7C,uBACPp7C,EACAA,EAAOq7C,wBACPr7C,EAAOW,SAAS8S,KAChBzT,EAAOs7C,yBACPhD,EACAt4C,EAAO1jB,SAGHi/D,EAAwBL,EACzB,GAAE,IAAIphB,EAAAr7C,QAAUy8D,EAAgB,IAC9BM,IAAIx7C,EAAOi7C,aAAaQ,gBAAiB,IACzCC,MAAM,KACNtY,MAAM,MACT,KAEEuY,EACJ37C,EAAOQ,UAAUm3C,SAAW33C,EAAOi7C,aAAaW,cAC3C,GAAE,IAAI9hB,EAAAr7C,QAAUuhB,EAAOQ,UAAUm3C,QAAS,IACxC6D,IAAIx7C,EAAOi7C,aAAaW,cAAe,IACvCF,MAAM,KACNtY,MAAM,MACT,KAEN9kD,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,iBACPC,SAAU,QACViiC,oBAAmBxiD,EAAAA,EAAA,GACd4e,EAAOi7C,cADO,GAAA,CAEjBY,yBAA0BX,EAC1BY,wBAAyBP,EACzBQ,2BAA4BJ,OAOH98D,oCAACmhB,EAAQg8C,GAC1C,MAAM13D,KACJA,EADIw6C,KAEJA,EAFI1xC,OAGJA,EAHI9Q,QAIJA,EACA6oB,OAAQ0+B,EACRljC,UAAUuvB,SACRA,EACAD,IAAKyiB,EAFGnJ,aAGRA,EAHQC,qBAIRA,EAJQ8L,kBAKRA,EALQC,aAMRA,GAZE7B,oBAcJA,EACAnmB,kBAAmB14B,GACjBmL,EACEi8C,EAAsB,aAAbpY,EAA0B,OAAS,OAE5CqY,EAAY,GASlB,IAPI,EAAA5N,EAAAkH,sBAAqBx1C,IACvBk8C,EAAUC,gBAAkB5S,EAC5B2S,EAAUE,yBAA2B5S,GAErC0S,EAAUG,UAAYnsB,EAGpBwjB,EAAqB,CACvB,MAAMC,aAAEA,GAAiBD,EACzB,GAAIC,EAAc,CAChBuI,EAAUI,iBAAmB3I,EAC7B,IAAIpB,EAAsBvyC,EAAO0zC,oBAAoBnK,aACjDiJ,EACFxyC,EAAO0zC,oBAAoBlK,qBAE7B,GACE,CACE4E,EAAAiF,oBAAoBkJ,IACpBnO,EAAAiF,oBAAoBC,OACpBlF,EAAAiF,oBAAoBC,OAAOkJ,MAC3BhwD,SAASmnD,GACX,CAAA,IAAA8I,EAAAC,EACA,MAAM9I,gBAAEA,SAA0Bt1D,KAAKqxD,6BACqB,IAAAgN,EAKQC,EALpE,GAAIhJ,MAAAA,GAAJ,QAAA6I,EAAI7I,EAAkBD,UAAtB,IAAA8I,GAAIA,EAAiCvI,sBACnC3B,EAAmB,QAAAoK,EACjB/I,EAAgBD,UADC,IAAAgJ,OAAA,EACjBA,EAA+BzI,sBACjCgI,EAAUW,wBAA0BtK,EAEtC,GAAIqB,MAAAA,GAAJ,QAAA8I,EAAI9I,EAAkBD,UAAtB,IAAA+I,GAAIA,EAAiCzI,8BACnCzB,EAA2B,QAAAoK,EACzBhJ,EAAgBD,UADS,IAAAiJ,OAAA,EACzBA,EAA+B3I,8BACjCiI,EAAUY,iCAAmCtK,GAK/CxyC,EAAO0zC,oBAAoBzjB,MAC7BisB,EAAUa,YAAc/8C,EAAO0zC,oBAAoBzjB,KAEjDjwB,EAAO0zC,oBAAoBxjB,WAC7BgsB,EAAUc,kBAAoBh9C,EAAO0zC,oBAAoBxjB,UAIzDolB,IACF4G,EAAUe,mBAAqB3H,GAG7BC,IACF2G,EAAUgB,cAAgB3H,GAG5B,MAAM4H,EAAkB7+D,KAAK8+D,oBAAoBlB,GAEjD,IAAImB,EAAiB,IACrB,GAAIr9C,EAAOW,SAAS4oC,aAAc,CAChC,MAAMsJ,iBAAEA,GAAqBv0D,KAAKuY,iBAAiBgD,WACnDwjD,EAAiBxK,EAAmB,IAAM,IAyB5C,MAAO,CAAEjxC,WAtBU,CACjBijC,SAAUvoD,EACVunD,SAAAA,EACAoY,OAAAA,EACApnD,QAAAA,EACAvQ,KAAAA,EACAg5D,iBAAkBD,EAClBE,cAAe,OACfC,mBAAoB,QAcD5Z,oBAXIxiD,EAAAA,EAAA,CACvBgM,OAAAA,EACAqwD,2BAA2B,EAAAnP,EAAAkH,sBAAqBx1C,GAC5C/P,EAAAytD,gCAAgC3J,WAChC9jD,EAAAytD,gCAAgCrL,OACpCsL,WAAY7e,EACZ8e,UAAWlL,GACRyK,GACAnB,IAmBPnD,gCACE74C,EACA0B,EACAE,EACAgiC,GAEA,MAIMH,EAAoB,eAJN,CAClBl0C,EAAAgiD,mBAAmB4G,UACnB5oD,EAAAgiD,mBAAmB9pC,WACnBjb,SAASkV,GAEK,YAAc,WAC1B1B,EAAOzc,KAGX,QAAwB,IADPjF,KAAKghB,qBAAqBmkC,GAK3C,OAAQ/hC,GAUN,KAAKnS,EAAAgiD,mBAAmBC,MACtBlzD,KAAK6gB,oBAAoB,CACvBwC,SAAU,eACVgiC,aAAcp0C,EAAAgiD,mBAAmBC,MACjChO,aAAcj0C,EAAAgiD,mBAAmBpd,SACjC+P,aAAc30C,EAAAgiD,mBAAmBzmB,SACjClpB,WAAAA,EACAgiC,oBAAAA,EACAvwC,SAAS,EACTowC,iBAAAA,IAEF,MASF,KAAKl0C,EAAAgiD,mBAAmBpd,SACxB,KAAK5kC,EAAAgiD,mBAAmBzmB,SACtBxsC,KAAK6gB,oBAAoB,CACvBwC,SAAU,eACV6hC,aAAcj0C,EAAAgiD,mBAAmBpd,SACjC+P,aAAc30C,EAAAgiD,mBAAmBzmB,SACjClpB,WAAAA,EACAgiC,oBAAAA,EACAvwC,SAAS,EACTowC,iBAAAA,IAEF,MAWF,KAAKl0C,EAAAgiD,mBAAmB9pC,UACtBnpB,KAAK6gB,oBAAoB,CACvBwC,SAAU,eACVgiC,aAAcp0C,EAAAgiD,mBAAmB9pC,UACjC+7B,aAAcj0C,EAAAgiD,mBAAmB4G,UACjCv2C,WAAAA,EACAgiC,oBAAAA,EACAvwC,SAAS,EACTowC,iBAAAA,IAEF,MASF,KAAKl0C,EAAAgiD,mBAAmB4G,UACtB75D,KAAK6gB,oBAAoB,CACvBwC,SAAU,eACV6hC,aAAcj0C,EAAAgiD,mBAAmB4G,UACjCv2C,WAAAA,EACAgiC,oBAAAA,EACAvwC,SAAS,EACTowC,iBAAAA,KAiB2B5kD,oCAACmhB,EAAQ0B,EAAOs6C,EAAc,IAC/D,IAAKh8C,EACH,OAEF,MAAM4B,WACJA,EADIgiC,oBAEJA,SACQtlD,KAAKs6D,8BAA8B54C,EAAQg8C,GAWrD,IAAIz4D,EAEJ,OATAjF,KAAKu6D,gCACH74C,EACA0B,EACAE,EACAgiC,GAKMliC,GAGN,KAAKnS,EAAAgiD,mBAAmBpd,SACtB5wC,EAAM,qBAAoByc,EAAOzc,KACjCjF,KAAK8gB,oBAAoB7b,EAAI,CAAEqe,WAAAA,EAAYgiC,oBAAAA,IAC3CtlD,KAAK+gB,sBAAsB9b,GAC3B,MAGF,KAAKgM,EAAAgiD,mBAAmBzmB,SACtBvnC,EAAM,qBAAoByc,EAAOzc,KACjCjF,KAAK8gB,oBAAoB7b,EAAI,CAAEqe,WAAAA,EAAYgiC,oBAAAA,IAC3CtlD,KAAK+gB,sBAAsB9b,EAAI,CAC7By/C,WAAW,IAEb,MAGF,KAAKzzC,EAAAgiD,mBAAmB4G,UACtB50D,EAAM,yBAAwByc,EAAOzc,KACrCjF,KAAK8gB,oBAAoB7b,EAAI,CAAEqe,WAAAA,EAAYgiC,oBAAAA,IAC3CtlD,KAAK+gB,sBAAuB,yBAAwBW,EAAOzc,OAOjE20D,8BAA8BlrB,GAC5B,OAAO9oC,KAAKk/C,OAAO7f,KAAKC,MAAQwJ,GAAiB,KAAMvR,WAGzD2hC,oBAAoBlB,GAClB,MAAM2B,EAAkB,GACxB,IAAK,MAAMC,KAAS5B,GACd,EAAAttD,EAAAmvD,aAAY7B,EAAU4B,IACxBD,EAAgBC,IAAS,EAAA/tD,EAAAiuD,iBAAgB9B,EAAU4B,IAEnDD,EAAgBC,GAAS5B,EAAU4B,GAGvC,OAAOD,EAGT5H,iBAAiBr2C,EAAMhhB,GACrBN,KAAK2hB,eAAeg+C,kBAAkBr+C,EAAMhhB,GAC5C,MAAMohB,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAClDthB,KAAKgzD,8BAA8BtxC,EAAQzQ,EAAAgiD,mBAAmB4G,UAAW,CACvEv5D,MAAOA,EAAM4D,UAIjBi3D,iBAAiB75C,GACfthB,KAAK2hB,eAAei+C,mBAAmBt+C,GACvC,MAAMI,EAAS1hB,KAAK2hB,eAAeC,eAAeN,GAClDthB,KAAKgzD,8BAA8BtxC,EAAQzQ,EAAAgiD,mBAAmB4G,ghBCp6DlE,MAAAgG,EAAAjgE,EAAAnB,EAAA,mBACA6E,EAAA7E,EAAA,kCAEA,MAAMqhE,EAAyB5/D,QAC7BuX,EAAQC,IAAIqoD,gBAAkBtoD,EAAQC,IAAIqC,SAEtCimD,EAA4B,OAAR,GAAA,GAAH,KACjBC,EAAY,QAAAC,EAAGzoD,EAAQC,IAAIuoD,oBAAf,IAAAC,EAAAA,EAA+B,KAiB3CC,EAAkC,EAAT78D,EAAAE,OAWlB48D,EAAoB,CAACC,EApBK,KAqBrC,MAAMC,EAAc,CAGlB5gE,MAAO,GAOPqnC,QACEu5B,EAAY5gE,MAAMZ,SAAQ,EAAEyG,EAAGlC,MAC7BA,OAEFi9D,EAAY5gE,MAAQ,IAUtBynD,MAAMnkB,EAAS3/B,EAAW,KAAM7C,YAC9B8/D,EAAY5gE,MAAMqhC,KAAK,CAACiC,EAAS3/B,IAE7Bi9D,EAAY5gE,MAAMkB,QAAUy/D,GAC9BC,EAAYv5B,SAQhB3N,SAGAmnC,cAKF,OAAOD,yBAGF,MAAMhoD,GACV0nD,GAAsBF,IAA2BG,EAC9CG,EAtEiC,GAuEjC,IAAIP,EAAA1/D,QAAU6/D,EAAmB,CAC/B7kB,KAAM8kB,EACNI,QAzE+B,EA0E/BG,cAAeL,whBCzFvB,IAAAtgE,EAAAD,EAAAnB,EAAA,aACAgiE,EAAA7gE,EAAAnB,EAAA,sBACAiiE,EAAA9gE,EAAAnB,EAAA,iCACA6R,EAAA7R,EAAA,mBAMAqB,EAAArB,EAAA,qBAEwB,CACtBk9B,cAAcH,EAAUC,GACtB,IACE,MACMklC,GAAgBC,EADL5gE,KAAK6gE,WAAWrlC,OACCC,GAClC,OAAO16B,QAAQC,QAAQ2/D,GACvB,MAAOn/D,GACP,OAAOT,QAAQE,OAAOO,KAI1Bq/D,WAAY,CACV,cAAgBnlC,IACd,IAAKA,EACH,MAAM,IAAIhzB,MAAM,+BAGlB,MAAMo4D,GAAW,EAAAhhE,EAAA2xC,cAAa/V,GACxByL,GAAS,EAAA72B,EAAA0oD,UAAS8H,GAExB,KAAK,EAAAxwD,EAAAywD,gBAAe55B,GAClB,MAAM,IAAIz+B,MAAM,sCAIlB,OADiB,EAAA4H,EAAAysB,gBAAe+jC,IAGlC,YAAa,CAACvhE,EAAO0mB,KACnB,IAAI+6C,EACJ,IACEA,EAASN,EAAAvgE,QAAU8gE,gBAAgB1hE,EAAO0mB,GAC1C,MAAOzkB,GACP3B,EAAAM,QAAI8D,MAAM,6DACV+8D,EAASP,EAAAtgE,QAAO+gE,OAAO3hE,EAAO0mB,GAAU,GAG1C,OAKN,SAA4B+6C,GAC1B,MAAMG,EAAmBH,EAAOI,gBAChC,OAAO,EAAA9wD,EAAA4wC,aAAYigB,GAPRE,CAAmBL,6dC/ChC,IAAA7vD,8bAAAmB,CAAA7T,EAAA,0pCCAAixD,EAAAjxD,EAAA,UACAoB,EAAAD,EAAAnB,EAAA,aACA+8C,EAAA57C,EAAAnB,EAAA,iBACAmR,EAAAnR,EAAA,uBACAH,EAAAG,EAAA,UACA8wD,EAAA3vD,EAAAnB,EAAA,6BACAiT,EAAAjT,EAAA,wCACA6iE,EAAA7iE,EAAA,qCACAsxD,EAAAtxD,EAAA,4CAKAyS,EAAAzS,EAAA,mCAOAqxD,EAAArxD,EAAA,iCAEA4U,EAAA5U,EAAA,uCAEA8iE,EAAA9iE,EAAA,sCAIA+iE,EAAA5hE,EAAAnB,EAAA,+CACA6E,EAAA7E,EAAA,kCACAqB,EAAArB,EAAA,kCACA0S,EAAA1S,EAAA,wlBAGA,MAAMgjE,EAAgB,KAQhBC,EAA8Bp+D,EAAA4+C,OAC9Byf,EAAmD,GAATr+D,EAAAE,OAGhD,SAASo+D,EACPC,EAASJ,KACTK,EAAkB,EAClBC,EAAe,GAEf,MAAMC,EAAoB,IAAIxmB,EAAAr7C,QAAU0hE,EAAQ,IAAII,MAClDH,EACA,IASF,OAPoCE,EAAkBE,GAAG,IAGvBF,EAAkBE,GAAGH,EAAc,IAC9D,KAAIC,EAAkB7kC,SAAS,MAChC4kC,EAKR,MAAMI,EAAe,CACnBC,WAAY,CACVC,OAAQ,GACRC,2BAA2B,EAC3BC,YAAa,KACb5+C,OAAQ,KACR6+C,UAAW,KACXC,YAAa,KACbC,kBAAmB,KACnBC,aAAc,GACdC,eAAgB,KAChBC,mBAAoB,KACpBC,2BAA4B,KAC5BC,kBAAmB,GACnBC,cAAe,KACfC,oBAAqB,GACrB/M,SAAU,GACVgN,SAAU,KACVC,WAAY,GACZC,oBAAoB,EACpBC,mBAAmB,EACnBC,sBAAuB5B,EACvB6B,iCAAkC7B,EAClC8B,+BAAgC7B,EAChC8B,mCAAoC9B,EACpC+B,kBAAmB,KAuxBvB,SAASC,EAAuBC,GAC9B,IAAKnpC,MAAMuS,QAAQ42B,IAA+B,IAAnBA,EAAQhjE,OACrC,MAAM,IAAI8H,MAAM,mCAGlB,MAAM25D,EAAS,IAAIuB,GAWnB,GATAvB,EAAO16D,MAAK,CAACk8D,EAAQC,KACnB,MAAMC,EAAuB,IAAIvoB,EAAAr7C,QAAU0jE,EAAOG,oBAAqB,IACjEC,EAAuB,IAAIzoB,EAAAr7C,QAAU2jE,EAAOE,oBAAqB,IACvE,OAAID,EAAqBG,OAAOD,GACvB,EAEFF,EAAqBI,SAASF,IAAyB,EAAI,KAGhE5B,EAAOzhE,OAAS,GAAM,EAAG,CAE3B,MAAMwjE,EACJ/B,GAAQA,EAAOzhE,OAAS,GAAK,GAAGojE,oBAIlC,OAAOK,EAHgChC,EAAOh6D,QAC3Ci8D,GAAUF,IAAuBE,EAAMN,uBAM5C,MAAMO,EAAalC,EAAOzhE,OAAS,EAC7B4jE,EAAaD,EAAa,EAE1BE,EAA2BpC,EAAOkC,GAAYP,oBAC9CU,EAA2BrC,EAAOmC,GAAYR,oBAE9CW,EAAgCtC,EAAOh6D,QAC1Ci8D,GAAUG,IAA6BH,EAAMN,sBAE1CY,EAAgCvC,EAAOh6D,QAC1Ci8D,GAAUI,IAA6BJ,EAAMN,sBAG1Ca,EAA2BR,EAC/BM,GAEIG,EAA2BT,EAC/BO,GAGF,MAAO,CACLG,OAAQ,IAAIvpB,EAAAr7C,QAAU0kE,EAAyBE,OAAQ,IACpDC,KAAKF,EAAyBC,OAAQ,IACtCE,UAAU,GACV9nC,SAAS,IACZ+nC,iBAAkB,IAAI1pB,EAAAr7C,QACpB0kE,EAAyBK,iBACzB,IAECF,KAAKF,EAAyBI,iBAAkB,IAChDD,UAAU,GACV9nC,SAAS,IACZgoC,iBAAkB,IAAI3pB,EAAAr7C,QACpB0kE,EAAyBM,iBACzB,IAECH,KAAKF,EAAyBK,iBAAkB,IAChDF,UAAU,GACV9nC,SAAS,KAahB,SAASknC,EAA0BhC,GACjC,MAAM+C,EAA8B/C,EAAOvrC,QACzC,CAACuuC,EAAiBf,KAAlB,CACES,OAAQM,EAAgBN,OAAOC,KAAKV,EAAMS,OAAQ,IAClDG,iBAAkBG,EAAgBH,iBAAiBF,KACjDV,EAAMY,iBACN,IAEFC,iBAAkBE,EAAgBF,iBAAiBH,KACjDV,EAAMa,iBACN,OAGJ,CACEJ,OAAQ,IAAIvpB,EAAAr7C,QAAU,EAAG,IACzB+kE,iBAAkB,IAAI1pB,EAAAr7C,QAAU,EAAG,IACnCglE,iBAAkB,IAAI3pB,EAAAr7C,QAAU,EAAG,MAIvC,MAAO,CACL4kE,OAAQK,EAA4BL,OACjC7H,IAAImF,EAAOzhE,OAAQ,IACnBu8B,SAAS,IACZ+nC,iBAAkBE,EAA4BF,iBAC3ChI,IAAImF,EAAOzhE,OAAQ,IACnBu8B,SAAS,IACZgoC,iBAAkBC,EAA4BD,iBAC3CjI,IAAImF,EAAOzhE,OAAQ,IACnBu8B,SAAS,eA93BD,MACbp9B,aAAYwkB,oBACVA,EADU1O,kBAEVA,EAFU9I,SAGVA,EAHU0T,kBAIVA,EAJUgE,mBAKVA,EALU6gD,gBAMVA,EAAkB/D,EAAA+D,gBANRz3D,kBAOVA,EAPUsT,0BAQVA,IAEAnhB,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAgB,CAC/Bg5C,WAAUt/D,EAAA,GAAOq/D,EAAaC,cAGhCpiE,KAAKulE,iBAAmBD,EACxBtlE,KAAKmtD,mBAAqBt/C,EAC1B7N,KAAKqxD,2BAA6BlwC,EAElCnhB,KAAKukB,oBAAsBA,EAC3BvkB,KAAKykB,mBAAqBA,EAE1BzkB,KAAKwlE,UAAY,EACjBxlE,KAAKygB,kBAAoBA,EAEzBzgB,KAAKylE,0BAA4B,EAEjCzlE,KAAK0lE,eAAiB,IAAIhW,EAAAc,OAAOmV,UAAUC,aAAa74D,GACxD/M,KAAK6lE,gBAAkBhwD,EAAkBf,MAAMyG,WAAWhF,QAC1DV,EAAkB4C,GAAGtH,EAAAuH,eAAeC,oBAAqBpC,IACvC,YAAZA,GAAyBA,IAAYvW,KAAK6lE,kBAC5C7lE,KAAK6lE,gBAAkBtvD,EACvBvW,KAAK0lE,eAAiB,IAAIhW,EAAAc,OAAOmV,UAAUC,aAAa74D,OAKlCxM,6BAACvC,GAC3B,MAAM8F,QAAiB,EAAA09D,EAAArhE,UACrB,EAAAohE,EAAAuE,YAAW,UAAW9nE,GACtB,CAAE6Q,OAAQ,OACV,CAAEk3D,iBAAkB,OAEhBC,aAAEA,GAAiBliE,GAAY,GACrC,IACGkiE,GAC8B,iBAAxBA,EAAa3D,QACsB,iBAAnC2D,EAAaC,mBACuB,iBAApCD,EAAaE,oBACmB,iBAAhCF,EAAaG,eAEpB,MAAM,IAAIz9D,MACP,iDAAgD5E,KAIrD,MAAO,CACLu+D,OAA8B,IAAtB2D,EAAa3D,OACrB4D,kBAAoD,IAAjCD,EAAaC,kBAChCC,mBAAsD,IAAlCF,EAAaE,mBACjCC,eAA8C,IAA9BH,EAAaG,eAC7BC,kBAAmBJ,EAAaI,mBAKT7lE,8BAAG,IAAA8lE,EAAAC,EAAAC,EAAAC,EAAAC,EAC5B,MAAMzoE,EAAUgC,KAAKmtD,qBACrB,IAAIuZ,EACJ,IACEA,QAA0B1mE,KAAK2mE,uBAAuB3oE,GACtD,MAAOwD,GACPuN,QAAQzO,MAAM,gDAAiDkB,GAEjE,MAAQ4gE,WAAYwE,GAAqB5mE,KAAK8U,MAAMyG,WACpDvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GACL8jE,GADK,GAAA,CAERtD,uBACmB,QAAjB+C,EAAAK,SAAA,IAAAL,OAAA,EAAAA,EAAmBhE,SAAUX,EAC/B6B,kCACmB,QAAjB+C,EAAAI,SAAA,IAAAJ,OAAA,EAAAA,EAAmBL,oBAAqBvE,EAC1C+B,oCACmB,QAAjB8C,EAAAG,SAAA,IAAAH,OAAA,EAAAA,EAAmBL,qBACnBvE,EACF6B,gCACmB,QAAjBgD,EAAAE,SAAA,IAAAF,OAAA,EAAAA,EAAmBL,iBACnBxE,EACFkF,wBACmB,QAAjBJ,EAAAC,SAAA,IAAAD,OAAA,EAAAA,EAAmBL,oBA3IgB,QAqJ3CU,mBACE,MACE1E,YAAYkB,sBACVA,EADUC,iCAEVA,EAFUjB,0BAGVA,IAEAtiE,KAAK8U,MAAMyG,WAETwrD,EAAwBzE,EAC1BgB,EACAC,EACJvjE,KAAKgnE,eAAiBxgC,YAAW,KAAM,IAAAygC,EACrC,MAAM7E,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAKsxB,kBACH8wC,EAAWG,YADb,QAAA0E,EAEE7E,EAAWG,mBAFb,IAAA0E,OAAA,EAEEA,EAAwBC,UACxB,KAEDH,GAGL70C,uBACMlyB,KAAKgnE,gBACPlgC,aAAa9mC,KAAKgnE,gBAICzmE,wBACrBgiE,EACA4E,EAAsB,GACtBC,GAEA,MAAMppE,QAAEA,GAAYmpE,GAElB/E,YAAYE,0BAAEA,EAAFe,kBAA6BA,IACvCrjE,KAAK8U,MAAMyG,WAEf,IAAKgnD,EACH,OAAO,KAGJ6E,IACHpnE,KAAKwlE,UAAY,GAInB1+B,aAAa9mC,KAAKgnE,gBAEbI,GACHpnE,KAAKqyB,iBAAiB,IAGxB,MAAMg1C,EAAqBrnE,KAAKylE,0BAA4B,EAC5DzlE,KAAKylE,0BAA4B4B,EAE5BhE,GACHrjE,KAAKsnE,sBAAqB,GAG5B,IAAKC,SAAmBxmE,QAAQ61B,IAAI,CAClC52B,KAAKulE,iBAAiBhD,EAAtBz/D,EAAA,GACKqkE,IAELnnE,KAAKwnE,0BAGP,MACEpF,YAAciB,kBAAmBoE,IAC/BznE,KAAK8U,MAAMyG,WAIf,IAAKksD,EACH,MAAO,CACL,GACA,MAIJF,GAAY,EAAAjpE,EAAAopE,WAAUH,GAAYjD,GAADxhE,EAAAA,EAAA,GAC5BwhE,GAD4B,GAAA,CAE/BqD,gBAAiBR,EAAoBQ,gBACrCC,qBAAsBT,EAAoBS,yBAG5C,MAAMlF,EAAoBz9B,KAAKC,MAE/B,IAAI2iC,GAAmB,EACvB,KACG,EAAAx0D,EAAAy0D,4BAA2BvF,EAAYwF,YAAa/pE,IACrDY,OAAO64B,OAAO8vC,GAAW3mE,OACzB,CACA,MAAMonE,QAAkBhoE,KAAKioE,mBAC3B1F,EAAYwF,YACZxF,EAAYlQ,YACZr0D,IAEKkqE,GAActpE,OAAO64B,OAAO8vC,GAUnC,GAJAM,EACEK,EAAWC,gBACXH,EAAUI,GAAG,IACa,kBAA1BF,EAAWG,WACRR,GAKE,IAAKT,EAAiB,CAC3B,MAAQhT,SAAUkU,SAAsBtoE,KAAKuoE,kBAC3CL,EAAWC,gBAGbZ,GAAY,EAAAjpE,EAAAopE,WAAUH,GAAYjD,GAADxhE,EAAAA,EAAA,GAC5BwhE,GAD4B,GAAA,CAE/B6D,eAAcrlE,EAAAA,EAAA,GACTwhE,EAAM6D,gBADG,GAAA,CAEZx2B,IAAK22B,GAAep3D,EAAAs3D,sCAbxBjB,GAAY,EAAAjpE,EAAAopE,WAAUH,GAAYjD,GAADxhE,EAAAA,EAAA,GAC5BwhE,GAD4B,GAAA,CAE/B6D,eAAgB,SAiBtB,IAAIjF,EAAW,KAQf,GAJK2E,GAAqBtF,MAAAA,GAAAA,EAAakG,eACrClB,QAAkBvnE,KAAK0oE,6BAA6BnB,IAGd,IAApC3oE,OAAO64B,OAAO8vC,GAAW3mE,OAC3BZ,KAAKqyB,iBAAiBnhB,EAAAy3D,gCACjB,CACL,MACEC,EACAC,SACQ7oE,KAAK8oE,iCAAiCvB,GAChDrE,EAAW0F,EACXrB,EAAYsB,EAKd,GAAI7oE,KAAKylE,4BAA8B4B,EACrC,MAAM,IAAI3+D,MAAMwI,EAAA63D,4BAGlB,MAAM3G,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClC,IAAIynD,cAAEA,GAAkBZ,EAsBxB,OArBKmF,EAAUvE,KACbA,EAAgB,MAGlBhjE,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GACLs/D,GADK,GAAA,CAERC,OAAQkF,EACRhF,YAAWz/D,EAAAA,EAAA,GAAOy/D,GAAP,GAAA,CAAoB2E,SAAUC,IACzCzE,kBAAAA,EACAM,cAAAA,EACAE,SAAAA,MAIAZ,IAGFtiE,KAAKwlE,WAAa,IAGflD,GAA6BtiE,KAAKwlE,UAAYwD,GACjDhpE,KAAK8mE,mBAOA,CAACS,EAAWrE,KALjBljE,KAAKoyB,sBACLpyB,KAAKqyB,iBAAiBnhB,EAAA+3D,sBACf,MAMXh3C,oBACE,MAAMmwC,WAAEA,GAAepiE,KAAK8U,MAAMyG,YAC7Bvb,KAAKgnE,gBAAkB5E,EAAWG,aACrCviE,KAAKsxB,kBAAkB8wC,EAAWG,aAItChxC,sBAAsByxC,GACpB,MAAMZ,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CAAEk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBY,cAAAA,MAGxDvxC,eAAe9N,GACb,MAAMy+C,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CAAEk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBz+C,OAAAA,MAGxD+N,mBACE,MAAM0wC,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CAAEk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBC,OAAQ,OAGhEhwC,iBAAiB6jC,GACf,MAAMkM,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CAAEk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBlM,SAAAA,MAGtB31D,mCAAC8hE,GACjC,MAAM6G,QAAqBnoE,QAAQ61B,IACjCh4B,OAAO64B,OAAO4qC,GAAQ3gE,KAAInB,MAAAA,IACxB,MAAM6zD,SAAEA,EAAF3wC,gBAAYA,SAA0BzjB,KAAKuoE,kBAC/CjE,EAAM6E,OAER,MAAO,CAAC/U,EAAU3wC,EAAiB6gD,EAAM+D,gBAIvCd,EAAY,GAqBlB,OApBA2B,EAAapqE,SAAQ,EAAEs1D,EAAU3wC,EAAiB2lD,MAChD,GAAIhV,IAAa3wC,EAAiB,CAChC,MAAM4lD,EAAwBzH,EAC5BS,EAAO+G,GAAOvH,OACdQ,EAAO+G,GAAOtH,gBACd1N,GAGFmT,EAAU6B,GAAVtmE,EAAAA,EAAA,GACKu/D,EAAO+G,IADZ,GAAA,CAEEE,YAAalV,EACbiV,sBAAAA,SAEOhH,EAAO+G,GAAOjB,iBAGvBZ,EAAU6B,GAAS/G,EAAO+G,OAIvB7B,EAGTgB,kBAAkBgB,GAChB,OAAO,IAAIxoE,SAASC,IAClB,IAAIwoE,GAAc,EAElB,MAAMC,EAAajjC,YAAW,KAC5BgjC,GAAc,EACdxoE,EAAQ,CAAEozD,SAAU,KAAM3wC,iBAAiB,MACjC,EAATngB,EAAAE,QAKGkmE,EAA8B,CAClClqE,KAAM+pE,EAAc/pE,KACpB21B,KAAMo0C,EAAcp0C,KACpBuc,GAAI63B,EAAc73B,GAClBlzC,MAAO+qE,EAAc/qE,OAGvBwB,KAAKukB,oBAAoB,CAAElC,SAAUqnD,GAA+B,GACjE5O,MAAK,EAAG1G,SAAAA,EAAU3wC,gBAAAA,MACZ+lD,IACH1iC,aAAa2iC,GACbzoE,EAAQ,CAAEozD,SAAAA,EAAU3wC,gBAAAA,QAGvBqhB,OAAOtjC,IACN3B,EAAAM,QAAIG,MAAMkB,GACLgoE,IACH1iC,aAAa2iC,GACbzoE,EAAQ,CAAEozD,SAAU,KAAM3wC,iBAAiB,WAM1BljB,4BAACopE,GAC1B,MAAMvH,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAE5BquD,EAAa9mE,EAAA,GAAQs/D,EAAWC,OAAOsH,KAG3CvV,SAAUyV,EADNpmD,gBAEJA,SACQzjB,KAAKuoE,kBAAkBqB,EAAcT,OAE/C,GAAIU,IAAmBpmD,EAAiB,CACtC,MAAM4lD,EAAwBzH,EAC5BgI,EAAc/H,OACd+H,EAAc9H,gBACd+H,GAGFD,EAAcN,YAAcO,EAC5BD,EAAcP,sBAAwBA,EAGxCrpE,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GACLs/D,GADK,GAAA,CAERC,OAAMv/D,EAAAA,EAAA,GAAOs/D,EAAWC,QAAlB,GAAA,CAA0BsH,CAACA,GAAeC,QAKtDj4C,eAAe8wC,GACb,MAAML,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CAAEk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBK,YAAAA,MAGxD7wC,aAAa4wC,GACX,MAAMJ,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CAAEk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBI,UAAAA,MAGxDsH,qBAAqBpH,GACnB,MAAMN,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBM,kBAAAA,MAIjC7wC,mBAAmB+f,GACjB,MAAMwwB,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBQ,eAAgBhxB,MAIjD7f,uBAAuBk5B,GACrB,MAAMmX,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBS,mBAAoB5X,MAIrDv4B,qBAAqBqwC,GACnB,MAAMX,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBW,kBAAAA,MAIjCpwC,kCAAkC2vC,GAChC,MAAMF,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBE,0BAAAA,MAIjCtwC,+BAA+Bk5B,GAC7B,MAAMkX,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GACLs/D,GADK,GAAA,CAERU,2BAA4B5X,MAKlCp5B,mBAAmBsiC,GACjB,MAAMgO,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBO,aAAcvO,MAI/C7hC,uBAAuB/yB,GACrB,MAAM4iE,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBa,oBAAqBzjE,MAItD2yB,4BAA4BgxC,GAC1B,MAAMf,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CAAEk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBe,WAAAA,MAGxDmE,qBAAqBx4D,GACnB,MAAMszD,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBiB,kBAAmBv0D,MAIpD0jB,iBAAiBu3C,GACf,MAAM3H,WAAEA,GAAepiE,KAAK8U,MAAMyG,YAC5B6nD,mBAAEA,GAAuB2G,EAC/B/pE,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBgB,mBAAAA,MAIjC3wC,qBAAqBixC,GACnB,MAAMtB,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GAAOs/D,GAAP,GAAA,CAAmBsB,kBAAAA,MAIjCtxC,sBACE,MAAMgwC,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GACLq/D,EAAaC,YADR,GAAA,CAERz+C,OAAQy+C,EAAWz+C,OACnB4+C,YAAaH,EAAWG,YACxBa,mBAAoBhB,EAAWgB,mBAC/BE,sBAAuBlB,EAAWkB,sBAClCC,iCACEnB,EAAWmB,iCACbG,kBAAmBtB,EAAWsB,sBAGlC58B,aAAa9mC,KAAKgnE,gBAGpBx1C,kBACE,MAAM4wC,WAAEA,GAAepiE,KAAK8U,MAAMyG,WAClCvb,KAAK8U,MAAMo2B,YAAY,CACrBk3B,WAAUt/D,EAAAA,EAAA,GACLq/D,EAAaC,YADR,GAAA,CAERkB,sBAAuBlB,EAAWkB,sBAClCC,iCACEnB,EAAWmB,qCAGjBz8B,aAAa9mC,KAAKgnE,gBAGkBzmE,uCAAC8hE,EAAS,IAC9C,MACE2H,sBAAuBC,GACrBjqE,KAAKykB,sBAEP29C,YAAYQ,eAAEA,EAAFE,2BAAkBA,IAC5B9iE,KAAK8U,MAAMyG,WACTvd,EAAUgC,KAAKmtD,qBAGrB,IADkBvuD,OAAO+B,KAAK0hE,GAAQzhE,OAEpC,MAAO,GAGT,MAAM2mE,GAAY,EAAAjpE,EAAAC,WAAU8jE,IAEtB/M,gBACJA,EADIC,gBAEJA,SACQv1D,KAAKqxD,6BAEf,IAAI6Y,EAAe,MAEnB,GAAI3U,IAAoBzF,EAAA0F,mBAAmBC,WAAY,CACrD,MACE0U,MAAMxU,8BAAEA,GADJ0B,iBAEJA,GACE/B,EAEJ4U,GAAe,EAAAna,EAAAqa,eACbtH,IACE,EAAA/S,EAAA6E,iBAAgBe,IAClB,EAAA5F,EAAA6E,iBAAgByC,GAChB,CACEgT,MAAO,GACPC,MAAO,GACPC,cAAe,MACfC,iBAAkB,SAGbjV,IAAoBzF,EAAA0F,mBAAmBzB,OAChDmW,EAAetH,IAAkB,EAAA7S,EAAA6E,iBAAgBU,EAAgB6U,MACxD5U,IAAoBzF,EAAA0F,mBAAmBK,eAChDqU,EACEtH,IAAkB,EAAA7S,EAAA6E,iBAAgBU,EAAgB1jB,WAGtD,IAAIsxB,EAAW,KACXuH,EAAoC,KAExC7rE,OAAO64B,OAAO8vC,GAAWzoE,SAASwlE,IAChC,MAAM+D,WACJA,EADIF,eAEJA,EAFIuC,WAGJA,EAHIC,kBAIJA,EAAoB,EAJhBC,iBAKJA,EALIhD,qBAMJA,EANI0B,YAOJA,EAPIuB,aAQJA,EARI9C,YASJA,EATIoB,MAUJA,EACA2B,IAAKC,GACHzG,EAME0G,GAJ8B1B,EAChC,IAAI9tB,EAAAr7C,QAAUmpE,EAAa,IAC3B,IAAI9tB,EAAAr7C,QAAUuqE,GAAcjJ,EAAe,KAG5CuD,MAAKmD,MAAAA,OAAA,EAAAA,EAAgBx2B,MAAO,MAAO,IACnCxU,SAAS,IAEN8tC,GAAmB,EAAA3J,EAAA4J,cACvBF,EACAd,GAOIiB,EAAe,IAAI3vB,EAAAr7C,QAAU8qE,EAAkB,IAAIjG,KACvDmE,EAAM3qE,MACN,IAGI4sE,GAAe,EAAArb,EAAAsb,gBAAeF,EAAc,CAChDG,aAAc,MACdC,iBAAkB,MAClBC,eAAgB,MAChBC,gBAAiB,KACjBjB,iBAAkB,IAOdzF,GAAS,EAAA1xD,EAAAy0D,4BAA2BC,EAAa/pE,IACnD,EAAA+xD,EAAAsb,gBACEF,EAAalJ,MAAM4I,EAAc,IACjC,CACES,aAAc,MACdC,iBAAkB,MAClBC,eAAgB,MAChBC,gBAAiB,KACjBjB,iBAAkB,IAGtBY,EAEEM,GAAmC,EAAAh6D,EAAAi6D,iBACvChB,EACA/C,EAAqB30B,UAGjB24B,EAAoC,IAAIpwB,EAAAr7C,QAAU,IAAK,IAC1D8hE,MAAM8I,EAAa,IACnB7N,IAAI,KAID2O,EAHqCH,EAAiCxO,IAC1E0O,GAE6D3J,MAC7DyJ,GAGII,EACJ7B,EACErrE,OAAO+B,KAAKspE,GAAsBnoE,MAAMk2C,IACtC,EAAAl4C,EAAAgjB,wBAAuBk1B,EAAc4yB,MAGrCmB,EAA2BD,GAAuB,EAElD3G,EAAmBuG,EAAiCtO,MACxD2O,EAAyB5uC,SAAS,IAClC,IAGI6uC,GAAgC,EAAA34D,EAAAy0D,4BACpC8C,EACA5sE,GAEE,EACA8tE,EAEEG,EACJD,IAAkCxrE,UAC9B2kE,EACAA,EAAiBlD,MAAM8C,EAAQ,IAErCT,EAAMS,OAASA,EAAO5nC,SAAS,IAE3B6uC,IAAkCxrE,YACpC8jE,EAAMa,iBAAmBA,EAAiBhoC,SAAS,IACnDmnC,EAAMN,oBAAsBiI,EAA8B9uC,SAAS,IACnEmnC,EAAMY,iBAAmB2G,EACtBzO,MAAM4O,EAA8B7uC,SAAS,KAC7CA,SAAS,MAI0B,OAAtCstC,GACAwB,EAA8BtwB,GAAG8uB,MAEjCvH,EAAWmF,EACXoC,EAAoCwB,MAoBxC,IAAIC,EAAU,KAEd,IAjBE,EAAA74D,EAAAy0D,4BACEP,EAAUrE,GAAU0H,iBACpB5sE,IAEFkC,QACE+pE,EACErrE,OAAO+B,KAAKspE,GAAsBnoE,MAAMk2C,IAAD,IAAAm0B,EAAA,OACrC,EAAArsE,EAAAgjB,wBACEk1B,EADF,QAAAm0B,EAEE5E,EAAUrE,UAFZ,IAAAiJ,OAAA,EAEEA,EAAqBvB,uBAQnB,CACV,MAAMwB,EAAY7E,EAAUrE,GAE5BgJ,EAAU,GAEV,MACEnH,OAAQsH,EACRnH,iBAAkBoH,EAClBnH,iBAAkBoH,GAChB5I,EAAuB/kE,OAAO64B,OAAO8vC,IAIzC2E,EAAQM,YAAc,IAAIhxB,EAAAr7C,QAAUisE,EAAUjH,iBAAkB,IAAIlD,MAClEsK,EACA,IAKFL,EAAQpB,IAAM,IAAItvB,EAAAr7C,QAAUksE,GAAcpK,MAAMmK,EAAUrH,OAAQ,IAElEmH,EAAQnB,YAAcqB,EAAUlH,iBAIhCgH,EAAQO,MAAQP,EAAQM,YACrBxH,KAAKkH,EAAQpB,KACb7I,MAAMiK,EAAQnB,aACd5tC,SAAS,IACZ+uC,EAAQM,YAAcN,EAAQM,YAAYrvC,SAAS,IACnD+uC,EAAQpB,IAAMoB,EAAQpB,IAAI3tC,SAAS,IACnC+uC,EAAQI,kBAAoBA,EAE5B/E,EAAUrE,GAAUwJ,aAAc,EAClCnF,EAAUrE,GAAUgJ,QAAUA,EAGhC,MAAO,CAAChJ,EAAUqE,GAGIhnE,yBAACwiB,EAAiB4pD,EAAe3uE,GACvD,MAAMo/C,EAAW,IAAIsS,EAAAc,OAAOoc,SAC1B7pD,EACAwsC,EAAApvD,QACAH,KAAK0lE,gBAEP,aAAatoB,EAAS4qB,UACpB2E,EACAz7D,EAAA27D,mCAAmC7uE,MA0HlC,MAAMyyD,EAAQ,CACnBkT,uBAAAA,EACAU,0BAAAA,kVCl+BF,MAAAyI,aAAAA,GAAAruE,EAAA,UACAsuE,EAAAtuE,EAAA,SACAuuE,EAAAvuE,EAAA,mBACAwuE,EAAAxuE,EAAA,iBACAy5D,mBAAAA,GAAAz5D,EAAA,kBAEAyuE,EAAA,IAEAlnE,EAAA,kBAKAmnE,EAAA,CACAC,QAAA,kCACAC,MAAA,gCACAC,QAAA,mCACA/gC,QAAA,4BAGA,MAAAghC,UAAAT,EACA/sE,YAAA8C,EAAA,IACAG,QACAhD,KAAAwtE,eAAA,GACAxtE,KAAAytE,UAAA,KACAztE,KAAAgG,KAAAA,EACAhG,KAAAo5B,KAAA,EACAp5B,KAAA0tE,QAAA,EACA1tE,KAAA2tE,gBAAA,EACA3tE,KAAA4tE,IAAA,IAAAb,EACA/sE,KAAA6tE,MAAA,GACA7tE,KAAA8tE,OAAA,KACA9tE,KAAAuW,QAAA,UACAvW,KAAA+tE,oBAAA,EACA/tE,KAAAguE,YAAAnrE,GAEA7C,KAAAiuE,cAAA,EACAjuE,KAAAkuE,eAGA3zC,YACA,OAAAx5B,QAAAC,QAAA,CACAq3B,OAAAr4B,KAAAq4B,OACA7Z,SAAAxe,KAAAwe,SACAgvD,eAAAxtE,KAAAwtE,eACAC,UAAAztE,KAAAytE,UACAM,oBAAA,IAIAC,YAAAnrE,EAAA,IAeA,OAdA7C,KAAAq4B,OAAAx1B,EAAAw1B,QA5CA,eA6CAr4B,KAAAytE,UAAA5qE,EAAA4qE,WA1CA,uDA2CAztE,KAAAwe,SAAA3b,EAAA2b,UAAA,GACAxe,KAAAwtE,eAAA3qE,EAAA2qE,gBAAA,GACA3qE,EAAA2qE,gBACAxtE,KAAAmuE,uBAAAtrE,GAGA7C,KAAA+tE,mBAAAlrE,EAAAkrE,qBAAA,EAGA/tE,KAAAwe,SAAAxe,KAAAwe,SACAnW,QAAA2nC,GAAApxC,OAAA+B,KAAAX,KAAAwtE,gBAAAt/D,SAAA8+D,EAAAoB,kBAAAp+B,MAEAjvC,QAAAC,UAGAmtE,uBAAAtrE,GACA,GAAA7C,KAAAquE,uBAAAxrE,EAAAyrE,eACA,IAAA,MAAAt+B,KAAApxC,OAAA+B,KAAAkC,EAAAyrE,gBACAtuE,KAAAwtE,eAAAx9B,GAAA,CACAu+B,OAAA,EACAl2C,OAAAr4B,KAAAwuE,iBAAA3rE,EAAAyrE,eAAAt+B,KAMAhwC,KAAAquE,uBACAruE,KAAAwe,SACAnW,QAAA2nC,IAAApxC,OAAA+B,KAAAX,KAAAwtE,gBAAAt/D,SAAA8+D,EAAAoB,kBAAAp+B,MACAlxC,SAAAkxC,IACA,IACAhwC,KAAAwtE,eAAAR,EAAAoB,kBAAAp+B,IAAA,CACAu+B,OAAA,EACAl2C,OAAAr4B,KAAAyuE,iBAAAz+B,IAEA,MAAAxuC,GACAuN,QAAA2/D,IAAA,6BAAA1+B,SAMA11B,aACA,OAAApa,QAAAF,KAAA4tE,KAAA5tE,KAAA4tE,IAAAnwC,WAGAvD,mBAAAL,GACA75B,KAAA2tE,gBAAA3zC,SAAAH,EAAA,IAGAhB,UAAAR,GAEAr4B,KAAAq4B,SAAAA,IACAr4B,KAAA4tE,IAAA,IAAAb,GAEA/sE,KAAAq4B,OAAAA,EAGAs2C,OAAAt2C,GACA,GAAAr4B,KAAAsa,eAAA+d,EACA,OAAAt3B,QAAAC,QAAA,oBAEA,MAAAvD,EAAA46B,EAAAr4B,KAAA4uE,cAAAv2C,GAAAr4B,KAAAq4B,OACA,OAAA,IAAAt3B,SAAA,CAAAC,EAAAC,KACAjB,KAAA6uE,aAAA,CACAtrD,OAAA,gBACA2D,OAAA,CACAmR,OAAA56B,KAGA,EAAAqxE,QAAAA,EAAA9rC,QAAAA,MACA8rC,GACA9uE,KAAA4tE,IAAAnwC,UAAAvI,EAAAC,KAAA6N,EAAAvF,UAAA,OACAz9B,KAAA4tE,IAAAmB,UAAA75C,EAAAC,KAAA6N,EAAA+rC,UAAA,OACA/tE,EAAAgiC,EAAAtkB,UAEAzd,EAAA+hC,EAAA1iC,OAAA,IAAAoI,MAAA,wBAMAsmE,YAAAC,EAAA,GAEA,OAAA,IAAAluE,SAAA,CAAAC,EAAAC,KACAjB,KAAA2uE,SACA7T,MAAAv6D,MAAAgF,IACA,MAAA4vB,EAAAn1B,KAAA2tE,gBACAj8B,EAAAvc,EAAA85C,EACA,IAAA,IAAA5mC,EAAAlT,EAAAkT,EAAAqJ,EAAArJ,IAAA,CACA,MAAA5qC,EAAAuC,KAAAwuE,iBAAAnmC,GACA,IAAA3pB,EAEAA,EADA1e,KAAAquE,4BACAruE,KAAA2uE,OAAAlxE,GAEAuC,KAAAkvE,kBAAAhC,EAAA7kC,GAEAroC,KAAAwtE,eAAAR,EAAAoB,kBAAA1vD,IAAA,CAGA6vD,MAAAvuE,KAAAquE,sBACAh2C,OAAA56B,GAGAuC,KAAAwe,SAAAtQ,SAAAwQ,IACA1e,KAAAwe,SAAAuiB,KAAAriB,GAEA1e,KAAAo5B,KAAA,EAEAp4B,EAAAhB,KAAAwe,aAEAsmB,MAAA7jC,MAIAs4B,eAEA,OADAv5B,KAAAo5B,KAAA,EACAp5B,KAAAmvE,UAAA,GAGA71C,cACA,OAAAt5B,KAAAmvE,UAAA,GAGA91C,kBACA,OAAAr5B,KAAAmvE,WAAA,GAGA7wD,cACA,OAAAvd,QAAAC,QAAAhB,KAAAwe,SAAAxW,SAGA+iB,cAAArM,GACA,IAAA1e,KAAAwe,SAAA9c,KAAAkG,GAAAA,EAAAhG,gBAAAsM,SAAAwQ,EAAA9c,eACA,MAAA,IAAA8G,MAAA,WAAAgW,+BAEA1e,KAAAwe,SAAAxe,KAAAwe,SAAAnW,QAAAT,GAAAA,EAAAhG,gBAAA8c,EAAA9c,uBACA5B,KAAAwtE,eAAAR,EAAAoB,kBAAA1vD,IAGAya,iBACA,OAAA,IAAAp4B,SAAA,CAAAC,EAAAC,KACAjB,KAAA6uE,aAAA,CACAtrD,OAAA,oBACA,EAAAurD,QAAAA,EAAAxuE,MAAAA,MACAwuE,EACA9tE,GAAA,GAEAC,EAAAX,SAMAukC,sBAAAF,GACA,OAAA,IAAA5jC,SAAA,CAAAC,EAAAC,KAGAjB,KAAAiuE,aASAjuE,KAAA6uE,aAAA,CACAtrD,OAAA,0BACA2D,OAAA,CAAAyd,cAAAA,KACA,EAAAmqC,QAAAA,MACAA,EACA9tE,GAAA,GAEAC,EAAA,IAAAyH,MAAA,6CAfA1I,KAAAovE,eAAA,CACApuE,QAAAA,EACAC,OAAAA,EACA0jC,cAAAA,MAmBA/jB,gBAAAlC,EAAAgZ,GACA,IAAA23C,EAKA,GAAA,mBAAA33C,EAAAzd,WAYA,OANAyd,EAAAyd,EAAA63B,EAAA9rB,YAAAxpB,EAAAzd,cACAyd,EAAAihC,EAAA,OACAjhC,EAAAkhC,EAAA,OAEAyW,EAAA33C,EAAA6C,YAAA4C,SAAA,OAEAn9B,KAAAsvE,iBAAA5wD,EAAA2wD,GAAArsC,IACAtL,EAAAyd,EAAAjgB,EAAAC,KAAA6N,EAAAmS,EAAA,OACAzd,EAAAihC,EAAAzjC,EAAAC,KAAA6N,EAAA21B,EAAA,OACAjhC,EAAAkhC,EAAA1jC,EAAAC,KAAA6N,EAAA41B,EAAA,OACAlhC,KAYA,MAAA63C,EAAA73C,EAAA83C,kBAAA,GAMA,OAJAH,EAAAn6C,EAAAu6C,SAAAF,GACAA,EAAApyC,SAAA,OACA6vC,EAAA0C,IAAAC,OAAAJ,GAAApyC,SAAA,OAEAn9B,KAAAsvE,iBAAA5wD,EAAA2wD,GAAArsC,IAIA,MAAA4sC,EAAAl4C,EAAAm4C,SASA,OAPAD,EAAA5pE,KAAA0xB,EAAA1xB,KAEA4pE,EAAAz6B,EAAA63B,EAAAv7B,aAAAzO,EAAAmS,GACAy6B,EAAAjX,EAAAqU,EAAAv7B,aAAAzO,EAAA21B,GACAiX,EAAAhX,EAAAoU,EAAAv7B,aAAAzO,EAAA41B,GAGAV,EAAAC,WAAAyX,EAAA,CAAA7X,OAAArgC,EAAAqgC,OAAA+X,OAAAlxE,OAAAmxE,SAAAr4C,QAIA43C,iBAAA5wD,EAAA2wD,EAAAW,GACA,OAAA,IAAAjvE,SAAA,CAAAC,EAAAC,KACAjB,KAAAiwE,uBAAAvxD,GACAo8C,MAAAziC,IACAr4B,KAAA6uE,aAAA,CACAtrD,OAAA,0BACA2D,OAAA,CACAwQ,GAAA23C,EACAh3C,OAAAA,KAGA,EAAAy2C,QAAAA,EAAA9rC,QAAAA,MACA,GAAA8rC,EAAA,CAEA,MAAAoB,EAAAF,EAAAhtC,GACAktC,EAAAC,kBAEAnvE,EAAAkvE,GAEAjvE,EAAA,IAAAyH,MAAA,wDAGAzH,EAAA+hC,EAAA1iC,OAAA,IAAAoI,MAAA,0DAIAo8B,MAAA7jC,MAIAuuB,YAAA4gD,EAAA5wE,GACA,OAAAQ,KAAA0vB,oBAAA0gD,EAAA5wE,GAIAkwB,oBAAA0gD,EAAAlsE,GACA,OAAA,IAAAnD,SAAA,CAAAC,EAAAC,KACAjB,KAAAiwE,uBAAAG,GACAtV,MAAAziC,IACAr4B,KAAA6uE,aAAA,CACAtrD,OAAA,+BACA2D,OAAA,CACAmR,OAAAA,EACAn0B,QAAA8oE,EAAAjwC,eAAA74B,MAGA,EAAA4qE,QAAAA,EAAA9rC,QAAAA,MACA,GAAA8rC,EAAA,CACA,IAAA35B,EAAAnS,EAAAmS,EAAA,GACAA,EAAAA,EAAAhY,SAAA,IACAgY,EAAAv0C,OAAA,IACAu0C,EAAA,IAAAA,KAEA,MAAAvX,EAAA,KAAAoF,EAAA21B,IAAA31B,EAAA41B,IAAAzjB,IACAk7B,EAAApD,EAAAqD,yBAAA,CAAA9wE,KAAA0E,EAAAqsE,IAAA3yC,IACAovC,EAAAoB,kBAAAiC,KAAArD,EAAAoB,kBAAAgC,IACAnvE,EAAA,IAAAyH,MAAA,yDAEA1H,EAAA48B,QAEA38B,EAAA+hC,EAAA1iC,OAAA,IAAAoI,MAAA,sDAIAo8B,MAAA7jC,MAIAV,6BAAAme,GACA,MAAA8xD,EAAAxD,EAAAoB,kBAAA1vD,GACA,IAAA9f,OAAA+B,KAAAX,KAAAwtE,gBAAAt/D,SAAAsiE,GACA,MAAA,IAAA9nE,MAAA,gCAAA8nE,gBAEA,MAAAn4C,OAAAA,GAAAr4B,KAAAwtE,eAAAgD,GAKA,UAJAxwE,KAAA2uE,OAAAt2C,IAIAz2B,gBAAA8c,EAAA9c,cACA,MAAA,IAAA8G,MAAA,mBAAAgW,6CAEA,OAAA2Z,EAGA93B,oBAAA6vE,EAAA5wE,EAAA8P,EAAA,IACA,MAAAmhE,EAAA,OAAAnhE,EAAAxH,QACA,IAAA2oE,EACA,MAAA,IAAA/nE,MAAA,6DAGA,MAAAylD,OACAA,EAAA3gD,MACAA,EAAAygD,YACAA,EAAA/pD,QACAA,GACA+oE,EAAAyD,eAAAC,aAAAnxE,GACAoxE,EAAA3D,EAAAyD,eAAAG,WAAA,eAAA1iB,EAAA3gD,EAAAijE,GAAAtzC,SAAA,OACA2zC,EAAA7D,EAAAyD,eAAAG,WAAA5iB,EAAA/pD,EAAAsJ,EAAAijE,GAAAtzC,SAAA,OAEA9E,QAAAr4B,KAAAiwE,uBAAAG,IACAtB,QAAAA,EAAA9rC,QAAAA,SAAA,IAAAjiC,SAAAC,IACAhB,KAAA6uE,aAAA,CACAtrD,OAAA,yBACA2D,OAAA,CACAmR,OAAAA,EACAu4C,mBAAAA,EACAE,qBAAAA,KAGArwE,GAAAO,EAAAP,QAGA,GAAAquE,EAAA,CACA,IAAA35B,EAAAnS,EAAAmS,EAAA,GACAA,EAAAA,EAAAhY,SAAA,IACAgY,EAAAv0C,OAAA,IACAu0C,EAAA,IAAAA,KAEA,MAAAvX,EAAA,KAAAoF,EAAA21B,IAAA31B,EAAA41B,IAAAzjB,IACAk7B,EAAApD,EAAA8D,yBAAA,CACAvxE,KAAAA,EACA+wE,IAAA3yC,IAEA,GAAAovC,EAAAoB,kBAAAiC,KAAArD,EAAAoB,kBAAAgC,GACA,MAAA,IAAA1nE,MAAA,wDAEA,OAAAk1B,EAEA,MAAAoF,EAAA1iC,OAAA,IAAAoI,MAAA,+CAGAmmB,gBACA,MAAA,IAAAnmB,MAAA,gCAGAwiB,eACAlrB,KAAAwe,SAAA,GACAxe,KAAAo5B,KAAA,EACAp5B,KAAA2tE,gBAAA,EACA3tE,KAAA6tE,MAAA,GACA7tE,KAAAwtE,eAAA,GACAxtE,KAAA4tE,IAAA,IAAAb,EAKAmB,eACAluE,KAAA8tE,OAAAkD,SAAAC,cAAA,UACAjxE,KAAA8tE,OAAAoD,IAAAlxE,KAAAytE,UACAztE,KAAA8tE,OAAAqD,MAAA,YACAnxE,KAAA8tE,OAAAsD,OAAA7wE,UAIA,GADAP,KAAAiuE,cAAA,EACAjuE,KAAAovE,eACA,IACA,MAAA3uE,QAAAT,KAAA6kC,sBACA7kC,KAAAovE,eAAAzqC,eAEA3kC,KAAAovE,eAAApuE,QAAAP,GACA,MAAAe,GACAxB,KAAAovE,eAAAnuE,OAAAO,GACA,eACAxB,KAAAovE,iBAIA4B,SAAAK,KAAAC,YAAAtxE,KAAA8tE,QAGAyD,aACA,MAAAC,EAAAxxE,KAAAytE,UAAAzrE,MAAA,KAEA,OADAwvE,EAAAjgC,QAAA,EAAA,GACAigC,EAAAC,KAAA,KAGA5C,aAAAjyC,EAAAnhB,GACAmhB,EAAAl+B,OAAA,gBACAsB,KAAA8tE,OAAA4D,cAAAC,YAAA/0C,EAAA,KACA,MAAAg1C,EAAA,EAAA/qD,OAAAA,EAAArnB,KAAAA,KACAqnB,IAAA7mB,KAAAuxE,eAIA/xE,GAAAA,EAAA+jB,QAAA/jB,EAAA+jB,SAAA,GAAAqZ,EAAArZ,gBAAA9H,GACAA,EAAAjc,GACAgB,YAGAmF,OAAAksE,oBAAA,UAAAD,GACApxE,YAEAmF,OAAAmsE,iBAAA,UAAAF,GAGArxE,gBAAAwxE,GAEA/xE,KAAAo5B,MAAA24C,EAEA/xE,KAAAo5B,MAAA,IACAp5B,KAAAo5B,KAAA,GAEA,MAAAjE,GAAAn1B,KAAAo5B,KAAA,GAAAp5B,KAAA0tE,QACAh8B,EAAAvc,EAAAn1B,KAAA0tE,QAGA,IAAAlvD,EAMA,aAPAxe,KAAA2uE,SAGAnwD,EADAxe,KAAAquE,4BACAruE,KAAAgyE,kBAAA78C,EAAAuc,GAEA1xC,KAAAiyE,mBAAA98C,EAAAuc,GAEAlzB,EAGAje,wBAAA40B,EAAAuc,GACA,MAAAlzB,EAAA,GAEA,IAAA,IAAA6pB,EAAAlT,EAAAkT,EAAAqJ,EAAArJ,IAAA,CACA,MAAA5qC,EAAAuC,KAAAwuE,iBAAAnmC,GACA3pB,QAAA1e,KAAA2uE,OAAAlxE,GACAy0E,GAAAlyE,KAAA+tE,0BAAA/tE,KAAAmyE,yBAAAzzD,GAUA,GATAF,EAAAuiB,KAAA,CACAriB,QAAAA,EACAoX,QAAA,KACA+D,MAAAwO,KAMA6pC,EACA,MAGA,OAAA1zD,EAGAyzD,mBAAA98C,EAAAuc,GACA,MAAAlzB,EAAA,GAEA,IAAA,IAAA6pB,EAAAlT,EAAAkT,EAAAqJ,EAAArJ,IAAA,CACA,MAAA3pB,EAAA1e,KAAAkvE,kBAAAhC,EAAA7kC,GACA7pB,EAAAuiB,KAAA,CACAriB,QAAAA,EACAoX,QAAA,KACA+D,MAAAwO,IAEAroC,KAAA6tE,MAAAb,EAAAoB,kBAAA1vD,IAAA2pB,EAEA,OAAA7pB,EAGA4zD,aAAAC,GACA,OAAAA,EAAAzxE,OAAA,GAAA,EAAAyxE,EAAA,IAAAA,IAGAC,WAAAC,GACA,OAAAvyE,KAAAoyE,aAAApF,EAAA9rB,YAAAqxB,GAAA3wE,eAIAstE,kBAAAhC,EAAA7kC,GACA,MAAAmqC,EAAAxyE,KAAA4tE,IAAA6E,OAAA,GAAAvF,KAAA7kC,KACA3pB,EAAAsuD,EACA0F,gBAAAF,EAAA/0C,WAAA,GACAN,SAAA,OACA,OAAA6vC,EAAAoB,kBAAA,KAAA1vD,KAGA+vD,iBAAA/vD,GACA,MAAA8xD,EAAAxD,EAAAoB,kBAAA1vD,GACA,IAAAmb,EAAA75B,KAAA6tE,MAAA2C,GACA,QAAA,IAAA32C,EACA,IAAA,IAAAwO,EAAA,EAAAA,EAziBA,IAyiBAA,IACA,GAAAmoC,IAAAxwE,KAAAkvE,kBAAAhC,EAAA7kC,GAAA,CACAxO,EAAAwO,EACA,MAKA,QAAA,IAAAxO,EACA,MAAA,IAAAnxB,MAAA,mBAEA,OAAA1I,KAAAwuE,iBAAA30C,GAGA84C,SAAAN,GACA,IAAAO,EAAA,GACAvqC,EAAA,EACA,MAAAwqC,EAAAR,EAAAzxE,OAIA,IAHA,OAAAyxE,EAAAS,UAAA,EAAA,KACAzqC,EAAA,GAEAA,EAAAwqC,EAAAxqC,GAAA,EAAA,CACA,MAAA1mC,EAAAq4B,SAAAq4C,EAAAU,OAAA1qC,EAAA,GAAA,IACAuqC,GAAA/tB,OAAAmuB,aAAArxE,GAGA,OAAAixE,EAGApE,iBAAA30C,GAEA,OAAA75B,KAAAquE,sBAAA,aAAAx0C,SAAA,GAAA75B,KAAAq4B,UAAAwB,IAGAw0C,sBACA,MAAA,qBAAAruE,KAAAq4B,OAGAu2C,cAAAnxE,GACA,OAAAA,EAAA0/B,WAAAt7B,QAAA,KAAA,IAGAtB,+BAAAme,GACA,MAAAu0D,EAAAjzE,KAAAkzE,aACApvE,QAAA6B,OAAAwtE,MAAA,GAAAF,8CAAAv0D,gCACA00D,QAAAtvE,EAAAE,OACA,MAAA,MAAAovE,EAAAtkE,QAAAskE,EAAA3yE,OAAAG,OAAA,EAMAsyE,aACA,OAAA/F,EAAAntE,KAAAuW,UAAA42D,EAAA5gC,SAKAghC,EAAAvnE,KAAAA,EACA7G,EAAAC,QAAAmuE,yjBC/mBA,IAAA5mE,EAAA3G,MAAAA,KAAA2G,kBAAA/H,OAAAgI,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAnI,OAAAqI,eAAAJ,EAAAG,EAAA,CAAAE,YAAA,EAAAhG,IAAA,WAAA,OAAA4F,EAAAC,OACA,SAAAF,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAF,EAAAG,GAAAF,EAAAC,KAEAI,EAAAnH,MAAAA,KAAAmH,cAAA,SAAAL,EAAA1H,GACA,IAAA,IAAAgI,KAAAN,EAAA,YAAAM,GAAAxI,OAAAyI,UAAAC,eAAAC,KAAAnI,EAAAgI,IAAAT,EAAAvH,EAAA0H,EAAAM,IAEAxI,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACA2I,EAAA1I,EAAA,iBAAAW,GACA+H,EAAA1I,EAAA,uBAAAW,GACA+H,EAAA1I,EAAA,eAAAW,GACA+H,EAAA1I,EAAA,6BAAAW,GACA+H,EAAA1I,EAAA,WAAAW,GACA+H,EAAA1I,EAAA,oBAAAW,GACA+H,EAAA1I,EAAA,0BAAAW,GACA+H,EAAA1I,EAAA,wBAAAW,GACA+H,EAAA1I,EAAA,4BAAAW,GACA+H,EAAA1I,EAAA,kBAAAW,GACA+H,EAAA1I,EAAA,YAAAW,yZCtBA,MAAAy/C,EAAApgD,EAAA,UACAquE,EAAAruE,EAAA,UAAAquE,aACAuG,EAAA50E,EAAA,gBACA60E,EAAA70E,EAAA,gBACA80E,EAAA90E,EAAA,kBACA+0E,EAAA/0E,EAAA,sBAAA0B,QACAszE,EAAAh1E,EAAA,mBACAi1E,EAAA,mBAKAC,EAAA,KAGA,MAAAC,UAAA9G,EACA/sE,YAAA8C,EAAA,IACAG,QACAhD,KAAAgG,KAAA0tE,EACA1zE,KAAA6zE,iBACA7zE,KAAAguE,YAAAnrE,GAMAmrE,YAAAnrE,EAAA,IAuBA,OAtBAA,EAAAw1B,SACAr4B,KAAAq4B,OAAAx1B,EAAAw1B,QACAx1B,EAAAixE,QACA9zE,KAAA8zE,MAAAjxE,EAAAixE,OACAjxE,EAAA2b,WACAxe,KAAAwe,SAAA3b,EAAA2b,UACA3b,EAAAkxE,iBACA/zE,KAAA+zE,eAAAlxE,EAAAkxE,gBACAlxE,EAAAmxE,cACAh0E,KAAAg0E,YAAAnxE,EAAAmxE,aACAnxE,EAAAoxE,YACAj0E,KAAAi0E,UAAApxE,EAAAoxE,WACApxE,EAAAmL,OACAhO,KAAA84B,QAAAj2B,EAAAmL,MACAnL,EAAAi2B,UACA94B,KAAA84B,QAAAj2B,EAAAi2B,SACAj2B,EAAA0T,UACAvW,KAAAuW,QAAA1T,EAAA0T,SACA1T,EAAAu2B,OACAp5B,KAAAo5B,KAAAv2B,EAAAu2B,MACAv2B,EAAAqxE,WACAl0E,KAAAk0E,SAAArxE,EAAAqxE,UACAnzE,QAAAC,UAGA63B,UAAAR,GACAr4B,KAAAq4B,OAAAA,EAGAkC,YACA,OAAAx5B,QAAAC,QAAA,CACA8yE,MAAA9zE,KAAA8zE,MACAt1D,SAAAxe,KAAAwe,SACAu1D,eAAA/zE,KAAA+zE,eACAC,YAAAh0E,KAAAg0E,YACAC,UAAAj0E,KAAAi0E,UACAn7C,QAAA94B,KAAA84B,QACA9qB,KAAAhO,KAAAgO,KACAuI,QAAAvW,KAAAuW,QACA6iB,KAAAp5B,KAAAo5B,KACAf,OAAAr4B,KAAAq4B,OACA67C,SAAAl0E,KAAAm0E,WACAn0E,KAAAm0E,WAAAC,eACA,OAMA95D,aACA,QAAAta,KAAAq0E,0BAAAr0E,KAAAm0E,WAUAxF,OAAA2F,GAAA,GACA,OAAA,IAAAvzE,SAAA,CAAAC,EAAAC,KAGAjB,KAAAg0E,aACAh0E,KAAAwe,SAAA5d,OAAA,GAAAZ,KAAAg0E,YAAApzE,QAAAZ,KAAAwe,SAAA5d,QAEAZ,KAAAkrB,eACAjqB,EAAA,IAAAyH,MACA,4EACA,iFAIA1I,KAAAsa,eAAAta,KAAAu0E,eACAvzE,EAAA,iBAGAhB,KAAAw0E,YACA1Z,MAAAgZ,IACAA,IACA9zE,KAAA8zE,MAAAW,SAAAX,EAAAW,SACAz0E,KAAA8zE,MAAA7tD,SAAA6tD,EAAA7tD,SACAjmB,KAAA8zE,MAAAY,SAAAZ,EAAAY,UAAA,MAEA10E,KAAA20E,kBAEA7Z,MAAA8Z,GAGAA,GAAAN,EACAtzE,EAAA,YAEAhB,KAAA60E,aAEA/Z,MAAA,IACA95D,EAAA,cAEA8jC,OAAA3jC,GACAF,EAAA,IAAAyH,MAAAvH,QAMA6tE,YAAAC,EAAA,GACA,OAAA,IAAAluE,SAAA,CAAAC,EAAAC,KA3HA,MA4HAguE,GAGAjvE,KAAAkrB,eACAlqB,EAAA,KACAiuE,GAAA,EAEAhuE,EAAA,6DAGAjB,KAAA2uE,SACA7T,MAAA,IACA96D,KAAA80E,gBAAA7F,EAAAjvE,KAAA2tE,mBAEA7S,MAAAia,IACA,MAAAd,EAAAj0E,KAAAq0E,uBAmBA,OAjBAU,EAAAj2E,SAAA,CAAAk2E,EAAA3sC,KACA,IAAA4sC,GAAA,EACA,IAAA,IAAAC,EAAA,EAAAA,EAAAl1E,KAAAwe,SAAA5d,OAAAs0E,IACAl1E,KAAAwe,SAAA02D,KAAAF,GACAh1E,KAAAg0E,YAAAkB,GAAAjB,YAAAA,GACAj0E,KAAAg0E,YAAAkB,GAAA78C,SAAAr4B,KAAAq4B,SACA48C,GAAA,GAEAA,IACAj1E,KAAAwe,SAAAuiB,KAAAi0C,GACAh1E,KAAA+zE,eAAAhzC,KAAA/gC,KAAA2tE,gBAAAtlC,GACAroC,KAAAg0E,YAAAjzC,KAAA,CACAkzC,UAAAA,EACA57C,OAAAr4B,KAAAq4B,aAIAr3B,EAAAhB,KAAAwe,aAEAsmB,OAAA3jC,GACAF,EAAA,IAAAyH,MAAAvH,QAOAmd,cACA,OAAAvd,QAAAC,QAAAhB,KAAAwe,SAAAxe,KAAAwe,SAAAxW,QAAA,GAAAA,SAGA4Y,gBAAAlC,EAAAgZ,GACA,OAAA,IAAA32B,SAAA,CAAAC,EAAAC,KACAjB,KAAAm1E,eAAAz2D,GACAo8C,MAAAsa,IACA,IAIA,MAAAC,EAAAr1E,KAAA+zE,eAAAqB,GACAE,EAAAt1E,KAAAg0E,YAAAoB,GAAA/8C,OACAu3C,EAAA,CACA5xE,QAAA,KAAAgC,KAAAu1E,sBAAA79C,GAAAyF,SAAA,UAAA,EACAqS,MAAA,KAAA9X,EAAA8X,MAAArS,SAAA,UAAA,EACAi3B,SAAA,KAAA18B,EAAA08B,SAAAj3B,SAAA,SACAuU,GAAAha,EAAAga,GAAAha,EAAAga,GAAAvU,SAAA,OAAA,KACA3+B,MAAA,KAAAk5B,EAAAl5B,MAAA2+B,SAAA,SACA39B,KAAA,IAAAk4B,EAAAl4B,KAAAoB,OAAA,KAAA,KAAA82B,EAAAl4B,KAAA29B,SAAA,SACAq4C,WAAAx1E,KAAAy1E,kBAAAH,EAAAD,IAEA,OAAA39C,EAAAg+C,OACA,KAAA,EACA,GAAA,OAAAh+C,EAAAwzB,sBAAA,OAAAxzB,EAAAuzB,cACAvzB,EAAAwzB,uBAAA1qD,WAAAk3B,EAAAuzB,eAAAzqD,UACA,MAAA,IAAAkI,MAAA,wFACAknE,EAAA1kB,qBAAA,KAAAxzB,EAAAwzB,qBAAA/tB,SAAA,SACAyyC,EAAA3kB,aAAA,KAAAvzB,EAAAuzB,aAAA9tB,SAAA,SACAyyC,EAAA+F,WAAAj+C,EAAAi+C,YAAA,GACA/F,EAAA5pE,KAAA,EACA,MACA,KAAA,EACA4pE,EAAA+F,WAAAj+C,EAAAi+C,YAAA,GACA/F,EAAAh+B,SAAA,KAAAla,EAAAka,SAAAzU,SAAA,SACAyyC,EAAA5pE,KAAA,EACA,MACA,QACA4pE,EAAAh+B,SAAA,KAAAla,EAAAka,SAAAzU,SAAA,SACAyyC,EAAA5pE,KAAA,KAMA,MAAA4vE,EAAA51E,KAAAm0E,WAAA0B,UAAA,GAAA,GACA71E,KAAAm0E,WAAA0B,UAAA,GAAA,GAcA,OAbAD,GAAA,IAAAhG,EAAA5pE,MACA4pE,EAAAh+B,SAAAg+B,EAAA3kB,aACA2kB,EAAAkG,gBAAA,SACAlG,EAAA5pE,YACA4pE,EAAA3kB,oBACA2kB,EAAA1kB,4BACA0kB,EAAA+F,YACAC,GAAA,IAAAhG,EAAA5pE,OACA4pE,EAAAkG,gBAAA,SACAlG,EAAA5pE,YACA4pE,EAAA+F,YAGA31E,KAAA+1E,YAAAnG,GACA,MAAAzuE,GACA,MAAA,IAAAuH,MAAA,oCAGAoyD,MAAAkb,IAEA,KAAAA,EAAAzF,KAAAyF,EAAAzF,IAAAp7B,GAAA6gC,EAAAzF,IAAA5X,GAAAqd,EAAAzF,IAAA3X,GACA,OAAA33D,EAAA,IAAAyH,MAAA,2BACA,MAAAutE,EAAAv+C,EAAAm4C,SACA16B,EAAA,IAAA6gC,EAAAzF,IAAAp7B,EAAAv0C,OAAA,IAAAo1E,EAAAzF,IAAAp7B,EAAAhY,SAAA,OAeA,IAAA+4C,EAdAD,EAAAtd,EAAA8a,EAAAhiC,aAAAukC,EAAAzF,IAAA5X,EAAAx7B,SAAA,QACA84C,EAAArd,EAAA6a,EAAAhiC,aAAAukC,EAAAzF,IAAA3X,EAAAz7B,SAAA,QACA84C,EAAA9gC,EAAAs+B,EAAAhiC,aAAA0D,IAEA,IAAA6gC,EAAAF,gBAEAG,EAAAjwE,KAAA,EACAiwE,EAAArkC,SAAAokC,EAAApkC,UAGAqkC,EAAAjwE,KAAAgwE,EAAAhwE,KAKA,MAAAmwE,EAAA,KAAAn2E,KAAAu1E,sBAAA79C,GAAAyF,SAAA,SACAn/B,EAAA,IAAAq1E,EAAA8C,GAAAC,WACAC,EAAA7C,EAAA1gB,eAAA,UAAA,CACA9kD,KAAA,aACA4kD,UAAA50D,EACAA,QAAAA,GACA,UAKA,OAHAk4E,EAAA3C,EAAArb,mBAAAC,WAAA8d,EAAA,CACAle,OAAAse,EAAAvG,OAAAlxE,OAAAmxE,SAAAr4C,KAEA12B,EAAAk1E,MAEApxC,OAAA3jC,GACAF,EAAA,IAAAyH,MAAAvH,SAKAuuB,oBAAAhR,EAAAke,GACA,OAAA58B,KAAAwvB,YAAA9Q,EAAA,CAAAskB,QAAApG,EAAA05C,SAAA,iBAGAC,cAAA73D,EAAAke,EAAA/5B,GACA,GAAAA,EAAAiF,SAAA,OAAAjF,EAAAiF,SAAA,OAAAjF,EAAAiF,QACA,MAAA,IAAAY,MAAA,6EAAA7F,EAAAiF,WACA,OAAA9H,KAAAwvB,YAAA9Q,EAAA,CAAAskB,QAAApG,EAAA05C,SAAA,WAGA9mD,YAAA9Q,EAAAke,GACA,OAAA,IAAA77B,SAAA,CAAAC,EAAAC,KACAjB,KAAAm1E,eAAAz2D,GACAo8C,MAAAsa,IACA,IAAApyC,QAAAA,EAAAszC,SAAAA,GAAA15C,EAEAoG,GAAAszC,IACAtzC,EAAApG,EACA05C,EAAA,gBAEA,MAAAjB,EAAAr1E,KAAA+zE,eAAAqB,GACAE,EAAAt1E,KAAAg0E,YAAAoB,GAAA/8C,OACAwD,EAAA,CACA4pB,SAAA,UACAjmD,KAAA,CACA82E,SAAAA,EACAtzC,QAAAA,EACAwyC,WAAAx1E,KAAAy1E,kBAAAH,EAAAD,KAGAr1E,KAAAm0E,WAAAqC,KAAA36C,GAAA,CAAA16B,EAAA+8B,KACA,GAAA/8B,EACA,OAAAF,EAAA,IAAAyH,MAAAvH,IAEA,IAAAnB,KAAAy2E,wBACA,OAAAx1E,EAAA,qBAEA,IAAAi9B,EAAAqyC,IACA,OAAAtvE,EAAA,IAAAyH,MAAA,0BAGA,IACA,IAAAysC,EAAAjX,EAAAqyC,IAAAp7B,EAAAhY,SAAA,OAIA,OAHAgY,EAAAv0C,OAAA,IACAu0C,EAAA,IAAAA,KAEAn0C,EAAA,KAAAk9B,EAAAqyC,IAAA5X,IAAAz6B,EAAAqyC,IAAA3X,IAAAzjB,KACA,MAAAh0C,GACA,OAAAF,EAAA,IAAAyH,MAAA,8CAIAo8B,OAAA3jC,GACAF,EAAA,IAAAyH,MAAAvH,SAKA0tB,cAAAnQ,GACA,OAAA3d,QAAAE,OAAAyH,MAAA,+CAGAqiB,cAAArM,GACA1e,KAAAwe,SAAA1f,SAAA,CAAAkxC,EAAA3H,KACA,GAAA2H,EAAApuC,gBAAA8c,EAAA9c,cAIA,OAHA5B,KAAAwe,SAAA+yB,OAAAlJ,EAAA,GACAroC,KAAA+zE,eAAAxiC,OAAAlJ,EAAA,QACAroC,KAAAg0E,YAAAziC,OAAAlJ,EAAA,MAMA9O,eASA,OAFAv5B,KAAAu0E,gBAAA,EACAv0E,KAAAo5B,KAAA,EACAp5B,KAAA02E,SAAA,GAGAp9C,cACA,OAAAt5B,KAAA02E,SAAA,GAGAr9C,kBACA,OAAAr5B,KAAA02E,UAAA,GAGAx8C,mBAAAL,GACA75B,KAAA2tE,gBAAA3zC,SAAAH,EAAA,IAGA3O,eACAlrB,KAAA6zE,iBAQAsB,eAAAz2D,GACA,OAAA,IAAA3d,SAAA,CAAAC,EAAAC,KAGAjB,KAAA2uE,QAAA,GACA7T,MAAA,IACA96D,KAAA22E,4BAEA7b,MAAA,IACA96D,KAAAse,gBAEAw8C,MAAAia,IAGA,IAAAK,EAAA,KAKA,OAJAL,EAAAj2E,SAAA,CAAAk2E,EAAA3sC,KACA3pB,EAAA9c,gBAAAozE,EAAApzE,gBACAwzE,EAAA/sC,MAEA,OAAA+sC,EACAn0E,EAAA,sBAEAD,EAAAo0E,MAEAtwC,OAAA3jC,GACAF,EAAAE,QAKAs0E,kBAAAp9C,EAAAu+C,EAAA,GACA,MAAAn5E,EAAA46B,EAAAr2B,MAAA,KAAAgG,MAAA,GACA6uE,EAAA,GACA,IAAAC,GAAA,EAwBA,GAvBAr5E,EAAAqB,SAAAi4E,IACA,MAAAC,EAAA,MAAAD,EAAAA,EAAAn2E,OAAA,GACA,IAAAq2E,EAAAD,EAlaA,WAkaA,EAKAD,EAAA5/C,QAAA,MAAA,GACA8/C,GAAAL,EACAE,GAAA,GAEAG,GAAAlmC,OADAimC,EACAD,EAAA/uE,MAAA,EAAA+uE,EAAAn2E,OAAA,GAEAm2E,GAEAF,EAAA91C,KAAAk2C,OAIA,IAAAH,GACAD,EAAA91C,KAAA61C,GAGAC,EAAAj2E,OAAA,EACA,MAAA,IAAA8H,MAAA,mDACA,OAAAmuE,EAGAhD,iBACA7zE,KAAAwe,SAAA,GACAxe,KAAA+zE,eAAA,GACA/zE,KAAAg0E,YAAA,GACAh0E,KAAAk3E,UAAA,EACAl3E,KAAA8zE,MAAA,CACAW,SAAA,KACAxuD,SAAA,KACAyuD,SAAA,MAEA10E,KAAAi0E,UAAA,KACAj0E,KAAAm0E,WAAA,KACAn0E,KAAAo5B,KAAA,EACAp5B,KAAA2tE,gBAAA,EACA3tE,KAAAuW,QAAA,KACAvW,KAAAq4B,OAxcA,mBA2cA8+C,kBAAAx5E,GACA,OAAA,IAAAoD,SAAA,CAAAC,EAAAC,KACA,MAAAm2E,EAAAzxE,OAAAy/B,KAAAznC,GAGA,OAAAy5E,EACAp2E,EAAA,CAAAq2E,SAAAD,IACAvqB,SAAAA,QAAAx+C,MAAAw+C,QAAAx+C,KAAAzH,YAKAimD,QAAAx+C,KAAAzH,OAAA,CAAAjJ,IAAAA,IACAm9D,MAAA76B,GACAj/B,EAAA,CAAAs2E,QAAAr3C,MAEA6E,OAAA3jC,GACAF,EAAA,IAAAyH,MAAA,wCAGAzH,EAAA,IAAAyH,MAAA,+DAMA6uE,aAAAtyE,GACA,OAAA,IAAAlE,SAAA,CAAAC,EAAAC,KACA4rD,QAAAx+C,KAAA4vB,MAAA,IACA68B,MAAAzsD,IACAA,EAAAvP,SAAAmhC,IACA,GAAAA,EAAAh7B,KAAAA,EACA,OAAAjE,EAAAi/B,MAGAj/B,EAAA,SAEA8jC,OAAA3jC,GACAF,EAAAE,QAKAqzE,YACA,OAAA,IAAAzzE,SAAA,CAAAC,EAAAC,KAEA,GAAAjB,KAAAw3E,cAAAx3E,KAAAu0E,eACA,OAAAvzE,IAEAhB,KAAAu0E,gBAAA,EAIA,MAAAvmE,EAAAhO,KAAA84B,QAAA94B,KAAA84B,QAAA,UACA2+C,EAAA,8BACA95E,EAAA,GAAA85E,aAAAzpE,oBACA,IAAA0pE,EAGA,SAAAC,EAAAv0D,GAEA,GAAAA,EAAAyD,SAAA4wD,EAEA,IAEAj0B,cAAAk0B,GAEA,MAAA5D,EAAA72C,KAAAC,MAAA9Z,EAAA5jB,MACA,OAAAs0E,EAAAW,UAAAX,EAAA7tD,SAEAjlB,EAAA8yE,GADA7yE,EAAA,IAAAyH,MAAA,+CAEA,MAAAvH,GACA,OAAAF,EAAAE,IAKAnB,KAAAm3E,kBAAAx5E,GACAm9D,MAAA73B,IACA,GAAAA,EAAAo0C,SAEA1xE,OAAAmsE,iBAAA,UAAA6F,GAAA,GAEAD,EAAAj0B,aAAA,KACA,GAAAxgB,EAAAo0C,SAAAO,OAEA,OADAp0B,cAAAk0B,GACAz2E,EAAA,IAAAyH,MAAA,gCAEA,UACA,GAAAu6B,EAAAq0C,QAAA,CAOA,MAAAO,EAAA,eACAH,EAAAj0B,aAAA,KACAzjD,KAAAu3E,aAAAt0C,EAAAq0C,QAAAryE,IACA61D,MAAA76B,IACA,IAAAA,IAAAA,EAAAtiC,IACA,OAAAsD,EAAA,IAAAyH,MAAA,8BAGA,MAAAovE,EAAA73C,EAAAtiC,IAAAw5B,QAAA0gD,GACA,GAAAC,EAAA,EACA,OACA,MAAAC,EAAAD,EAAAD,EAAAj3E,OAEA4iD,cAAAk0B,GACA,IAGA,MAAAM,EAAA9iD,EAAAC,KAAA8K,EAAAtiC,IAAAqK,MAAA+vE,GAAA,UAAA56C,WAEA0vB,QAAAx+C,KAAAZ,OAAAwyB,EAAAh7B,IACA61D,MAAA,KACA,MAAAgZ,EAAA72C,KAAAC,MAAA86C,GACA,OAAAlE,EAAAW,UAAAX,EAAA7tD,SAEAjlB,EAAA8yE,GADA7yE,EAAA,IAAAyH,MAAA,kDAGA,MAAAvH,GACA,OAAAF,EAAA,kEAGA,YASA4zE,WACA,OAAA,IAAA9zE,SAAA,CAAAC,EAAAC,KAIAjB,KAAAm0E,WAAAhuC,QArlBA,IAslBAnmC,KAAAm0E,WAAA8D,QAAAj4E,KAAA8zE,MAAAW,UAAAtzE,IACAnB,KAAAm0E,WAAAhuC,QAAAwtC,EACAxyE,EACAF,EAAAE,GAEAnB,KAAAy2E,wBAGAz1E,IAFAC,EAAA,2BAOA0zE,eACA,OAAA,IAAA5zE,SAAA,CAAAC,EAAAC,KACA,GAAAjB,KAAAsa,aACA,OAAAtZ,IAEA,IACA,IAGAk3E,EAHAv6E,EAAA,4BAuBA,OAtBAqC,KAAA8zE,MAAAY,WACA/2E,EAAAqC,KAAA8zE,MAAAY,UAIAwD,EAFAl4E,KAAAk0E,SAEA,CACAiE,UAAAn4E,KAAAk0E,UAKA,CACAlmE,KAAAhO,KAAA84B,QACAs/C,QAAAz6E,EACAwoC,QAAAwtC,EACA0E,QAAAr4E,KAAAs4E,iBACA/hE,QAAAvW,KAAAuW,SAGAvW,KAAAm0E,WAAA,IAAAb,EAAAiF,OAAAL,GAGAl3E,IAAAk3E,EAAAC,WACA,MAAAh3E,GACA,OAAAF,EAAAE,OAKA2zE,gBAAA7F,EAAA,EAAA5mC,EAAA,EAAAmwC,EAAA,IACA,OAAA,IAAAz3E,SAAA,CAAAC,EAAAC,KACA,IAAAjB,KAAAsa,aACA,OAAArZ,EAAA,qDAEAjB,KAAAy4E,iBAAAxJ,EAAA5mC,GAAA,CAAAlnC,EAAA4zE,IACA5zE,EACAF,EAAAE,GAEAH,EAAA+zE,QAKA0D,iBAAAxJ,EAAA,EAAA5mC,EAAA,EAAA5sB,EAAA+8D,EAAA,IAIA,GAAA,IAAAvJ,EACA,OAAAxzD,EAAA,KAAA+8D,GACA,MAAAE,EAAA14E,KAAA24E,2BAGAC,EAAA,CACAnzB,SAAA,MACAozB,UAAA74E,KAAAy1E,kBAAAz1E,KAAAq4B,OAAAgQ,GACA4mC,EAAAyJ,EAAA,EAAAzJ,EACA6J,WAAA,GAEA94E,KAAAm0E,WAAA4E,aAAAH,GAAA,CAAAz3E,EAAA4zE,IACA5zE,EACAsa,EAAAta,GACAnB,KAAAy2E,wBAIA1B,EAAAn0E,OAAA,EACA6a,EAAA,IAAA/S,MAAA,0BAGAgwE,EACA14E,KAAAy4E,iBAAAxJ,EAAA,EAAA5mC,EAAA,EAAA5sB,EAAA+8D,EAAA9+C,OAAAq7C,IAEAt5D,EAAA,KAAAs5D,GAVAt5D,EAAA,IAAA/S,MAAA,wBAeAqtE,YAAAnG,GACA,OAAA,IAAA7uE,SAAA,CAAAC,EAAAC,KACAjB,KAAAm0E,WAAAqC,KAAA,CAAA/wB,SAAA,MAAAjmD,KAAAowE,IAAA,CAAAzuE,EAAA+8B,IACA/8B,EACAF,EAAAE,GAEAnB,KAAAy2E,wBAGAv4C,EAAAxG,IAKAwG,EAAAl4B,KAAA4pE,EAAA5pE,KACA4pE,EAAAkG,iBACA53C,EAAA43C,gBAAA,EACA53C,EAAA0T,SAAAg+B,EAAAh+B,UAGA5wC,EAAAk9B,IAVAj9B,EAAA,IAAAyH,MAAA,qCAHAzH,EAAA,0BAkBAy1E,SAAA3E,EAAA,GACA,OAAA,IAAAhxE,SAAA,CAAAC,EAAAC,KACAjB,KAAAo5B,MAAA24C,EACA/xE,KAAAo5B,KAAA,IACAp5B,KAAAo5B,KAAA,GACA,MAAAxc,EAztBA,EAytBA5c,KAAAo5B,KAEAp5B,KAAA2uE,SACA7T,MAAA,IACA96D,KAAA80E,gBA7tBA,EA6tBAl4D,KAEAk+C,MAAAia,IACA,MAAAv2D,EAAA,GAQA,OAPAu2D,EAAAj2E,SAAA,CAAA4f,EAAA2pB,KACA7pB,EAAAuiB,KAAA,CACAriB,QAAAA,EACAoX,QAAA,KACA+D,MAAAjd,EAAAyrB,OAGArnC,EAAAwd,MAEAsmB,OAAA3jC,GACAF,EAAAE,QAKAq2E,YACA,OAAA,OAAAx3E,KAAA8zE,MAAAW,UAAA,OAAAz0E,KAAA8zE,MAAA7tD,UAAAjmB,KAAA84B,QAGAw/C,iBAGA,GAFAt4E,KAAAgO,OAAAhO,KAAA84B,UACA94B,KAAA84B,QAAA94B,KAAAgO,OACAhO,KAAAw3E,YACA,MAAA,IAAA9uE,MAAA,gDACA,MAAA6pE,EAAAr9C,EAAAwE,OAAA,CACAxE,EAAAC,KAAAn1B,KAAA8zE,MAAA7tD,UACAiP,EAAAC,KAAAn1B,KAAA8zE,MAAAW,UACAv/C,EAAAC,KAAAn1B,KAAA84B,WAEA,OAAA+lB,EAAAm6B,WAAA,UAAA1qE,OAAAikE,GAAA0G,SAOAN,2BACA,MAAAl7E,EAAAuC,KAAAq4B,OAAAr2B,MAAA,KAAAgG,MAAA,GACA,IAAA,IAAAqgC,EAAA,EAAAA,EAAA5qC,EAAAmD,OAAA,EAAAynC,IACA,GAAA5qC,EAAA4qC,GAAAlR,QAAA,MAAA,EACA,OAAA,EAEA,OAAA,EAKAo+C,sBAAA79C,GACA,MAAA,mBAAAA,EAAAzd,WACAyd,EAAAzd,aACAyd,EAAAqgC,QAAA,mBAAArgC,EAAAqgC,OAAAmhB,UACAxhD,EAAAqgC,OAAAmhB,YAAA/7C,SAAA,IACA,iBAAAzF,EAAA15B,QACA05B,EAAA15B,QAAAm/B,SAAA,IACA,iBAAAzF,EAAA15B,QACA05B,EAAA15B,QACA,IAGAq2E,uBACA,OAAAr0E,KAAAi0E,WAAA,KASAwC,wBACA,IAAAz2E,KAAAm0E,WACA,OAAA,KAEA,MAAAgF,EAAAn5E,KAAAm0E,WAAAiF,kBACA,IAAAD,IAAAA,EAAAE,IACA,OAAA,KAEA,MAAAC,EAAAH,EAAAE,IAAAl8C,SAAA,OAMA,OAHAm8C,GAAAt5E,KAAAi0E,YACAj0E,KAAAi0E,UAAAqF,GAEAt5E,KAAAi0E,UAKA0C,0BACA,OAAA,IAAA51E,SAAA,CAAAC,EAAAC,KACA,GAAAjB,KAAAq0E,uBACA,OAAArzE,IAEAhB,KAAA2uE,SACA7T,MAAA,IACA96D,KAAAq0E,uBACArzE,IAEAC,EAAA,yDAGA6jC,OAAA3jC,GACAF,EAAAE,SAOAyyE,EAAA5tE,KAAA0tE,EACAv0E,EAAAC,QAAAw0E,2UCv1BA,IAAA9oC,EAAA9qC,MAAAA,KAAA8qC,iBAAA,SAAAC,GACA,OAAAA,GAAAA,EAAAC,WAAAD,EAAA,CAAA5qC,QAAA4qC,IAEAnsC,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IAEAC,EAAA,oBACA,MAAA86E,EAAAzuC,EAAArsC,EAAA,kCACAW,EAAAe,QAAAo5E,EAAAp5E,2wBCRA4sD,EAAAtuD,EAAA,UACAmR,EAAAnR,EAAA,uBACAuuD,EAAAvuD,EAAA,gBACAixD,EAAAjxD,EAAA,UACAoB,EAAAD,EAAAnB,EAAA,aACA0S,EAAA1S,EAAA,qCAIA4T,EAAA5T,EAAA,yCACA2S,EAAA3S,EAAA,8CACA+6E,EAAA/6E,EAAA,kmBAEe,MAiBbsB,YAAY8C,EAAO,IACjB,MAAMyR,EAASxR,EAAA,CACbhF,sBAAuB,GACvB27E,YAAY,EACZC,eAAe,EACfp7C,gBAAgB,EAChBq7C,2BAA2B,EAI3Bn+D,mBAAmB,EACnBo+D,yBAAyB,EACzBC,gBAAgB,EAChBlf,eAAgB,KAMhBjuB,aAAc,CACZ8c,0BAA0B,GAE5BswB,gBAAiB,GACjB/jD,cAAelzB,EAAIwT,aACnBwH,WAAY,GACZk8D,eAAgB,GAChBC,mBAAmB,EACnBv6D,YAAa,CACX6uB,kBAAmB9tC,UACnBy5E,oBAAoB,EACpBr+B,kBAAkB,EAClBs+B,oCAAoC,EACpCC,uBAAuB,GAGzBhsE,YAAagD,EAAAipE,yBACbC,cAAe,KACf9gC,oBAAqB5zC,OAAMszC,UAANC,IACjB9nC,EAAA+nC,uBAAAC,OACAhoC,EAAA+nC,uBAAAE,KACDx2C,EAAIyR,WAGTtU,KAAAuW,QAAe1T,EAAI0T,QACnBvW,KAAA0lE,eAAsB,IAAIhW,EAAAc,OAAAmV,UAAAC,aAA8B/iE,EAAIkK,UAC5D/M,KAAA8U,MAAa,IAAIlF,EAAAwZ,gBAAgB9U,GACjCtU,KAAA8U,MAAAwlE,gBAA2B,IAC3Bt6E,KAAAsW,UAAiBzT,EAAIyT,UACrBtW,KAAAwW,wBAA+B3T,EAAI2T,wBAEnCxW,KAAAu6E,iCAEAlwC,OAAMnd,cAAiB,CAAAnuB,EAAAP,IACdwB,KAAAitB,eAAoBluB,EAAKP,GAUpC2/B,qBAAoB67C,GAClBh6E,KAAA8U,MAAAo2B,YAAuB,CAAE8uC,kBAAAA,IAQ3BjwD,cAAaywD,GACXx6E,KAAA8U,MAAAo2B,YAAuB,CAAEuuC,WAAYe,IAQvCxwD,iBAAgBwwD,GACdx6E,KAAA8U,MAAAo2B,YAAuB,CAAEwuC,cAAec,IAQ1CvwD,kBAAiBuwD,GACfx6E,KAAA8U,MAAAo2B,YAAuB,CAAE5M,eAAgBk8C,IAQ3CtwD,qBAAoBswD,GAClBx6E,KAAA8U,MAAAo2B,YAAuB,CAAE1vB,kBAAmBg/D,IAQ9CrwD,2BAA0ByvD,GACxB55E,KAAA8U,MAAAo2B,YAAuB,CAAE0uC,wBAAAA,IAQ3BxvD,kBAAiByvD,GACf75E,KAAA8U,MAAAo2B,YAAuB,CACrB2uC,eAAAA,IASJxsD,kBAAiBmtD,GACfx6E,KAAA8U,MAAAo2B,YAAuB,CAAEyvB,eAAgB6f,IAQ3CltD,oBAAmBktD,GACjBx6E,KAAA8U,MAAAo2B,YAAuB,CAAEqpB,iBAAkBimB,IAS7CrtD,mBAAkBstD,EAAAC,GAChB,MAAMZ,mBAAsB95E,KAAA8U,MAAAyG,WAC5Bu+D,EAAgBW,GAAkBC,EAClC16E,KAAA8U,MAAAo2B,YAAuB,CAAE4uC,gBAAAA,IAQ3BvvD,iBAAgBxrB,GACd,MAAM47E,EAAgB,CAAC,KAAM,KAAM,KAAM,KAAM,MAAzBzsE,SAAwCnP,GAC1D,MACA,OAKJ,OAJAiB,KAAA8U,MAAAo2B,YAAuB,CACrBnV,cAAeh3B,EACf47E,cAAAA,IAEKA,EAST9lD,aAAYD,GACV,MAAMgmD,EAAgB56E,KAAA8U,MAAAyG,WAAAsC,WAEhBA,EAAa+W,EAASkC,QAAQ,CAAA+jD,EAAAn8D,EAAAmb,KAClC,MAAMihD,EAAQF,EAAcl8D,IAAY,GAExC,OADAm8D,EAAIn8D,GAAJ5b,EAAA,CAAiBkL,KAAO,WAAU6rB,EAAQ,IAAKnb,QAAAA,GAAYo8D,GACpDD,IACN,IAEH76E,KAAA8U,MAAAo2B,YAAuB,CAAErtB,WAAAA,IAS3B0d,cAAa7c,GACX,MAAMb,cAAiB7d,KAAA8U,MAAAyG,WAEvB,IAAKsC,EAAWa,GACd,MAAM,IAAIhW,MAAO,GAAEgW,6CAOrB,UALOb,EAAWa,GAClB1e,KAAA8U,MAAAo2B,YAAuB,CAAErtB,WAAAA,IAIrBa,IAAY1e,KAAAgoB,qBAA2B,CACzC,MAAM+yD,EAAWn8E,OAAM+B,KAAMkd,GAAY,GACzC7d,KAAAysB,mBAAwBsuD,GAE1B,OAAOr8D,EAQTs8D,aAAYpmD,GACV,MAAM/W,cAAiB7d,KAAA8U,MAAAyG,WACvBqZ,EAAS91B,SAAU4f,IAEjB,GAAIb,EAAWa,GACb,OAGF,MAAMu8D,EAAgBr8E,OAAM+B,KAAMkd,GAAZjd,OAEtBid,EAAWa,GAAW,CAAE1Q,KAAO,WAAUitE,EAAgB,IAAKv8D,QAAAA,MAEhE1e,KAAA8U,MAAAo2B,YAAuB,CAAErtB,WAAAA,IAU3BwlB,cAAazO,GACX,IAAK6F,MAAKuS,QAASpY,IAAmC,IAArBA,EAASh0B,OACxC,MAAM,IAAI8H,MAAM,uDAGlB,MAAMmV,+BAAiC7d,KAAA8U,MAAAyG,WAEjC2/D,EAAY,GAClBt8E,OAAM+B,KAAMkd,GAAZ/e,SAAiCwtC,IAC1B1X,EAAS1mB,SAAUo+B,KACtB4uC,EAAU5uC,GAAYzuB,EAAWyuB,UAC1BzuB,EAAWyuB,OAKlB1tC,OAAM+B,KAAMu6E,GAAZt6E,OAAgC,GAElChC,OAAM+B,KAAMu6E,GAAZp8E,SAAgCC,IAC9Bg7E,EAAeh7E,GAAOm8E,EAAUn8E,MAIpCiB,KAAA8U,MAAAo2B,YAAuB,CAAErtB,WAAAA,EAAYk8D,eAAAA,IACrC/5E,KAAAg7E,aAAkBpmD,GAIlB,IAAImmD,EAAW/6E,KAAAgoB,qBAMf,OALK4M,EAAS1mB,SAAU6sE,KACtBA,EAAWnmD,EAAU,GACrB50B,KAAAysB,mBAAwBsuD,IAGnBA,EAQTtuD,mBAAkB0uD,GAChB,MAAMz8D,GAAU,EAAAsuC,EAAAouB,WAAiBD,IAE3Bt9D,cAAiB7d,KAAA8U,MAAAyG,WACjB8/D,EAAmBx9D,EAAWa,GACpC,IAAK28D,EACH,MAAM,IAAI3yE,MAAO,iBAAgBgW,eAGnC28D,EAAgBC,aAAgBr2C,KAAIC,MACpCllC,KAAA8U,MAAAo2B,YAAuB,CAAErtB,WAAAA,EAAYwJ,gBAAiB3I,IAQxDsJ,qBACE,OAAOhoB,KAAA8U,MAAAyG,WAAA8L,gBAUT2F,gBAAegjB,EAAA5V,GACb,IAAK4V,EACH,MAAM,IAAItnC,MACP,iDAAgDm8C,OAAO7U,MAG5D,MAAMtxB,GAAU,EAAAsuC,EAAAouB,WAAiBprC,IAC3BnyB,cAAiB7d,KAAA8U,MAAAyG,WAIvB,OAHAsC,EAAWa,GAAWb,EAAWa,IAAY,GAC7Cb,EAAWa,GAAX1Q,KAA2BosB,EAC3Bp6B,KAAA8U,MAAAo2B,YAAuB,CAAErtB,WAAAA,IAClB9c,QAAOC,QAASo5B,GAaV75B,gBAAAg7E,GACb,MAAMC,EAAUx7E,KAAA6hB,2BACVgY,EAAQ2hD,EAAOnqC,WAAYoqC,GACxBA,EAAO19E,SAAYw9E,EAAax9E,SAEzC,GAAI87B,GAAS,EAAG,CACd,MAAM6hD,EAAYF,EAAQ3hD,GACpB8hD,EAAU74E,EAAAA,EAAA,GAAQ44E,GAAcH,GACtC,GAAIG,EAAS19E,UAAa29E,EAAU39E,QAAU,CAM5C,IAAI49E,EAAiBF,EAAS19E,QAC9B,IAAK49E,EAEH,IACEA,QAAuB57E,KAAA0lE,eAAAmW,KAAyB,gBAChD,EAAA9uB,EAAAS,QAAiC,iBAAnBouB,GACd,MAAAt7E,GACAT,EAAAM,QAAA8D,MAAU3D,GACVT,EAAAM,QAAA6O,KACG,gCAA+B0sE,EAAS39E,2CAS/C,IAAIomC,GAAY,EAChB,MAAM23C,EAA4Bl9E,OAAM64B,OACtCtmB,EAAAw/B,wBADgCjvC,KAE3Bm5E,GAAQA,EAAGjoB,YACZmpB,EAAkBP,EAAOnzE,QAC5Bg8B,GAAUA,EAAKtmC,SAAYw9E,EAAax9E,UAGzC+9E,EAAyB5tE,SAAU0tE,IACnCG,EAAensC,MAAOvL,GAAUA,EAAKrmC,UAAa49E,OAElDz3C,GAAY,GAGdnkC,KAAAwW,wBACEolE,EACAD,EAAU39E,QACVmmC,GAGJq3C,EAAQ3hD,GAAS8hD,EACjB37E,KAAA8U,MAAAo2B,YAAuB,CAAEptC,sBAAuB09E,QAC3C,CACL,MAAMz9E,gDAKJI,EAAW,IACTo9E,EACJv7E,KAAAkiC,qBAA0BnkC,EAAQC,EAASC,EAAQC,EAAUC,IAajE+jC,qBAAoBnkC,EAAAC,EAGlBC,EAAS,MACTC,EAAW,GACXC,EAAW,IAEX,MAAMq9E,EAAUx7E,KAAA6hB,2BAEVgY,EAAQ2hD,EAAOnqC,WAAYoqC,GACxBA,EAAO19E,SAAYA,IAM5B,IAJe,IAAX87B,GACF2hD,EAAOjqC,OAAQ1X,EAAO,KAGnB,EAAAxnB,EAAA2pE,8BAA6Bh+E,GAChC,MAAM,IAAI0K,MAAO,qBAAoB1K,MAGvCw9E,EAAOz6C,KAAM,CAAEhjC,OAAAA,EAAQC,QAAAA,EAASC,OAAAA,EAAQC,SAAAA,EAAUC,SAAAA,IAClD6B,KAAA8U,MAAAo2B,YAAuB,CAAEptC,sBAAuB09E,IASlDh3C,0BAAyB7mC,GACvB,MAAM69E,EAAUx7E,KAAA6hB,2BACVgY,EAAQ2hD,EAAOnqC,WAAYoqC,GACxBA,EAAO19E,SAAYJ,IAM5B,OAJe,IAAXk8B,GACF2hD,EAAOjqC,OAAQ1X,EAAO,GAExB75B,KAAA8U,MAAAo2B,YAAuB,CAAEptC,sBAAuB09E,IACzCz6E,QAAOC,QAASw6E,GAQzB35D,2BACE,OAAO7hB,KAAA8U,MAAAyG,WAAAzd,sBAUTmvB,eAAcgvD,EAAAC,GACZ,MACMC,EAAmBr5E,EAAAA,EAAA,GADG9C,KAAA8U,MAAAyG,WAAAmxB,cACH,GAAA,CAEvBuvC,CAACA,GAAUC,IAKb,OAFAl8E,KAAA8U,MAAAo2B,YAAuB,CAAEwB,aAAcyvC,IAEhCp7E,QAAOC,QAASm7E,GAWzBjvD,cAAakvD,EAAA59E,GACX,MACM69E,EAAkBv5E,EAAAA,EAAA,GADG9C,KAAAs8E,kBACH,GAAA,CAEtBF,CAACA,GAAa59E,IAIhB,OADAwB,KAAA8U,MAAAo2B,YAAuB,CAAEzrB,YAAa48D,IAC/Bt7E,QAAOC,QAASq7E,GAQzBC,iBACE,OAAOt8E,KAAA8U,MAAAyG,WAAAkE,YAQTrR,iBACE,OAAOpO,KAAA8U,MAAAyG,WAAApN,YASTkc,eAAc8jC,GAEZ,OADAnuD,KAAA8U,MAAAo2B,YAAuB,CAAE/8B,YAAaggD,IAC/BptD,QAAOC,QAASmtD,GASzB9iC,6BAA4BkuB,GAE1B,OADAv5C,KAAA8U,MAAAo2B,YAAuB,CAAEqO,oBAAAA,IAClBA,EAQT3jB,+BACE,OAAO51B,KAAA8U,MAAAyG,WAAAg+B,oBAQyBh5C,mCAAAo5E,SAC1B35E,KAAA8U,MAAAo2B,YAAuB,CAC3ByuC,0BAAAA,IAQJY,iCACEv6E,KAAAuW,QAAAkC,GAAgB+gE,EAAA9gE,eAAA6jE,mBAAkC,KAChDv8E,KAAAw8E,mBAAuB,MAEzBx8E,KAAAuW,QAAAkC,GAAgB+gE,EAAA9gE,eAAA+jE,qBAAoC,KAClDz8E,KAAAw8E,mBAAuB,MAU3BA,kBAAiBE,GACf,MAAMrC,iBAAoBr6E,KAAA8U,MAAAyG,WAEtB8+D,IAAkBqC,GAItB18E,KAAA8U,MAAAo2B,YAAuB,CAAEmvC,cAAeqC,qkBC5lB5C,IAAA/rE,EAAA/Q,EAAAnB,EAAA,cAEAmR,EAAAnR,EAAA,uBACAoB,EAAAD,EAAAnB,EAAA,aACAwD,EAAArC,EAAAnB,EAAA,SACAqjD,EAAAliD,EAAAnB,EAAA,SACAsjD,EAAAniD,EAAAnB,EAAA,oCACA0S,EAAA1S,EAAA,qCAOAujD,EAAAvjD,EAAA,0BAMAqB,EAAArB,EAAA,oBAkBe,MAObsB,YAAY8C,EAAO,IAKjB7C,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAJC,CAChB5K,SAAU,GACVm+D,qBAAsB,KAIxB38E,KAAKijD,UAAYpgD,EAAKkK,SACtB/M,KAAK48E,QAAS,EAAA36E,EAAA9B,SAAK,IAAIwQ,EAAAxQ,QAASH,KAAKijD,YACrCjjD,KAAK68E,cAAgBh6E,EAAKsT,aAE1BnW,KAAK88E,oBAAsB98E,KAAK68E,cAAc7yB,kBAC9ChqD,KAAK68E,cAAcv8B,KAAK,UAAWgK,IACjCtqD,KAAK88E,oBAAsBxyB,KAG7BtqD,KAAK+8E,gBAAkB/8E,KAAK+8E,gBAAgBp4E,KAAK3E,MACjDA,KAAK6N,kBAAoBhL,EAAKgL,kBAE9B7N,KAAK0iD,KAAO,IAAIZ,EAAA3hD,QAAKH,KAAKijD,WAG5BrmC,QAEE5c,KAAK68E,cAAcnvE,eAAe,SAAU1N,KAAK+8E,iBAEjD/8E,KAAK68E,cAAcxvE,YAAY,SAAUrN,KAAK+8E,iBAE9C/8E,KAAKilB,kBAGPpI,OAEE7c,KAAK68E,cAAcnvE,eAAe,SAAU1N,KAAK+8E,iBAanDpjD,kBAAkB/E,GAChB,MAAMpW,SAAEA,GAAaxe,KAAK8U,MAAMyG,WAC1ByhE,EAASp+E,OAAO+B,KAAK6d,GAErBy+D,EAAgB,GACtBroD,EAAU91B,SAASo+E,IACZF,EAAO9uE,SAASgvE,IACnBD,EAAcl8C,KAAKm8C,MAIvB,MAAMC,EAAmB,GACzBH,EAAOl+E,SAASuB,IACTu0B,EAAU1mB,SAAS7N,IACtB88E,EAAiBp8C,KAAK1gC,MAI1BL,KAAKgvE,YAAYiO,GACjBj9E,KAAK+qB,cAAcoyD,GASrBnO,YAAYp6C,GACV,MAAMpW,SAAEA,GAAaxe,KAAK8U,MAAMyG,WAEhCqZ,EAAU91B,SAAS4f,IACjBF,EAASE,GAAW,MAGtB1e,KAAK8U,MAAMo2B,YAAY,CAAE1sB,SAAAA,IAEpBxe,KAAK88E,qBAGV98E,KAAKilB,kBAQP8F,cAAc6J,GACZ,MAAMpW,SAAEA,GAAaxe,KAAK8U,MAAMyG,WAEhCqZ,EAAU91B,SAAS4f,WACVF,EAASE,MAGlB1e,KAAK8U,MAAMo2B,YAAY,CAAE1sB,SAAAA,IAO3B6W,gBACEr1B,KAAK8U,MAAMo2B,YAAY,CAAE1sB,SAAU,KAWhBje,sBAAC+pD,GACpBtqD,KAAK88E,oBAAsBxyB,EAG3B,MAAMP,QAAqB/pD,KAAK48E,OAAOQ,iBAAiB9yB,GAAa,GACrE,IAAKP,EACH,OAEF,MAAM4yB,EAAuB5yB,EAAaqK,SAC1Cp0D,KAAK8U,MAAMo2B,YAAY,CAAEyxC,qBAAAA,IAEzB,UACQ38E,KAAKilB,kBACX,MAAO9jB,GACPtB,EAAAM,QAAIG,MAAMa,IAUOZ,wBACnB,MAAMie,SAAEA,GAAaxe,KAAK8U,MAAMyG,WAC1BqZ,EAAYh2B,OAAO+B,KAAK6d,GAG9B,OAFgBxe,KAAK6N,qBAGnB,KAAKsD,EAAA6I,uBACGha,KAAKq9E,iCACTzoD,EACAotB,EAAAW,8BAEF,MAEF,KAAKxxC,EAAA08B,uBACG7tC,KAAKq9E,iCACTzoD,EACAotB,EAAAs7B,sCAEF,MAEF,KAAKnsE,EAAAw8B,uBACG3tC,KAAKq9E,iCACTzoD,EACAotB,EAAAu7B,sCAEF,MAEF,KAAKpsE,EAAA88B,qBACGjuC,KAAKq9E,iCACTzoD,EACAotB,EAAAw7B,oCAEF,MAEF,cACQz8E,QAAQ61B,IAAIhC,EAAUlzB,IAAI1B,KAAKy9E,eAAe94E,KAAK3E,SAW3CO,qBAACme,GAEnB,MACMje,EAAS,CAAEie,QAAAA,EAASoX,cADJ91B,KAAK48E,OAAOpnD,WAAW9W,KAGvCF,SAAEA,GAAaxe,KAAK8U,MAAMyG,WAE3BiD,EAASE,KAGdF,EAASE,GAAWje,EACpBT,KAAK8U,MAAMo2B,YAAY,CAAE1sB,SAAAA,KASWje,uCAACq0B,EAAW8oD,GAChD,MAAMl/D,SAAEA,GAAaxe,KAAK8U,MAAMyG,WAChCvb,KAAK0iD,KAAKM,YAAYhjD,KAAKijD,WACPjjD,KAAK0iD,KAAKzF,IAC3BG,SAAS2E,EAAA5hD,SACTw9C,GAAG+/B,GAGM96B,SAAShuB,EAFF,CAAC,QAEwB,CAACt0B,EAAOG,KAClD,GAAIH,EAMF,OALAT,EAAAM,QAAI6O,KACD,8DACD1O,QAEFS,QAAQ61B,IAAIhC,EAAUlzB,IAAI1B,KAAKy9E,eAAe94E,KAAK3E,QAGrD40B,EAAU91B,SAAQ,CAAC4f,EAASmb,KAC1B,MAAM/D,EAAUr1B,EAAOo5B,IAAS,EAAA/5B,EAAAkrD,SAAQvqD,EAAOo5B,IAAU,MACzDrb,EAASE,GAAW,CAAEA,QAAAA,EAASoX,QAAAA,MAEjC91B,KAAK8U,MAAMo2B,YAAY,CAAE1sB,SAAAA,uYC7R/B,MAAAsuD,aAAAA,GAAAruE,EAAA,UACAuuE,EAAAvuE,EAAA,mBACAsuE,EAAAtuE,EAAA,SACAk/E,EAAAl/E,EAAA,kBAAA0B,SACA+3D,mBAAAA,GAAAz5D,EAAA,kBACAm/E,EAAAn/E,EAAA,iDAEAo/E,EAAA,iBAGAC,EAAA,CACAD,CAAAA,IAAA,EACA,iBAAA,GAGAnK,EAAA,kBAGAqK,EAAA,IACAC,EAAA,CACAC,MAAA,sBACAC,OAAA,uBAGA,SAAAh4C,EAAAi4C,GACA,OAAA,IAAAp9E,SAAAC,GAAAwlC,WAAAxlC,EAAAm9E,KAqBA,SAAAC,EAAA1mD,GACA,MAAA,mBAAAA,EAAAzd,WAGA,MAAAokE,UAAAvR,EACA/sE,YAAA8C,EAAA,IACAG,QACAhD,KAAAgG,KAAA0tE,EACA1zE,KAAAwe,SAAA,GACAxe,KAAA4tE,IAAA,IAAAb,EACA/sE,KAAAo5B,KAAA,EACAp5B,KAAA0tE,QAAA,EACA1tE,KAAA2tE,gBAAA,EACA3tE,KAAA6tE,MAAA,GACA7tE,KAAAguE,YAAAnrE,GAEA86E,EAAAllE,GAAA,gBAAA2K,IACAA,GAAAA,EAAA4f,SAAA5f,EAAA4f,QAAAs7C,WACAt+E,KAAA+4B,MAAA3V,EAAA4f,QAAAs7C,SAAAvlD,UAGA4kD,EAAA1lD,KAAA,CAAAsmD,SAAAP,IASAhlD,WACA,OAAAh5B,KAAA+4B,MAGAiN,UAIA23C,EAAA33C,UAGAzL,YACA,OAAAx5B,QAAAC,QAAA,CACAq3B,OAAAr4B,KAAAq4B,OACA7Z,SAAAxe,KAAAwe,SACA4a,KAAAp5B,KAAAo5B,KACAy0C,MAAA7tE,KAAA6tE,MACAH,QAAA1tE,KAAA0tE,QACAC,gBAAA3tE,KAAA2tE,kBAIAK,YAAAnrE,EAAA,IAKA,OAJA7C,KAAAq4B,OAAAx1B,EAAAw1B,QAAAwlD,EACA79E,KAAAwe,SAAA3b,EAAA2b,UAAA,GACAxe,KAAAo5B,KAAAv2B,EAAAu2B,MAAA,EACAp5B,KAAA0tE,QAAA7qE,EAAA6qE,SAAA,EACA3sE,QAAAC,UAGAsZ,aACA,OAAApa,QAAAF,KAAA4tE,KAAA5tE,KAAA4tE,IAAAnwC,WAGAkxC,SACA,OAAA3uE,KAAAsa,aACAvZ,QAAAC,QAAA,oBAEA,IAAAD,SAAA,CAAAC,EAAAC,KACA08E,EAAAa,aAAA,CACA/gF,KAAAuC,KAAAq4B,OACAomD,KAAA,QAEA3jB,MAAAh3D,IACAA,EAAAgrE,SACA9uE,KAAA4tE,IAAAnwC,UAAAvI,EAAAC,KAAArxB,EAAAk/B,QAAAvF,UAAA,OACAz9B,KAAA4tE,IAAAmB,UAAA75C,EAAAC,KAAArxB,EAAAk/B,QAAA+rC,UAAA,OACA/tE,EAAA,kBAEAC,EACA,IAAAyH,MACA5E,EAAAk/B,SAAAl/B,EAAAk/B,QAAA1iC,OAAA,qBAKAwkC,OAAAtjC,IACAP,EAAA,IAAAyH,MAAAlH,GAAAA,EAAA27B,YAAA,wBAKAjD,mBAAAL,GACA75B,KAAA2tE,gBAAA3zC,SAAAH,EAAA,IAGAm1C,YAAAC,EAAA,GACA,OAAA,IAAAluE,SAAA,CAAAC,EAAAC,KACAjB,KAAA2uE,SACA7T,MAAAv1D,IACA,MAAA4vB,EAAAn1B,KAAA2tE,gBACAj8B,EAAAvc,EAAA85C,EAEA,IAAA,IAAA5mC,EAAAlT,EAAAkT,EAAAqJ,EAAArJ,IAAA,CACA,MAAA3pB,EAAA1e,KAAAkvE,kBAtIA,IAsIA7mC,GACAroC,KAAAwe,SAAAtQ,SAAAwQ,IACA1e,KAAAwe,SAAAuiB,KAAAriB,GAEA1e,KAAAo5B,KAAA,EAEAp4B,EAAAhB,KAAAwe,aAEAsmB,OAAAtjC,IACAP,EAAAO,SAKA+3B,eAEA,OADAv5B,KAAAo5B,KAAA,EACAp5B,KAAAmvE,UAAA,GAGA71C,cACA,OAAAt5B,KAAAmvE,UAAA,GAGA91C,kBACA,OAAAr5B,KAAAmvE,WAAA,GAGAA,UAAA4C,GAOA,OANA/xE,KAAAo5B,MAAA24C,EAEA/xE,KAAAo5B,MAAA,IACAp5B,KAAAo5B,KAAA,GAGA,IAAAr4B,SAAA,CAAAC,EAAAC,KACAjB,KAAA2uE,SACA7T,MAAAv1D,IACA,MAAA4vB,GAAAn1B,KAAAo5B,KAAA,GAAAp5B,KAAA0tE,QACAh8B,EAAAvc,EAAAn1B,KAAA0tE,QAEAlvD,EAAA,GAEA,IAAA,IAAA6pB,EAAAlT,EAAAkT,EAAAqJ,EAAArJ,IAAA,CACA,MAAA3pB,EAAA1e,KAAAkvE,kBAjLA,IAiLA7mC,GACA7pB,EAAAuiB,KAAA,CACAriB,QAAAA,EACAoX,QAAA,KACA+D,MAAAwO,IAEAroC,KAAA6tE,MAAAb,EAAAoB,kBAAA1vD,IAAA2pB,EAEArnC,EAAAwd,MAEAsmB,OAAAtjC,IACAP,EAAAO,SAKA8c,cACA,OAAAvd,QAAAC,QAAAhB,KAAAwe,SAAAxW,SAGA+iB,cAAArM,GACA,IACA1e,KAAAwe,SAAA9c,KAAAkG,GAAAA,EAAAhG,gBAAAsM,SAAAwQ,EAAA9c,eAEA,MAAA,IAAA8G,MAAA,WAAAgW,+BAGA1e,KAAAwe,SAAAxe,KAAAwe,SAAAnW,QACAT,GAAAA,EAAAhG,gBAAA8c,EAAA9c,gBAgBAgf,gBAAAlC,EAAAgZ,GACA,OAAA0mD,EAAA1mD,GAMA13B,KAAAsvE,iBAAA5wD,EAAAgZ,EAAAzd,aAAAyd,GAAAsL,IACAtL,EAAAyd,EAAAjgB,EAAAC,KAAA6N,EAAAmS,EAAA,OACAzd,EAAAihC,EAAAzjC,EAAAC,KAAA6N,EAAA21B,EAAA,OACAjhC,EAAAkhC,EAAA1jC,EAAAC,KAAA6N,EAAA41B,EAAA,OACAlhC,KAGA13B,KAAAsvE,iBACA5wD,EACAgZ,EAAAqgC,OAAAmhB,YAAA9C,WACA1+C,GACAsL,IAIA,MAAA4sC,EAAAl4C,EAAAm4C,SASA,OAPAD,EAAA5pE,KAAA0xB,EAAA1xB,KAEA4pE,EAAAz6B,EAAA63B,EAAAv7B,aAAAzO,EAAAmS,GACAy6B,EAAAjX,EAAAqU,EAAAv7B,aAAAzO,EAAA21B,GACAiX,EAAAhX,EAAAoU,EAAAv7B,aAAAzO,EAAA41B,GAGAV,EAAAC,WAAAyX,EAAA,CACA7X,OAAArgC,EAAAqgC,OACA+X,OAAAlxE,OAAAmxE,SAAAr4C,QAiBAn3B,uBAAAme,EAAA1gB,EAAA05B,EAAAs4C,GACA,IAAAhhC,EAIAA,EAHAovC,EAAA1mD,GAGA,CACAga,GAAA1xC,KAAAsyE,WAAA56C,EAAAga,IACAlzC,MAAAwB,KAAAsyE,WAAA56C,EAAAl5B,OACAgB,KAAAQ,KAAAsyE,WAAA56C,EAAAl4B,MACAxB,QAAAA,EACAwxC,MAAAxvC,KAAAsyE,WAAA56C,EAAA8X,OACA4kB,SAAAp0D,KAAAsyE,WAAA56C,EAAA08B,UACAxiB,SAAA5xC,KAAAsyE,WAAA56C,EAAAka,WAKA,IACAla,EAAAm4C,SACA7xE,QAAAA,EACA0zC,GAAA1xC,KAAAsyE,WAAA56C,EAAAga,KAIA,IACA,MAAA5iC,QAAA9O,KAAA2uE,eACAzoC,EAAA,kBAAAp3B,EAAAivE,EAAA,GACA,MAAAj6E,QAAA65E,EAAAe,wBAAA,CACAjhF,KAAAuC,KAAAyuE,iBAAA/vD,GACAswB,YAAAA,IAEA,GAAAlrC,EAAAgrE,QAAA,CACA,MAAAoB,EAAAF,EAAAlsE,EAAAk/B,SAEAqtC,EAAArD,EAAAoB,kBACApB,EAAAv7B,aACAy+B,EAAAyO,mBAAAxhD,SAAA,SAIA,GAAAkzC,IADArD,EAAAoB,kBAAA1vD,GAEA,MAAA,IAAAhW,MAAA,6CAGA,OAAAwnE,EAEA,MAAA,IAAAxnE,MACA5E,EAAAk/B,SAAAl/B,EAAAk/B,QAAA1iC,OAAA,iBAEA,MAAAkB,GACA,MAAA,IAAAkH,MAAAlH,GAAAA,EAAA27B,YAAA,kBAIA3N,YAAA4gD,EAAA5wE,GACA,OAAAQ,KAAA0vB,oBAAA0gD,EAAA5wE,GAIAkwB,oBAAA0gD,EAAAlsE,GACA,OAAA,IAAAnD,SAAA,CAAAC,EAAAC,KACAjB,KAAA2uE,SACA7T,MAAAhsD,IACA03B,YACAjhC,IACAo4E,EAAAiB,oBAAA,CACAnhF,KAAAuC,KAAAyuE,iBAAA2B,GACAlsE,QAAA8oE,EAAAjwC,eAAA74B,GACAmuE,KAAA,IAEAvX,MAAAh3D,IACA,GAAAA,EAAAgrE,QAAA,CAEAhrE,EAAAk/B,QAAAtkB,UACAsuD,EAAAoB,kBAAAgC,IAEAnvE,EACA,IAAAyH,MAAA,6CAGA,MAAAk1B,EAAA,KAAA95B,EAAAk/B,QAAApF,YACA58B,EAAA48B,QAEA38B,EACA,IAAAyH,MACA5E,EAAAk/B,SAAAl/B,EAAAk/B,QAAA1iC,OACA,qBAKAwkC,OAAAtjC,IACAP,EAAA,IAAAyH,MAAAlH,GAAAA,EAAA27B,YAAA,uBAKA,kBAAAruB,EAAAivE,EAAA,MAGAj5C,OAAAtjC,IACAP,EAAA,IAAAyH,MAAAlH,GAAAA,EAAA27B,YAAA,wBAQA58B,oBAAAme,EAAAlf,GAAAsI,QAAAA,IACA,MAAA+2E,EAAAjB,EAAAp+E,EAAA,OAAAsI,IAKA0F,OAAAsxE,aAAAA,EAAA,MAAAC,GAAA,GAAA76E,QACAA,EAAA,GAAAiqD,OACAA,EAAA,GAAAF,YACAA,EAAA+wB,sBAEAA,EAAAC,aACAA,GACAJ,EAIA/vE,QAAA9O,KAAA2uE,eACAzoC,EAAA,kBAAAp3B,EAAAivE,EAAA,GAEA,MAAAj6E,QAAA65E,EAAAuB,sBAAA,CACAzhF,KAAAuC,KAAAyuE,iBAAA/vD,GACAlf,KAAA,CACAgO,MAAA,CAAAsxE,aAAAA,KAAAC,GACA76E,QAAAA,EACAiqD,OAAAA,EACAF,YAAAA,GAEAkxB,oBAAA,EAEAH,sBAAAA,EACAC,aAAAA,IAGA,GAAAn7E,EAAAgrE,QAAA,CACA,GAAA9B,EAAAoB,kBAAA1vD,KAAA5a,EAAAk/B,QAAAtkB,QACA,MAAA,IAAAhW,MAAA,4CAEA,OAAA5E,EAAAk/B,QAAApF,UAGA,MAAA,IAAAl1B,MACA5E,EAAAk/B,SAAAl/B,EAAAk/B,QAAA1iC,OAAA,iBAIAuuB,gBACA,OAAA9tB,QAAAE,OAAA,IAAAyH,MAAA,iCAGAwiB,eACAlrB,KAAAwe,SAAA,GACAxe,KAAA4tE,IAAA,IAAAb,EACA/sE,KAAAo5B,KAAA,EACAp5B,KAAA2tE,gBAAA,EACA3tE,KAAA6tE,MAAA,GAaAh1C,UAAAR,GACA,IAAAylD,EAAAzlD,GACA,MAAA,IAAA3vB,MACA,4DAAA2vB,KAKAr4B,KAAAq4B,SAAAA,IACAr4B,KAAA4tE,IAAA,IAAAb,EACA/sE,KAAAwe,SAAA,GACAxe,KAAAo5B,KAAA,EACAp5B,KAAA0tE,QAAA,EACA1tE,KAAA2tE,gBAAA,EACA3tE,KAAA6tE,MAAA,IAEA7tE,KAAAq4B,OAAAA,EAKAi6C,WAAAC,GACA,OAAAvF,EAAA9rB,YAAAqxB,GAAAp1C,WAIA+xC,kBAAAhC,EAAA7kC,GACA,MAAAmqC,EAAAxyE,KAAA4tE,IAAA6E,OAAA,GAAAvF,KAAA7kC,KACA3pB,EAAAsuD,EACA0F,gBAAAF,EAAA/0C,WAAA,GACAN,SAAA,OACA,OAAA6vC,EAAAoB,kBAAA,KAAA1vD,KAGA+vD,iBAAA/vD,GACA,MAAA8xD,EAAAxD,EAAAoB,kBAAA1vD,GACA,IAAAmb,EAAA75B,KAAA6tE,MAAA2C,GACA,QAAA,IAAA32C,EACA,IAAA,IAAAwO,EAAA,EAAAA,EAreA,IAqeAA,IACA,GAAAmoC,IAAAxwE,KAAAkvE,kBAveA,IAueA7mC,GAAA,CACAxO,EAAAwO,EACA,MAKA,QAAA,IAAAxO,EACA,MAAA,IAAAnxB,MAAA,mBAEA,MAAA,GAAA1I,KAAAq4B,UAAAwB,KAIAwkD,EAAAr4E,KAAA0tE,EACAv0E,EAAAC,QAAAi/E,8WCrgBA,IAAA13E,EAAA3G,MAAAA,KAAA2G,kBAAA/H,OAAAgI,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAnI,OAAAqI,eAAAJ,EAAAG,EAAA,CAAAE,YAAA,EAAAhG,IAAA,WAAA,OAAA4F,EAAAC,OACA,SAAAF,EAAAC,EAAAC,EAAAC,GACAA,IAAAxG,YAAAwG,EAAAD,GACAF,EAAAG,GAAAF,EAAAC,KAEAI,EAAAnH,MAAAA,KAAAmH,cAAA,SAAAL,EAAA1H,GACA,IAAA,IAAAgI,KAAAN,EAAA,YAAAM,GAAAxI,OAAAyI,UAAAC,eAAAC,KAAAnI,EAAAgI,IAAAT,EAAAvH,EAAA0H,EAAAM,IAEAxI,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACA2I,EAAA1I,EAAA,iBAAAW,GACA+H,EAAA1I,EAAA,cAAAW,GACA+H,EAAA1I,EAAA,cAAAW,GACA+H,EAAA1I,EAAA,WAAAW,GACA+H,EAAA1I,EAAA,sBAAAW,kUChBA,IAAAggF,EAAA3gF,EAAA,4BAAAG,OAAA+B,KAAAy+E,GAAAtgF,SAAA,SAAAC,GAAA,YAAAA,GAAA,eAAAA,IAAAA,KAAAK,GAAAA,EAAAL,KAAAqgF,EAAArgF,IAAAH,OAAAqI,eAAA7H,EAAAL,EAAA,CAAAmI,YAAA,EAAAhG,IAAA,WAAA,OAAAk+E,EAAArgF,+UCIAI,EAAAC,QAAAX,EAAA,q3BCJAmR,EAAAnR,EAAA,uBAQAoB,EAAAD,EAAAnB,EAAA,aACAqR,EAAArR,EAAA,mBACAyR,EAAAzR,EAAA,2BACA4gF,EAAAz/E,EAAAnB,EAAA,oBACA6gF,EAAA1/E,EAAAnB,EAAA,kBACAuT,EAAApS,EAAAnB,EAAA,kCACA8gF,EAAA3/E,EAAAnB,EAAA,knBAXA,MAAM+gF,EAAM/nE,EAAQC,IAAIqC,QACpBtb,EAAQ,kCACRA,EAAQ,kBAcG,MACbsB,YAAY8C,EAAO,IACjB,MAAMuT,sBACJA,EADIgH,kBAEJA,EAFIwC,sBAGJA,EAHI9X,QAIJA,EAJIoY,0BAKJA,EALIC,sBAMJA,GACEtd,EAEJ7C,KAAKoW,sBAAwBA,EAC7BpW,KAAK4f,sBAAwBA,EAC7B5f,KAAKod,kBAAoBA,EACzBpd,KAAK+M,SAAW/M,KAAKy/E,gBAAgB,CACnC33E,QAAAA,EACAwW,YAAa/d,OAASsmB,OAAAA,MACpB,GAAe,SAAXA,EACF,MAAO,GAET,MAAMvM,WAAEA,GAAe4F,IAEjB1B,QAAiBxe,KAAKod,kBAAkBkB,cAE9C,GAAIhE,GAAckE,EAAS,GAAI,CAK7B,MAAO,OAJqBxe,KAAKod,kBAAkBsiE,iBACjDlhE,EAAS,GACT,8BAIJ,MAAO,IAETiK,uBAAwBloB,MAAAA,IACtB,MAAMie,QAAiBxe,KAAKod,kBAAkBkB,cAC9C,OAAOlB,EAAkBsS,oBAAlB5sB,EAAAA,EAAA,GACAg5B,GADA,GAAA,CACW3G,KAAM3W,EAAS,KAC/B,CACEmhE,iBAAkB,iCAK1B3/E,KAAKmxD,uBAAyBhxC,EAE9B,MAAM7L,EAASxR,EAAAA,EAAA,CACbg1B,wBAAwB,EACxB8nD,mBAAmB,EACnBC,oBAAqB,GAClBh9E,EAAKyR,WAJK,GAAA,CAKbwrE,gBAAiB,KACjBC,gBAAgB,EAChBC,kBAAkB,IAEpBhgF,KAAK8U,MAAQ,IAAIlF,EAAAwZ,gBAAgB9U,GACjCtU,KAAKigF,oBAAqB,EAC1BjgF,KAAK+H,cAAgBu3E,EAAAn/E,QAClBwH,MAAK,CAACC,EAAGC,IAAMD,EAAEE,QAAUD,EAAEC,UAC7BE,OAAO,GAAG,GAETsM,EAAUwjB,wBACZ93B,KAAKi4B,OAIC13B,aACR,MAAMie,QAAiBxe,KAAKod,kBAAkBkB,cAC9Cte,KAAK0e,QAAUF,EAAS,GAExBxe,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,iBACPC,SAAU,UAGRrjB,KAAK0e,SAAa1e,KAAKg4B,KAAOh4B,KAAK8U,MAAMyG,WAAWwkE,sBAChD//E,KAAKkgF,UAIE3/E,oBACf,IACE,MAAMu3B,uBAAEA,EAAFioD,eAA0BA,GAAmB//E,KAAK8U,MAAMyG,WAC9D,GAAIuc,GAA0BioD,EAAgB,CAC5C,MAAMx8C,EAAW,CACf9jB,YAAazf,KAAKoW,sBAAsBtB,MAAMyG,WAC9C6oB,YAAapkC,KAAK4f,sBAAsB/e,MACxCq6C,YAAajW,KAAKC,MAClBn9B,cAAe/H,KAAK+H,qBAGhB/H,KAAKmgF,MAAMC,QAAQ/+E,IACvB,iBACA47B,KAAK2N,UAAUrH,UAEXvjC,KAAK2wB,+BAEb,MAAOrwB,GACPyO,QAAQzO,MAAMA,IAIlBm/E,gBAAgB73D,GACd,MAAMy4D,GAAqB,EAAAd,EAAAp/E,SAAyBynB,GAC9CsY,EAAS,IAAIpwB,EAAA6wB,cACnBT,EAAOa,MAAK,EAAA/uB,EAAA7R,SAAuB,CAAE0mB,OAAQ,UAC7CqZ,EAAOa,KAAKs/C,GAEZ,OADiB,EAAAnwE,EAAAowE,oBAAmBpgD,GAItCqgD,qBACE,OAAO,IAAIx/E,SAASC,IAClBhB,KAAKg4B,IAAIwoD,YAAW,KAClB3gF,EAAAM,QAAI8D,MAAM,sBACHjD,UAKAT,gBACX,MAAMie,QAAiBxe,KAAKod,kBAAkBkB,cAK9C,IAAImiE,EAJJzgF,KAAK0e,cAAgB1e,KAAKod,kBAAkBsiE,iBAC1ClhE,EAAS,GACT,6BAGF,IACE,MAAMkiE,QAAuBlB,EAAImB,UAAU3gF,KAAK0e,SAChD+hE,EAAeC,EAAeE,QAAUF,EAAeE,OAAO7rC,SAC9D,MAAOvzC,GACP,IAAIA,EAAE0C,QAAQgvC,MAAM,qCAalB,MALAlzC,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,oBACPC,SAAU,SAGN7hB,EAZNxB,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,6BACPC,SAAU,SAGZo9D,GAAe,EAUnB,GAAIzgF,KAAK+3B,2BAA6B0oD,EAAc,CAClDzgF,KAAK8U,MAAMo2B,YAAY,CAAE60C,gBAAgB,IAEzC,IAAIc,GAAW,EACf,MAAMC,EAAct6C,YAAW,KAC7B3mC,EAAAM,QAAIG,MAAO,sCACXugF,GAAW,EACX7gF,KAAK8U,MAAMo2B,YAAY,CACrB80C,kBAAkB,EAClBloD,wBAAwB,MA7Jb,KAgKf,IACE93B,KAAKg4B,UAAYwnD,EAAIuB,QAAQ/gF,KAAK0e,QAAS1e,KAAK+M,gBAC1C/M,KAAKugF,qBACXvgF,KAAKmgF,YAAcngF,KAAKg4B,IAAIgpD,UAAU,WAAY,CAChDR,WAAYjgF,UACV,MAAM0gF,EAAc,CAClBlB,gBAAgB,EAChBD,gBAAiB9/E,KAAK0e,SAEpBmiE,IACFhhF,EAAAM,QAAIi8B,KAAM,yDACV6kD,EAAYjB,kBAAmB,GAGjCl5C,aAAag6C,GACb9gF,KAAK8U,MAAMo2B,YAAY+1C,GAEvBphF,EAAAM,QAAI8D,MAAM,wBAEVjE,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,cACPC,SAAU,YAIhB,MAAO7hB,GAOP,MANAxB,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,wBACPC,SAAU,SAGZtU,QAAQzO,MAAMkB,GACRA,IAKQjB,uBAClB,MAAM29B,QAAYl+B,KAAKmgF,MAAMC,QAAQl/E,IAAI,kBAEzC,OADkB+7B,KAAKC,MAAMgB,GAAO,MACnBgd,YAGO36C,2BAAC2gF,GACzB,MAAMC,EAAW,IAAI9B,EAAAl/E,QAAS,CAAEuH,WAAA43E,EAAAn/E,WAC1Bsf,YAAEA,EAAF2kB,YAAeA,GAAgBnH,KAAKC,MAAMgkD,GAC1CE,EAAuB,CAC3BvjF,sBAAuB4hB,EACvBI,sBAAuBukB,GAEnBi9C,EAAwBF,EAASh5E,qBACrCi5E,GAEIE,QAAsBH,EAASI,YAAYF,GACjD,MAAO,CACL5hE,YAAa6hE,EAAc9hF,KAAK3B,sBAChCumC,YAAak9C,EAAc9hF,KAAKqgB,uBAIXtf,4BACvB,MAAM2gF,QAAsBlhF,KAAKmgF,MAAMC,QAAQl/E,IAAI,mBAC7Cue,YAAEA,EAAF2kB,YAAeA,SAAsBpkC,KAAKwhF,qBAC9CN,GAEFlhF,KAAK8U,MAAMo2B,YAAY,CAAE20C,oBAAqBqB,EAAchmC,cAC5Dz7B,GAAezf,KAAKoW,sBAAsBtB,MAAMo2B,YAAYzrB,GAC5D2kB,GAAepkC,KAAK4f,sBAAsBtR,OAAO81B,GAAa,GAC9DpkC,KAAK2wB,8BAEL3wB,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,qBACPC,SAAU,SAIdyN,wBACE9wB,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,sBACPC,SAAU,SAGZrjB,KAAK2jD,mBAGP89B,yBACEzhF,KAAKmxD,uBAAuB,CAC1B/tC,MAAO,uBACPC,SAAU,SAGZrjB,KAAKg4B,IAAI0pD,SAGX/wD,8BACE3wB,KAAK8U,MAAMo2B,YAAY,CAAE00C,mBAAmB,IAG9CnvD,6BAA6BkxD,GACvB3hF,KAAK8U,MAAMyG,WAAWykE,mBAG1BhgF,KAAK8U,MAAMo2B,YAAY,CACrBpT,uBAAwB6pD,IAGtBA,GAA2B3hF,KAAKg4B,KAClCh4B,KAAK8wB,yBAGF6wD,GAA2B3hF,KAAKg4B,KACnCh4B,KAAKyhF,0BAIT1pD,0BACE,OAAO/3B,KAAK8U,MAAMyG,WAAWuc,uBAG/B6rB,mBACE,IAAK3jD,KAAKigF,mBAAoB,CAC5B,MAAM2B,EAAoB5hF,KAAK6hF,YAAYl9E,KAAK3E,MAChDA,KAAKoW,sBAAsBtB,MAAM8B,UAAUgrE,GAC3C,MAAME,EAAoB9hF,KAAK6hF,YAAYl9E,KAAK3E,MAChDA,KAAK4f,sBAAsBhJ,UAAUkrE,GACrC9hF,KAAKigF,oBAAqB,qQC7ShCrhF,OAAAqI,eAAA7H,EAAA,aAAA,CAAAZ,OAAA,IACA,MAAAujF,EAAAtjF,EAAA,UACA,SAAAujF,EAAAj5C,EAAA3C,EAAA3K,GACA,IACAwmD,QAAAx7C,MAAAsC,EAAA3C,EAAA3K,GAEA,MAAAt6B,GAEAqlC,YAAA,KACA,MAAArlC,MAYA,MAAA+gF,UAAAH,EAAAjV,aACAzmE,KAAAL,KAAAy1B,GACA,IAAA0mD,EAAA,UAAAn8E,EACA,MAAA86B,EAAA9gC,KAAAwH,QACA,GAAAs5B,IAAAtgC,UACA2hF,EAAAA,GAAArhD,EAAAxgC,QAAAE,eAEA,IAAA2hF,EACA,OAAA,EAGA,GAAAA,EAAA,CACA,IAAAC,EAIA,GAHA3mD,EAAA76B,OAAA,KACAwhF,GAAA3mD,GAEA2mD,aAAA15E,MAGA,MAAA05E,EAGA,MAAAjhF,EAAA,IAAAuH,MAAA,oBAAA05E,EAAA,KAAAA,EAAAl+E,WAAA,KAEA,MADA/C,EAAAilC,QAAAg8C,EACAjhF,EAEA,MAAA4nC,EAAAjI,EAAA96B,GACA,GAAA+iC,IAAAvoC,UACA,OAAA,EAEA,GAAA,mBAAAuoC,EACAi5C,EAAAj5C,EAAA/oC,KAAAy7B,OAEA,CACA,MAAA4mD,EAAAt5C,EAAAnoC,OACA0hF,EA3CA,SAAAn6C,GACA,MAAA8mC,EAAA9mC,EAAAvnC,OACA2hF,EAAA,IAAA9nD,MAAAw0C,GACA,IAAA,IAAA5mC,EAAA,EAAAA,EAAA4mC,EAAA5mC,GAAA,EACAk6C,EAAAl6C,GAAAF,EAAAE,GAEA,OAAAk6C,EAqCAC,CAAAz5C,GACA,IAAA,IAAAV,EAAA,EAAAA,EAAAg6C,EAAAh6C,GAAA,EACA25C,EAAAM,EAAAj6C,GAAAroC,KAAAy7B,GAGA,OAAA,GAGAr8B,EAAAe,QAAA+hF,sUCjEA,IAAAO,EAAAhkF,EAAA,mBAAAgkF,UACAC,EAAAjkF,EAAA,QAAAikF,SACAC,EAAAlkF,EAAA,SAEA,SAAAmkF,EAAA//E,GACA4/E,EAAAl7E,KAAAvH,KAAA6C,GACA7C,KAAA6iF,YAAA,EAkBA,SAAAC,EAAA3/E,EAAA4/E,EAAA1/E,GACAA,EAAA,KAAAF,GAMA,SAAA6/E,EAAAC,GACA,OAAA,SAAA3zE,EAAA4zE,EAAAn8C,GAaA,MAZA,mBAAAz3B,IACAy3B,EAAAm8C,EACAA,EAAA5zE,EACAA,EAAA,IAGA,mBAAA4zE,IACAA,EAAAJ,GAEA,mBAAA/7C,IACAA,EAAA,MAEAk8C,EAAA3zE,EAAA4zE,EAAAn8C,IApCA27C,EAAAE,EAAAH,GAEAG,EAAAv7E,UAAAo5B,QAAA,SAAAt/B,GACA,IAAAnB,KAAA6iF,WAAA,CACA7iF,KAAA6iF,YAAA,EAEA,IAAA/jC,EAAA9+C,KACAyX,EAAAowB,UAAA,WACA1mC,GACA29C,EAAAz4C,KAAA,QAAAlF,GACA29C,EAAAz4C,KAAA,cAgCAlH,EAAAC,QAAA4jF,GAAA,SAAA1zE,EAAA4zE,EAAAn8C,GACA,IAAAo8C,EAAA,IAAAP,EAAAtzE,GAOA,OALA6zE,EAAAC,WAAAF,EAEAn8C,IACAo8C,EAAAE,OAAAt8C,GAEAo8C,KAMAhkF,EAAAC,QAAAkkF,KAAAN,GAAA,SAAA1zE,EAAA4zE,EAAAn8C,GACA,SAAAw8C,EAAAC,GACA,KAAAxjF,gBAAAujF,GACA,OAAA,IAAAA,EAAAC,GAEAxjF,KAAAsP,QAAAqzE,EAAArzE,EAAAk0E,GAEAZ,EAAAr7E,KAAAvH,KAAAA,KAAAsP,SAUA,OAPAozE,EAAAa,EAAAX,GAEAW,EAAAl8E,UAAA+7E,WAAAF,EAEAn8C,IACAw8C,EAAAl8E,UAAAg8E,OAAAt8C,GAEAw8C,KAIApkF,EAAAC,QAAAhB,IAAA4kF,GAAA,SAAA1zE,EAAA4zE,EAAAn8C,GACA,IAAAo8C,EAAA,IAAAP,EAAAD,EAAA,CAAA5/E,YAAA,EAAA0gF,cAAA,IAAAn0E,IAOA,OALA6zE,EAAAC,WAAAF,EAEAn8C,IACAo8C,EAAAE,OAAAt8C,GAEAo8C,6YC3Fe,SAAqBr7E,EAASuN,EAAQquE,GACnD,OAAO,SAAUn4C,GACf,MAAMrjC,GAAgB,EAAA5J,EAAAC,WAAUgtC,GAChCrjC,EAAcK,KAAKT,QAAUA,EAC7B,IACE,MACMy7B,EASZ,SAAwB1iC,EAAO6iF,EAAWruE,GACxC,MAAMkuB,EAAW1iC,GACXyf,sBAAEA,GAA0BijB,EAClC,GAAIjjB,GAAyBA,EAAsBkX,aAAc,CAC/D,MAAMA,aAAEA,GAAiBlX,EAEzBijB,EAASjjB,sBAAsBkX,aAAeA,EAAa91B,KAAKggB,GACzDgiE,EAAUhiE,IAIfA,EAAO5S,OAASmC,EAAAsQ,qBAAqBE,OACrCC,EAAOvgB,IAAM,CACX+C,QAASmR,EACTm9B,KAAO,gDAA+Cn9B,KAGjDqM,GATEA,IAYb,OAAO6hB,EA7BcqI,CADH1jC,EAAc1I,KACWkkF,EAAWruE,GAClDnN,EAAc1I,KAAO+jC,EACrB,MAAOpiC,GACP4N,QAAQC,KAAM,uBAAsBlH,IAAU3G,EAAI0qC,SAEpD,OAAO9qC,QAAQC,QAAQkH,KAd3B,IAAA5J,EAAAG,EAAA,UACAwS,EAAAxS,EAAA,mhBCQO,SAAAklF,GACL,OACEA,OAEO,CAAAt/C,EAAAxK,IACW,IAAVA,EACKwK,EAEFu/C,EAAqBD,EAAY9pD,EAAQ,GAAIwK,sBAoCrD,SAAAw/C,GAEL,OADqB,EAAAvlF,EAAAC,WAAUslF,GACZ/sD,QACjB,CAAA0jD,EAAAn2C,IAAgBy/C,EAAA3jF,QAAA4jF,WAAsBvJ,EAAKn2C,GAA3B2/C,oCAUb,SAAAtiE,GACL,MAAMuiE,6WAAOnhF,CAAA,GAAQ4e,GAErB,cADOuiE,EAAOpwC,SACP,EAAAv1C,EAAAC,WAAU0lF,wDArEnBH,EAAAlkF,EAAAnB,EAAA,oBACAH,EAAAG,EAAA,wOAkCO,SAAAmlF,EAAAM,EAAA3gD,EAAAiP,GACL,MAAMnO,EAAQy/C,EAAA3jF,QAAAgkF,QAAmBD,EAAe3gD,GAQhD,OANIc,EAAM,KACJmO,IACFnO,EAAM,GAANmO,KAAgBA,GAElBnO,EAAM,GAANgC,UAAqBpB,KAAIC,OAEpBb,iPC5CTllC,EAAAC,QAAA,SAAAI,GACA,GAAAA,aAAA4kF,WAAA5kF,aAAA2/C,YAAA3/C,aAAA6kF,kBACA,OAAA,IAAAC,SAAA9kF,EAAA2nC,OAAA3nC,EAAA+kF,WAAA/kF,EAAAu9C,YAGA,GAAAv9C,aAAAglF,YACA,OAAA,IAAAF,SAAA9kF,GAGA,MAAA,IAAAilF,UAAA","file":"../ExtensionSource/background-0.js","sourcesContent":["// Type Imports\n/**\n * @typedef {import('../../shared/constants/app').EnvironmentType} EnvironmentType\n */\n\n// Type Declarations\n/**\n * Used to attach context of where the user was at in the application when the\n * event was triggered. Also included as full details of the current page in\n * page events.\n *\n * @typedef {Object} MetaMetricsPageObject\n * @property {string} [path] - the path of the current page (e.g /home)\n * @property {string} [title] - the title of the current page (e.g 'home')\n * @property {string} [url] - the fully qualified url of the current page\n */\n\n/**\n * For metamask, this is the dapp that triggered an interaction\n *\n * @typedef {Object} MetaMetricsReferrerObject\n * @property {string} [url] - the origin of the dapp issuing the\n *  notification\n */\n\n/**\n * We attach context to every meta metrics event that help to qualify our\n * analytics. This type has all optional values because it represents a\n * returned object from a method call. Ideally app and userAgent are\n * defined on every event. This is confirmed in the getTrackMetaMetricsEvent\n * function, but still provides the consumer a way to override these values if\n * necessary.\n *\n * @typedef {Object} MetaMetricsContext\n * @property {Object} app - Application metadata.\n * @property {string} app.name - the name of the application tracking the event\n * @property {string} app.version - the version of the application\n * @property {string} userAgent - the useragent string of the user\n * @property {MetaMetricsPageObject} [page] - an object representing details of\n *  the current page\n * @property {MetaMetricsReferrerObject} [referrer] - for metamask, this is the\n *  dapp that triggered an interaction\n */\n\n/**\n * @typedef {Object} MetaMetricsEventPayload\n * @property {string} event - event name to track\n * @property {string} category - category to associate event to\n * @property {string} [environmentType] - The type of environment this event\n *  occurred in. Defaults to the background process type\n * @property {object} [properties] - object of custom values to track, keys\n *  in this object must be in snake_case\n * @property {object} [sensitiveProperties] - Object of sensitive values to\n *  track. Keys in this object must be in snake_case. These properties will be\n *  sent in an additional event that excludes the user's metaMetricsId\n * @property {number} [revenue] - amount of currency that event creates in\n *  revenue for MetaMask\n * @property {string} [currency] - ISO 4127 format currency for events with\n *  revenue, defaults to US dollars\n * @property {number} [value] - Abstract business \"value\" attributable to\n *  customers who trigger this event\n * @property {MetaMetricsPageObject} [page] - the page/route that the event\n *  occurred on\n * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp\n *  that triggered the event\n */\n\n/**\n * @typedef {Object} MetaMetricsEventOptions\n * @property {boolean} [isOptIn] - happened during opt in/out workflow\n * @property {boolean} [flushImmediately] - When true will automatically flush\n *  the segment queue after tracking the event. Recommended if the result of\n *  tracking the event must be known before UI transition or update\n * @property {boolean} [excludeMetaMetricsId] - whether to exclude the user's\n *  metametrics id for anonymity\n * @property {string} [metaMetricsId] - an override for the metaMetricsId in\n *  the event one is created as part of an asynchronous workflow, such as\n *  awaiting the result of the metametrics opt-in function that generates the\n *  user's metametrics id\n * @property {boolean} [matomoEvent] - is this event a holdover from matomo\n *  that needs further migration? when true, sends the data to a special\n *  segment source that marks the event data as not conforming to our schema\n */\n\n/**\n * @typedef {Object} MetaMetricsEventFragment\n * @property {string} successEvent - The event name to fire when the fragment\n *  is closed in an affirmative action.\n * @property {string} [failureEvent] - The event name to fire when the fragment\n *  is closed with a rejection.\n * @property {string} [initialEvent] - An event name to fire immediately upon\n *  fragment creation. This is useful for building funnels in mixpanel and for\n *  reduction of code duplication.\n * @property {string} category - the event category to use for both the success\n *  and failure events\n * @property {boolean} [persist] - Should this fragment be persisted in\n *  state and progressed after the extension is locked and unlocked.\n * @property {number} [timeout] - Time in seconds the event should be persisted\n *  for. After the timeout the fragment will be closed as abandoned. if not\n *  supplied the fragment is stored indefinitely.\n * @property {number} [lastUpdated] - Date.now() when the fragment was last\n *  updated. Used to determine if the timeout has expired and the fragment\n *  should be closed.\n * @property {object} [properties] - Object of custom values to track, keys in\n *  this object must be in snake_case.\n * @property {object} [sensitiveProperties] - Object of sensitive values to\n *  track. Keys in this object must be in snake_case. These properties will be\n *  sent in an additional event that excludes the user's metaMetricsId\n * @property {number} [revenue] - amount of currency that event creates in\n *  revenue for MetaMask if fragment is successful.\n * @property {string} [currency] - ISO 4127 format currency for events with\n *  revenue, defaults to US dollars\n * @property {number} [value] - Abstract business \"value\" attributable to\n *  customers who successfully complete this fragment\n * @property {MetaMetricsPageObject} [page] - the page/route that the event\n *  occurred on\n * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp\n *  that initiated the event fragment.\n * @property {string} [uniqueIdentifier] - optional argument to override the\n *  automatic generation of UUID for the event fragment. This is useful when\n *  tracking events for subsystems that already generate UUIDs so to avoid\n *  unnecessary lookups and reduce accidental duplication.\n */\n\n/**\n * Represents the shape of data sent to the segment.track method.\n *\n * @typedef {Object} SegmentEventPayload\n * @property {string} [userId] - The metametrics id for the user\n * @property {string} [anonymousId] - An anonymousId that is used to track\n *  sensitive data while preserving anonymity.\n * @property {string} event - name of the event to track\n * @property {Object} properties - properties to attach to the event\n * @property {MetaMetricsContext} context - the context the event occurred in\n */\n\n/**\n * @typedef {Object} MetaMetricsPagePayload\n * @property {string} name - The name of the page that was viewed\n * @property {Object} [params] - The variadic parts of the page url\n *  example (route: `/asset/:asset`, path: `/asset/ETH`)\n *  params: { asset: 'ETH' }\n * @property {EnvironmentType} environmentType - the environment type that the\n *  page was viewed in\n * @property {MetaMetricsPageObject} [page] - the details of the page\n * @property {MetaMetricsReferrerObject} [referrer] - dapp that triggered the page\n *  view\n */\n\n/**\n * @typedef {Object} MetaMetricsPageOptions\n * @property {boolean} [isOptInPath] - is the current path one of the pages in\n *  the onboarding workflow? If true and participateInMetaMetrics is null track\n *  the page view\n */\n\n// Mixpanel converts the zero address value to a truly anonymous event, which\n// speeds up reporting\nexport const METAMETRICS_ANONYMOUS_ID = '0x0000000000000000';\n\n/**\n * This object is used to identify events that are triggered by the background\n * process.\n *\n * @type {MetaMetricsPageObject}\n */\nexport const METAMETRICS_BACKGROUND_PAGE_OBJECT = {\n  path: '/background-process',\n  title: 'Background Process',\n  url: '/background-process',\n};\n\n/**\n * @typedef {Object} SegmentInterface\n * @property {SegmentEventPayload[]} queue - A queue of events to be sent when\n *  the flushAt limit has been reached, or flushInterval occurs\n * @property {() => void} flush - Immediately flush the queue, resetting it to\n *  an empty array and sending the pending events to Segment\n * @property {(\n *  payload: SegmentEventPayload,\n *  callback: (err?: Error) => void\n * ) => void} track - Track an event with Segment, using the internal batching\n *  mechanism to optimize network requests\n * @property {(payload: Object) => void} page - Track a page view with Segment\n * @property {() => void} identify - Identify an anonymous user. We do not\n *  currently use this method.\n */\n\nexport const REJECT_NOTFICIATION_CLOSE = 'Cancel Via Notification Close';\nexport const REJECT_NOTFICIATION_CLOSE_SIG =\n  'Cancel Sig Request Via Notification Close';\n","/**\n * @typedef {Object} FirstTimeState\n * @property {Object} config Initial configuration parameters\n * @property {Object} NetworkController Network controller state\n */\n\n/**\n * @type {FirstTimeState}\n */\nconst initialState = {\n  config: {},\n  PreferencesController: {\n    frequentRpcListDetail: [\n      {\n        rpcUrl: 'http://localhost:8545',\n        chainId: '0x539',\n        ticker: 'ETH',\n        nickname: 'Localhost 8545',\n        rpcPrefs: {},\n      },\n    ],\n  },\n};\n\nexport default initialState;\n","import { cloneDeep } from 'lodash';\n\n// This will create an object that represents the structure of the given object\n// it replaces all values with the result of their type\n\n// {\n//   \"data\": {\n//     \"CurrencyController\": {\n//       \"conversionDate\": \"number\",\n//       \"conversionRate\": \"number\",\n//       \"currentCurrency\": \"string\"\n//     }\n// }\n\n/**\n * Creates an object that represents the structure of the given object. It replaces all values with the result of their\n * type.\n *\n * @param {Object} obj - The object for which a 'structure' will be returned. Usually a plain object and not a class.\n * @returns {Object} The \"mapped\" version of a deep clone of the passed object, with each non-object property value\n * replaced with the javascript type of that value.\n */\nexport default function getObjStructure(obj) {\n  const structure = cloneDeep(obj);\n  return deepMap(structure, (value) => {\n    return value === null ? 'null' : typeof value;\n  });\n}\n\n/**\n * Modifies all the properties and deeply nested of a passed object. Iterates recursively over all nested objects and\n * their properties, and covers the entire depth of the object. At each property value which is not an object is modified.\n *\n * @param {Object} target - The object to modify\n * @param {Function} visit - The modifier to apply to each non-object property value\n * @returns {Object} The modified object\n */\nfunction deepMap(target = {}, visit) {\n  Object.entries(target).forEach(([key, value]) => {\n    if (typeof value === 'object' && value !== null) {\n      target[key] = deepMap(value, visit);\n    } else {\n      target[key] = visit(value);\n    }\n  });\n  return target;\n}\n","var through = require('through')\n  , duplexer = require('duplexer')\n  , debounce = require('debounce')\n\nmodule.exports = debounceStream\n\nfunction debounceStream(_ms, immediate) {\n  var ms = _ms || 100\n    , input = through(debounce(write, ms, immediate))\n    , output = through()\n\n  return duplexer(input, output)\n\n  function write(data) {\n    output.queue(data)\n  }\n}\n","import extension from 'extensionizer';\nimport log from 'loglevel';\nimport { checkForError } from './util';\n\n/**\n * A wrapper around the extension's storage local API\n */\nexport default class ExtensionStore {\n  constructor() {\n    this.isSupported = Boolean(extension.storage.local);\n    if (!this.isSupported) {\n      log.error('Storage local API not available.');\n    }\n  }\n\n  /**\n   * Returns all of the keys currently saved\n   *\n   * @returns {Promise<*>}\n   */\n  async get() {\n    if (!this.isSupported) {\n      return undefined;\n    }\n    const result = await this._get();\n    // extension.storage.local always returns an obj\n    // if the object is empty, treat it as undefined\n    if (isEmpty(result)) {\n      return undefined;\n    }\n    return result;\n  }\n\n  /**\n   * Sets the key in local state\n   *\n   * @param {Object} state - The state to set\n   * @returns {Promise<void>}\n   */\n  async set(state) {\n    return this._set(state);\n  }\n\n  /**\n   * Returns all of the keys currently saved\n   *\n   * @private\n   * @returns {Object} the key-value map from local storage\n   */\n  _get() {\n    const { local } = extension.storage;\n    return new Promise((resolve, reject) => {\n      local.get(null, (/** @type {any} */ result) => {\n        const err = checkForError();\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n\n  /**\n   * Sets the key in local state\n   *\n   * @param {Object} obj - The key to set\n   * @returns {Promise<void>}\n   * @private\n   */\n  _set(obj) {\n    const { local } = extension.storage;\n    return new Promise((resolve, reject) => {\n      local.set(obj, () => {\n        const err = checkForError();\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}\n\n/**\n * Returns whether or not the given object contains no keys\n *\n * @param {Object} obj - The object to check\n * @returns {boolean}\n */\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n","import extension from 'extensionizer';\nimport promisify from 'pify';\nimport allLocales from '../../_locales/index.json';\n\nconst getPreferredLocales = extension.i18n\n  ? promisify(extension.i18n.getAcceptLanguages, { errorFirst: false })\n  : async () => [];\n\n// mapping some browsers return hyphen instead underscore in locale codes (e.g. zh_TW -> zh-tw)\nconst existingLocaleCodes = {};\nallLocales.forEach((locale) => {\n  if (locale && locale.code) {\n    existingLocaleCodes[locale.code.toLowerCase().replace('_', '-')] =\n      locale.code;\n  }\n});\n\n/**\n * Returns a preferred language code, based on settings within the user's browser. If we have no translations for the\n * users preferred locales, 'en' is returned.\n *\n * @returns {Promise<string>} Promises a locale code, either one from the user's preferred list that we have a translation for, or 'en'\n */\nexport default async function getFirstPreferredLangCode() {\n  let userPreferredLocaleCodes;\n\n  try {\n    userPreferredLocaleCodes = await getPreferredLocales();\n  } catch (e) {\n    // Brave currently throws when calling getAcceptLanguages, so this handles that.\n    userPreferredLocaleCodes = [];\n  }\n\n  // safeguard for Brave Browser until they implement chrome.i18n.getAcceptLanguages\n  // https://github.com/MetaMask/metamask-extension/issues/4270\n  if (!userPreferredLocaleCodes) {\n    userPreferredLocaleCodes = [];\n  }\n\n  let firstPreferredLangCode = userPreferredLocaleCodes\n    .map((code) => code.toLowerCase().replace('_', '-'))\n    .find(\n      (code) =>\n        existingLocaleCodes[code] !== undefined ||\n        existingLocaleCodes[code.split('-')[0]] !== undefined,\n    );\n\n  // if we have matched against a code with a '-' present, meaning its a regional\n  // code for which we have a non-regioned locale, we need to set firstPreferredLangCode\n  // to the correct non-regional code.\n  if (\n    firstPreferredLangCode !== undefined &&\n    existingLocaleCodes[firstPreferredLangCode] === undefined\n  ) {\n    firstPreferredLangCode = firstPreferredLangCode.split('-')[0];\n  }\n\n  return existingLocaleCodes[firstPreferredLangCode] || 'en';\n}\n","import { Writable as WritableStream } from 'readable-stream';\nimport promiseToCallback from 'promise-to-callback';\n\nclass AsyncWritableStream extends WritableStream {\n  constructor(asyncWriteFn, _opts) {\n    const opts = { objectMode: true, ..._opts };\n    super(opts);\n    this._asyncWriteFn = asyncWriteFn;\n  }\n\n  // write from incoming stream to state\n  _write(chunk, encoding, callback) {\n    promiseToCallback(this._asyncWriteFn(chunk, encoding))(callback);\n  }\n}\n\nexport default function createStreamSink(asyncWriteFn, _opts) {\n  return new AsyncWritableStream(asyncWriteFn, _opts);\n}\n","import log from 'loglevel';\nimport { SECOND } from '../../../shared/constants/time';\nimport getFetchWithTimeout from '../../../shared/modules/fetch-with-timeout';\n\nconst fetchWithTimeout = getFetchWithTimeout(SECOND * 30);\n\nconst FIXTURE_SERVER_HOST = 'localhost';\nconst FIXTURE_SERVER_PORT = 12345;\nconst FIXTURE_SERVER_URL = `http://${FIXTURE_SERVER_HOST}:${FIXTURE_SERVER_PORT}/state.json`;\n\n/**\n * A read-only network-based storage wrapper\n */\nexport default class ReadOnlyNetworkStore {\n  constructor() {\n    this._initialized = false;\n    this._initializing = this._init();\n    this._state = undefined;\n  }\n\n  /**\n   * Declares this store as compatible with the current browser\n   */\n  isSupported = true;\n\n  /**\n   * Initializes by loading state from the network\n   */\n  async _init() {\n    try {\n      const response = await fetchWithTimeout(FIXTURE_SERVER_URL);\n      if (response.ok) {\n        this._state = await response.json();\n      }\n    } catch (error) {\n      log.debug(`Error loading network state: '${error.message}'`);\n    } finally {\n      this._initialized = true;\n    }\n  }\n\n  /**\n   * Returns state\n   *\n   * @returns {Promise<object>}\n   */\n  async get() {\n    if (!this._initialized) {\n      await this._initializing;\n    }\n    return this._state;\n  }\n\n  /**\n   * Set state\n   *\n   * @param {Object} state - The state to set\n   * @returns {Promise<void>}\n   */\n  async set(state) {\n    if (!this._initialized) {\n      await this._initializing;\n    }\n    this._state = state;\n  }\n}\n","import EventEmitter from 'safe-event-emitter';\nimport ExtensionPlatform from '../platforms/extension';\n\nconst NOTIFICATION_HEIGHT = 620;\nconst NOTIFICATION_WIDTH = 360;\n\nexport const NOTIFICATION_MANAGER_EVENTS = {\n  POPUP_CLOSED: 'onPopupClosed',\n};\n\n/**\n * A collection of methods for controlling the showing and hiding of the notification popup.\n */\nexport default class NotificationManager extends EventEmitter {\n  constructor() {\n    super();\n    this.platform = new ExtensionPlatform();\n    this.platform.addOnRemovedListener(this._onWindowClosed.bind(this));\n  }\n\n  /**\n   * Mark the notification popup as having been automatically closed.\n   *\n   * This lets us differentiate between the cases where we close the\n   * notification popup v.s. when the user closes the popup window directly.\n   */\n  markAsAutomaticallyClosed() {\n    this._popupAutomaticallyClosed = true;\n  }\n\n  /**\n   * Either brings an existing MetaMask notification window into focus, or creates a new notification window. New\n   * notification windows are given a 'popup' type.\n   *\n   */\n  async showPopup() {\n    const popup = await this._getPopup();\n\n    // Bring focus to chrome popup\n    if (popup) {\n      // bring focus to existing chrome popup\n      await this.platform.focusWindow(popup.id);\n    } else {\n      let left = 0;\n      let top = 0;\n      try {\n        const lastFocused = await this.platform.getLastFocusedWindow();\n        // Position window in top right corner of lastFocused window.\n        top = lastFocused.top;\n        left = lastFocused.left + (lastFocused.width - NOTIFICATION_WIDTH);\n      } catch (_) {\n        // The following properties are more than likely 0, due to being\n        // opened from the background chrome process for the extension that\n        // has no physical dimensions\n        const { screenX, screenY, outerWidth } = window;\n        top = Math.max(screenY, 0);\n        left = Math.max(screenX + (outerWidth - NOTIFICATION_WIDTH), 0);\n      }\n\n      // create new notification popup\n      const popupWindow = await this.platform.openWindow({\n        url: 'notification.html',\n        type: 'popup',\n        width: NOTIFICATION_WIDTH,\n        height: NOTIFICATION_HEIGHT,\n        left,\n        top,\n      });\n\n      // Firefox currently ignores left/top for create, but it works for update\n      if (popupWindow.left !== left && popupWindow.state !== 'fullscreen') {\n        await this.platform.updateWindowPosition(popupWindow.id, left, top);\n      }\n      this._popupId = popupWindow.id;\n    }\n  }\n\n  _onWindowClosed(windowId) {\n    if (windowId === this._popupId) {\n      this._popupId = undefined;\n      this.emit(NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED, {\n        automaticallyClosed: this._popupAutomaticallyClosed,\n      });\n      this._popupAutomaticallyClosed = undefined;\n    }\n  }\n\n  /**\n   * Checks all open MetaMask windows, and returns the first one it finds that is a notification window (i.e. has the\n   * type 'popup')\n   *\n   * @private\n   */\n  async _getPopup() {\n    const windows = await this.platform.getAllWindows();\n    return this._getPopupIn(windows);\n  }\n\n  /**\n   * Given an array of windows, returns the 'popup' that has been opened by MetaMask, or null if no such window exists.\n   *\n   * @private\n   * @param {Array} windows - An array of objects containing data about the open MetaMask extension windows.\n   */\n  _getPopupIn(windows) {\n    return windows\n      ? windows.find((win) => {\n          // Returns notification popup\n          return win && win.type === 'popup' && win.id === this._popupId;\n        })\n      : null;\n  }\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./asStream\"), exports);\n__exportStar(require(\"./ComposedStore\"), exports);\n__exportStar(require(\"./LocalStorageStore\"), exports);\n__exportStar(require(\"./MergedStore\"), exports);\n__exportStar(require(\"./ObservableStore\"), exports);\n__exportStar(require(\"./transform\"), exports);\n//# sourceMappingURL=index.js.map","import EventEmitter from 'events';\n\n/**\n * @typedef {Object} Migration\n * @property {number} version - The migration version\n * @property {Function} migrate - Returns a promise of the migrated data\n */\n\n/**\n * @typedef {Object} MigratorOptions\n * @property {Array<Migration>} [migrations] - The list of migrations to apply\n * @property {number} [defaultVersion] - The version to use in the initial state\n */\n\nexport default class Migrator extends EventEmitter {\n  /**\n   * @param {MigratorOptions} opts\n   */\n  constructor(opts = {}) {\n    super();\n    const migrations = opts.migrations || [];\n    // sort migrations by version\n    this.migrations = migrations.sort((a, b) => a.version - b.version);\n    // grab migration with highest version\n    const lastMigration = this.migrations.slice(-1)[0];\n    // use specified defaultVersion or highest migration version\n    this.defaultVersion =\n      opts.defaultVersion || (lastMigration && lastMigration.version) || 0;\n  }\n\n  // run all pending migrations on meta in place\n  async migrateData(versionedData = this.generateInitialState()) {\n    // get all migrations that have not yet been run\n    const pendingMigrations = this.migrations.filter(migrationIsPending);\n\n    // perform each migration\n    for (const migration of pendingMigrations) {\n      try {\n        // attempt migration and validate\n        const migratedData = await migration.migrate(versionedData);\n        if (!migratedData.data) {\n          throw new Error('Migrator - migration returned empty data');\n        }\n        if (\n          migratedData.version !== undefined &&\n          migratedData.meta.version !== migration.version\n        ) {\n          throw new Error(\n            'Migrator - Migration did not update version number correctly',\n          );\n        }\n        // accept the migration as good\n        // eslint-disable-next-line no-param-reassign\n        versionedData = migratedData;\n      } catch (err) {\n        // rewrite error message to add context without clobbering stack\n        const originalErrorMessage = err.message;\n        err.message = `MetaMask Migration Error #${migration.version}: ${originalErrorMessage}`;\n        // emit error instead of throw so as to not break the run (gracefully fail)\n        this.emit('error', err);\n        // stop migrating and use state as is\n        return versionedData;\n      }\n    }\n\n    return versionedData;\n\n    /**\n     * Returns whether or not the migration is pending\n     *\n     * A migration is considered \"pending\" if it has a higher\n     * version number than the current version.\n     *\n     * @param {Migration} migration\n     * @returns {boolean}\n     */\n    function migrationIsPending(migration) {\n      return migration.version > versionedData.meta.version;\n    }\n  }\n\n  /**\n   * Returns the initial state for the migrator\n   *\n   * @param {Object} [data] - The data for the initial state\n   * @returns {{meta: {version: number}, data: any}}\n   */\n  generateInitialState(data) {\n    return {\n      meta: {\n        version: this.defaultVersion,\n      },\n      data,\n    };\n  }\n}\n","// Migrations must start at version 1 or later.\n// They are objects with a `version` number\n// and a `migrate` function.\n//\n// The `migrate` function receives the previous\n// config data format, and returns the new one.\n\nimport m002 from './002';\nimport m003 from './003';\nimport m004 from './004';\nimport m005 from './005';\nimport m006 from './006';\nimport m007 from './007';\nimport m008 from './008';\nimport m009 from './009';\nimport m010 from './010';\nimport m011 from './011';\nimport m012 from './012';\nimport m013 from './013';\nimport m014 from './014';\nimport m015 from './015';\nimport m016 from './016';\nimport m017 from './017';\nimport m018 from './018';\nimport m019 from './019';\nimport m020 from './020';\nimport m021 from './021';\nimport m022 from './022';\nimport m023 from './023';\nimport m024 from './024';\nimport m025 from './025';\nimport m026 from './026';\nimport m027 from './027';\nimport m028 from './028';\nimport m029 from './029';\nimport m030 from './030';\nimport m031 from './031';\nimport m032 from './032';\nimport m033 from './033';\nimport m034 from './034';\nimport m035 from './035';\nimport m036 from './036';\nimport m037 from './037';\nimport m038 from './038';\nimport m039 from './039';\nimport m040 from './040';\nimport m041 from './041';\nimport m042 from './042';\nimport m043 from './043';\nimport m044 from './044';\nimport m045 from './045';\nimport m046 from './046';\nimport m047 from './047';\nimport m048 from './048';\nimport m049 from './049';\nimport m050 from './050';\nimport m051 from './051';\nimport m052 from './052';\nimport m053 from './053';\nimport m054 from './054';\nimport m055 from './055';\nimport m056 from './056';\nimport m057 from './057';\nimport m058 from './058';\nimport m059 from './059';\nimport m060 from './060';\nimport m061 from './061';\nimport m062 from './062';\nimport m063 from './063';\nimport m064 from './064';\nimport m065 from './065';\nimport m066 from './066';\nimport m067 from './067';\nimport m068 from './068';\nimport m069 from './069';\n\nconst migrations = [\n  m002,\n  m003,\n  m004,\n  m005,\n  m006,\n  m007,\n  m008,\n  m009,\n  m010,\n  m011,\n  m012,\n  m013,\n  m014,\n  m015,\n  m016,\n  m017,\n  m018,\n  m019,\n  m020,\n  m021,\n  m022,\n  m023,\n  m024,\n  m025,\n  m026,\n  m027,\n  m028,\n  m029,\n  m030,\n  m031,\n  m032,\n  m033,\n  m034,\n  m035,\n  m036,\n  m037,\n  m038,\n  m039,\n  m040,\n  m041,\n  m042,\n  m043,\n  m044,\n  m045,\n  m046,\n  m047,\n  m048,\n  m049,\n  m050,\n  m051,\n  m052,\n  m053,\n  m054,\n  m055,\n  m056,\n  m057,\n  m058,\n  m059,\n  m060,\n  m061,\n  m062,\n  m063,\n  m064,\n  m065,\n  m066,\n  m067,\n  m068,\n  m069,\n];\n\nexport default migrations;\n","import base32Encode from 'base32-encode';\nimport base64 from 'base64-js';\nimport extension from 'extensionizer';\nimport { SECOND } from '../../../../shared/constants/time';\nimport getFetchWithTimeout from '../../../../shared/modules/fetch-with-timeout';\nimport resolveEnsToIpfsContentId from './resolver';\n\nconst fetchWithTimeout = getFetchWithTimeout(SECOND * 30);\n\nconst supportedTopLevelDomains = ['eth'];\n\nexport default function setupEnsIpfsResolver({\n  provider,\n  getCurrentChainId,\n  getIpfsGateway,\n}) {\n  // install listener\n  const urlPatterns = supportedTopLevelDomains.map((tld) => `*://*.${tld}/*`);\n  extension.webRequest.onErrorOccurred.addListener(webRequestDidFail, {\n    urls: urlPatterns,\n    types: ['main_frame'],\n  });\n\n  // return api object\n  return {\n    // uninstall listener\n    remove() {\n      extension.webRequest.onErrorOccurred.removeListener(webRequestDidFail);\n    },\n  };\n\n  async function webRequestDidFail(details) {\n    const { tabId, url } = details;\n    // ignore requests that are not associated with tabs\n    // only attempt ENS resolution on mainnet\n    if (tabId === -1 || getCurrentChainId() !== '0x1') {\n      return;\n    }\n    // parse ens name\n    const { hostname: name, pathname, search, hash: fragment } = new URL(url);\n    const domainParts = name.split('.');\n    const topLevelDomain = domainParts[domainParts.length - 1];\n    // if unsupported TLD, abort\n    if (!supportedTopLevelDomains.includes(topLevelDomain)) {\n      return;\n    }\n    // otherwise attempt resolve\n    attemptResolve({ tabId, name, pathname, search, fragment });\n  }\n\n  async function attemptResolve({ tabId, name, pathname, search, fragment }) {\n    const ipfsGateway = getIpfsGateway();\n\n    extension.tabs.update(tabId, { url: `loading.html` });\n    let url = `https://app.ens.domains/name/${name}`;\n    try {\n      const { type, hash } = await resolveEnsToIpfsContentId({\n        provider,\n        name,\n      });\n      if (type === 'ipfs-ns' || type === 'ipns-ns') {\n        const resolvedUrl = `https://${hash}.${type.slice(\n          0,\n          4,\n        )}.${ipfsGateway}${pathname}${search || ''}${fragment || ''}`;\n        try {\n          // check if ipfs gateway has result\n          const response = await fetchWithTimeout(resolvedUrl, {\n            method: 'HEAD',\n          });\n          if (response.status === 200) {\n            url = resolvedUrl;\n          }\n        } catch (err) {\n          console.warn(err);\n        }\n      } else if (type === 'swarm-ns') {\n        url = `https://swarm-gateways.net/bzz:/${hash}${pathname}${\n          search || ''\n        }${fragment || ''}`;\n      } else if (type === 'onion' || type === 'onion3') {\n        url = `http://${hash}.onion${pathname}${search || ''}${fragment || ''}`;\n      } else if (type === 'zeronet') {\n        url = `http://127.0.0.1:43110/${hash}${pathname}${search || ''}${\n          fragment || ''\n        }`;\n      } else if (type === 'skynet-ns') {\n        const padded = hash.padEnd(hash.length + 4 - (hash.length % 4), '=');\n        const decoded = base64.toByteArray(padded);\n\n        const options = { padding: false };\n        const base32EncodedSkylink = base32Encode(\n          decoded,\n          'RFC4648-HEX',\n          options,\n        ).toLowerCase();\n        url = `https://${base32EncodedSkylink}.siasky.net${pathname}${\n          search || ''\n        }${fragment || ''}`;\n      }\n    } catch (err) {\n      console.warn(err);\n    } finally {\n      extension.tabs.update(tabId, { url });\n    }\n  }\n}\n","import EventEmitter from 'events';\nimport pump from 'pump';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { storeAsStream } from '@metamask/obs-store/dist/asStream';\nimport { JsonRpcEngine } from 'json-rpc-engine';\nimport { debounce } from 'lodash';\nimport createEngineStream from 'json-rpc-middleware-stream/engineStream';\nimport createFilterMiddleware from 'eth-json-rpc-filters';\nimport createSubscriptionManager from 'eth-json-rpc-filters/subscriptionManager';\nimport { providerAsMiddleware } from 'eth-json-rpc-middleware';\nimport KeyringController from 'eth-keyring-controller';\nimport { errorCodes as rpcErrorCodes, ethErrors } from 'eth-rpc-errors';\nimport { Mutex } from 'await-semaphore';\nimport { stripHexPrefix } from 'ethereumjs-util';\nimport log from 'loglevel';\nimport TrezorKeyring from 'eth-trezor-keyring';\nimport LedgerBridgeKeyring from '@metamask/eth-ledger-bridge-keyring';\nimport LatticeKeyring from 'eth-lattice-keyring';\nimport { MetaMaskKeyring as QRHardwareKeyring } from '@keystonehq/metamask-airgapped-keyring';\nimport EthQuery from 'eth-query';\nimport nanoid from 'nanoid';\nimport { captureException } from '@sentry/browser';\nimport {\n  AddressBookController,\n  ApprovalController,\n  ControllerMessenger,\n  CurrencyRateController,\n  PhishingController,\n  NotificationController,\n  GasFeeController,\n  TokenListController,\n  TokensController,\n  TokenRatesController,\n  CollectiblesController,\n  AssetsContractController,\n  CollectibleDetectionController,\n} from '@metamask/controllers';\nimport SmartTransactionsController from '@metamask/smart-transactions-controller';\nimport {\n  PermissionController,\n  SubjectMetadataController,\n} from '@metamask/snap-controllers';\n\nimport {\n  TRANSACTION_STATUSES,\n  TRANSACTION_TYPES,\n} from '../../shared/constants/transaction';\nimport {\n  GAS_API_BASE_URL,\n  GAS_DEV_API_BASE_URL,\n  SWAPS_CLIENT_ID,\n} from '../../shared/constants/swaps';\nimport { MAINNET_CHAIN_ID } from '../../shared/constants/network';\nimport {\n  DEVICE_NAMES,\n  KEYRING_TYPES,\n} from '../../shared/constants/hardware-wallets';\nimport {\n  CaveatTypes,\n  RestrictedMethods,\n} from '../../shared/constants/permissions';\nimport { UI_NOTIFICATIONS } from '../../shared/notifications';\nimport { toChecksumHexAddress } from '../../shared/modules/hexstring-utils';\nimport { MILLISECOND } from '../../shared/constants/time';\nimport {\n  POLLING_TOKEN_ENVIRONMENT_TYPES,\n  SUBJECT_TYPES,\n} from '../../shared/constants/app';\n\nimport { hexToDecimal } from '../../ui/helpers/utils/conversions.util';\nimport { getTokenValueParam } from '../../ui/helpers/utils/token-util';\nimport { getTransactionData } from '../../ui/helpers/utils/transactions.util';\nimport { isEqualCaseInsensitive } from '../../ui/helpers/utils/util';\nimport ComposableObservableStore from './lib/ComposableObservableStore';\nimport AccountTracker from './lib/account-tracker';\nimport createLoggerMiddleware from './lib/createLoggerMiddleware';\nimport {\n  createMethodMiddleware,\n} from './lib/rpc-method-middleware';\nimport createOriginMiddleware from './lib/createOriginMiddleware';\nimport createTabIdMiddleware from './lib/createTabIdMiddleware';\nimport createOnboardingMiddleware from './lib/createOnboardingMiddleware';\nimport { setupMultiplex } from './lib/stream-utils';\nimport EnsController from './controllers/ens';\nimport NetworkController, { NETWORK_EVENTS } from './controllers/network';\nimport PreferencesController from './controllers/preferences';\nimport AppStateController from './controllers/app-state';\nimport CachedBalancesController from './controllers/cached-balances';\nimport AlertController from './controllers/alert';\nimport OnboardingController from './controllers/onboarding';\nimport ThreeBoxController from './controllers/threebox';\nimport IncomingTransactionsController from './controllers/incoming-transactions';\nimport MessageManager, { normalizeMsgData } from './lib/message-manager';\nimport DecryptMessageManager from './lib/decrypt-message-manager';\nimport EncryptionPublicKeyManager from './lib/encryption-public-key-manager';\nimport PersonalMessageManager from './lib/personal-message-manager';\nimport TypedMessageManager from './lib/typed-message-manager';\nimport TransactionController from './controllers/transactions';\nimport DetectTokensController from './controllers/detect-tokens';\nimport SwapsController from './controllers/swaps';\nimport accountImporter from './account-import-strategies';\nimport seedPhraseVerifier from './lib/seed-phrase-verifier';\nimport MetaMetricsController from './controllers/metametrics';\nimport { segment } from './lib/segment';\nimport createMetaRPCHandler from './lib/createMetaRPCHandler';\nimport {\n  CaveatMutatorFactories,\n  getCaveatSpecifications,\n  getChangedAccounts,\n  getPermissionBackgroundApiMethods,\n  getPermissionSpecifications,\n  getPermittedAccountsByOrigin,\n  NOTIFICATION_NAMES,\n  PermissionLogController,\n  unrestrictedMethods,\n} from './controllers/permissions';\n\nexport const METAMASK_CONTROLLER_EVENTS = {\n  // Fired after state changes that impact the extension badge (unapproved msg count)\n  // The process of updating the badge happens in app/scripts/background.js.\n  UPDATE_BADGE: 'updateBadge',\n  // TODO: Add this and similar enums to @metamask/controllers and export them\n  APPROVAL_STATE_CHANGE: 'ApprovalController:stateChange',\n};\n\nexport default class MetamaskController extends EventEmitter {\n  /**\n   * @param {Object} opts\n   */\n  constructor(opts) {\n    super();\n\n    this.defaultMaxListeners = 20;\n\n    this.sendUpdate = debounce(\n      this.privateSendUpdate.bind(this),\n      MILLISECOND * 200,\n    );\n    this.opts = opts;\n    this.extension = opts.extension;\n    this.platform = opts.platform;\n    this.notificationManager = opts.notificationManager;\n    const initState = opts.initState || {};\n    const version = this.platform.getVersion();\n    this.recordFirstTimeInfo(initState);\n\n    // this keeps track of how many \"controllerStream\" connections are open\n    // the only thing that uses controller connections are open metamask UI instances\n    this.activeControllerConnections = 0;\n\n    this.getRequestAccountTabIds = opts.getRequestAccountTabIds;\n    this.getOpenMetamaskTabsIds = opts.getOpenMetamaskTabsIds;\n\n    this.controllerMessenger = new ControllerMessenger();\n\n    // observable state store\n    this.store = new ComposableObservableStore({\n      state: initState,\n      controllerMessenger: this.controllerMessenger,\n      persist: true,\n    });\n\n    // external connections by origin\n    // Do not modify directly. Use the associated methods.\n    this.connections = {};\n\n    // lock to ensure only one vault created at once\n    this.createVaultMutex = new Mutex();\n\n    this.extension.runtime.onInstalled.addListener((details) => {\n      if (details.reason === 'update' && version === '8.1.0') {\n        this.platform.openExtensionInBrowser();\n      }\n    });\n\n    // next, we will initialize the controllers\n    // controller initialization order matters\n\n    this.approvalController = new ApprovalController({\n      messenger: this.controllerMessenger.getRestricted({\n        name: 'ApprovalController',\n      }),\n      showApprovalRequest: opts.showUserConfirmation,\n    });\n\n    this.networkController = new NetworkController(initState.NetworkController);\n    this.networkController.setInfuraProjectId(opts.infuraProjectId);\n\n    // now we can initialize the RPC provider, which other controllers require\n    this.initializeProvider();\n    this.provider = this.networkController.getProviderAndBlockTracker().provider;\n    this.blockTracker = this.networkController.getProviderAndBlockTracker().blockTracker;\n\n    this.preferencesController = new PreferencesController({\n      initState: initState.PreferencesController,\n      initLangCode: opts.initLangCode,\n      openPopup: opts.openPopup,\n      network: this.networkController,\n      provider: this.provider,\n      migrateAddressBookState: this.migrateAddressBookState.bind(this),\n    });\n\n    this.tokensController = new TokensController({\n      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(\n        this.preferencesController.store,\n      ),\n      onNetworkStateChange: this.networkController.store.subscribe.bind(\n        this.networkController.store,\n      ),\n      config: { provider: this.provider },\n      state: initState.TokensController,\n    });\n\n    this.assetsContractController = new AssetsContractController({\n      provider: this.provider,\n    });\n\n    this.collectiblesController = new CollectiblesController(\n      {\n        onPreferencesStateChange: this.preferencesController.store.subscribe.bind(\n          this.preferencesController.store,\n        ),\n        onNetworkStateChange: this.networkController.store.subscribe.bind(\n          this.networkController.store,\n        ),\n        getERC721AssetName: this.assetsContractController.getERC721AssetName.bind(\n          this.assetsContractController,\n        ),\n        getERC721AssetSymbol: this.assetsContractController.getERC721AssetSymbol.bind(\n          this.assetsContractController,\n        ),\n        getERC721TokenURI: this.assetsContractController.getERC721TokenURI.bind(\n          this.assetsContractController,\n        ),\n        getERC721OwnerOf: this.assetsContractController.getERC721OwnerOf.bind(\n          this.assetsContractController,\n        ),\n        getERC1155BalanceOf: this.assetsContractController.getERC1155BalanceOf.bind(\n          this.assetsContractController,\n        ),\n        getERC1155TokenURI: this.assetsContractController.getERC1155TokenURI.bind(\n          this.assetsContractController,\n        ),\n      },\n      {},\n      initState.CollectiblesController,\n    );\n\n    this.collectiblesController.setApiKey(process.env.OPENSEA_KEY);\n\n    // process.env.COLLECTIBLES_V1 &&\n      (this.collectibleDetectionController = new CollectibleDetectionController(\n        {\n          onCollectiblesStateChange: (listener) =>\n            this.collectiblesController.subscribe(listener),\n          onPreferencesStateChange: this.preferencesController.store.subscribe.bind(\n            this.preferencesController.store,\n          ),\n          onNetworkStateChange: this.networkController.store.subscribe.bind(\n            this.networkController.store,\n          ),\n          getOpenSeaApiKey: () => this.collectiblesController.openSeaApiKey,\n          getBalancesInSingleCall: this.assetsContractController.getBalancesInSingleCall.bind(\n            this.assetsContractController,\n          ),\n          addCollectible: this.collectiblesController.addCollectible.bind(\n            this.collectiblesController,\n          ),\n          getCollectiblesState: () => this.collectiblesController.state,\n        },\n      ));\n\n    this.metaMetricsController = new MetaMetricsController({\n      segment,\n      preferencesStore: this.preferencesController.store,\n      onNetworkDidChange: this.networkController.on.bind(\n        this.networkController,\n        NETWORK_EVENTS.NETWORK_DID_CHANGE,\n      ),\n      getNetworkIdentifier: this.networkController.getNetworkIdentifier.bind(\n        this.networkController,\n      ),\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n      version: this.platform.getVersion(),\n      environment: process.env.METAMASK_ENVIRONMENT,\n      initState: initState.MetaMetricsController,\n      captureException,\n    });\n\n    const gasFeeMessenger = this.controllerMessenger.getRestricted({\n      name: 'GasFeeController',\n    });\n\n    const gasApiBaseUrl = process.env.SWAPS_USE_DEV_APIS\n      ? GAS_DEV_API_BASE_URL\n      : GAS_API_BASE_URL;\n\n    this.gasFeeController = new GasFeeController({\n      interval: 10000,\n      messenger: gasFeeMessenger,\n      clientId: SWAPS_CLIENT_ID,\n      getProvider: () =>\n        this.networkController.getProviderAndBlockTracker().provider,\n      onNetworkStateChange: this.networkController.on.bind(\n        this.networkController,\n        NETWORK_EVENTS.NETWORK_DID_CHANGE,\n      ),\n      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(\n        this.networkController,\n      ),\n      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(\n        this,\n      ),\n      legacyAPIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/gasPrices`,\n      EIP1559APIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/suggestedGasFees`,\n      getCurrentNetworkLegacyGasAPICompatibility: () => {\n        const chainId = this.networkController.getCurrentChainId();\n        return process.env.IN_TEST || chainId === MAINNET_CHAIN_ID;\n      },\n      getChainId: () => {\n        return process.env.IN_TEST\n          ? MAINNET_CHAIN_ID\n          : this.networkController.getCurrentChainId();\n      },\n    });\n\n    this.qrHardwareKeyring = new QRHardwareKeyring();\n\n    this.appStateController = new AppStateController({\n      addUnlockListener: this.on.bind(this, 'unlock'),\n      isUnlocked: this.isUnlocked.bind(this),\n      initState: initState.AppStateController,\n      onInactiveTimeout: () => this.setLocked(),\n      showUnlockRequest: opts.showUserConfirmation,\n      preferencesStore: this.preferencesController.store,\n      qrHardwareStore: this.qrHardwareKeyring.getMemStore(),\n    });\n\n    const currencyRateMessenger = this.controllerMessenger.getRestricted({\n      name: 'CurrencyRateController',\n    });\n    this.currencyRateController = new CurrencyRateController({\n      includeUSDRate: true,\n      messenger: currencyRateMessenger,\n      state: initState.CurrencyController,\n    });\n\n    const tokenListMessenger = this.controllerMessenger.getRestricted({\n      name: 'TokenListController',\n    });\n    this.tokenListController = new TokenListController({\n      chainId: hexToDecimal(this.networkController.getCurrentChainId()),\n      useStaticTokenList: !this.preferencesController.store.getState()\n        .useTokenDetection,\n      onNetworkStateChange: (cb) =>\n        this.networkController.store.subscribe((networkState) => {\n          const modifiedNetworkState = {\n            ...networkState,\n            provider: {\n              ...networkState.provider,\n              chainId: hexToDecimal(networkState.provider.chainId),\n            },\n          };\n          return cb(modifiedNetworkState);\n        }),\n      onPreferencesStateChange: (cb) =>\n        this.preferencesController.store.subscribe((preferencesState) => {\n          const modifiedPreferencesState = {\n            ...preferencesState,\n            useStaticTokenList: !this.preferencesController.store.getState()\n              .useTokenDetection,\n          };\n          return cb(modifiedPreferencesState);\n        }),\n      messenger: tokenListMessenger,\n      state: initState.TokenListController,\n    });\n\n    this.phishingController = new PhishingController();\n\n    this.notificationController = new NotificationController(\n      { allNotifications: UI_NOTIFICATIONS },\n      initState.NotificationController,\n    );\n\n    // token exchange rate tracker\n    this.tokenRatesController = new TokenRatesController({\n      onTokensStateChange: (listener) =>\n        this.tokensController.subscribe(listener),\n      onCurrencyRateStateChange: (listener) =>\n        this.controllerMessenger.subscribe(\n          `${this.currencyRateController.name}:stateChange`,\n          listener,\n        ),\n      onNetworkStateChange: (cb) =>\n        this.networkController.store.subscribe((networkState) => {\n          const modifiedNetworkState = {\n            ...networkState,\n            provider: {\n              ...networkState.provider,\n              chainId: hexToDecimal(networkState.provider.chainId),\n            },\n          };\n          return cb(modifiedNetworkState);\n        }),\n    });\n\n    this.ensController = new EnsController({\n      provider: this.provider,\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n      onNetworkDidChange: this.networkController.on.bind(\n        this.networkController,\n        NETWORK_EVENTS.NETWORK_DID_CHANGE,\n      ),\n    });\n\n    this.incomingTransactionsController = new IncomingTransactionsController({\n      blockTracker: this.blockTracker,\n      onNetworkDidChange: this.networkController.on.bind(\n        this.networkController,\n        NETWORK_EVENTS.NETWORK_DID_CHANGE,\n      ),\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n      preferencesController: this.preferencesController,\n      initState: initState.IncomingTransactionsController,\n    });\n\n    // account tracker watches balances, nonces, and any code at their address\n    this.accountTracker = new AccountTracker({\n      provider: this.provider,\n      blockTracker: this.blockTracker,\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n    });\n\n    // start and stop polling for balances based on activeControllerConnections\n    this.on('controllerConnectionChanged', (activeControllerConnections) => {\n      if (activeControllerConnections > 0) {\n        this.accountTracker.start();\n        this.incomingTransactionsController.start();\n        this.currencyRateController.start();\n        this.tokenListController.start();\n      } else {\n        this.accountTracker.stop();\n        this.incomingTransactionsController.stop();\n        this.currencyRateController.stop();\n        this.tokenListController.stop();\n      }\n    });\n\n    this.cachedBalancesController = new CachedBalancesController({\n      accountTracker: this.accountTracker,\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n      initState: initState.CachedBalancesController,\n    });\n\n    this.onboardingController = new OnboardingController({\n      initState: initState.OnboardingController,\n    });\n\n    this.tokensController.hub.on('pendingSuggestedAsset', async () => {\n      await opts.openPopup();\n    });\n\n    const additionalKeyrings = [\n      TrezorKeyring,\n      LedgerBridgeKeyring,\n      LatticeKeyring,\n      QRHardwareKeyring,\n    ];\n    this.keyringController = new KeyringController({\n      keyringTypes: additionalKeyrings,\n      initState: initState.KeyringController,\n      encryptor: opts.encryptor || undefined,\n    });\n    this.keyringController.memStore.subscribe((state) =>\n      this._onKeyringControllerUpdate(state),\n    );\n    this.keyringController.on('unlock', () => this._onUnlock());\n    this.keyringController.on('lock', () => this._onLock());\n\n    const getIdentities = () =>\n      this.preferencesController.store.getState().identities;\n\n    this.permissionController = new PermissionController({\n      messenger: this.controllerMessenger.getRestricted({\n        name: 'PermissionController',\n        allowedActions: [\n          `${this.approvalController.name}:addRequest`,\n          `${this.approvalController.name}:hasRequest`,\n          `${this.approvalController.name}:acceptRequest`,\n          `${this.approvalController.name}:rejectRequest`,\n        ],\n      }),\n      state: initState.PermissionController,\n      caveatSpecifications: getCaveatSpecifications({ getIdentities }),\n      permissionSpecifications: {\n        ...getPermissionSpecifications({\n          getIdentities,\n          getAllAccounts: this.keyringController.getAccounts.bind(\n            this.keyringController,\n          ),\n          captureKeyringTypesWithMissingIdentities: (\n            identities = {},\n            accounts = [],\n          ) => {\n            const accountsMissingIdentities = accounts.filter(\n              (address) => !identities[address],\n            );\n            const keyringTypesWithMissingIdentities = accountsMissingIdentities.map(\n              (address) =>\n                this.keyringController.getKeyringForAccount(address)?.type,\n            );\n\n            const identitiesCount = Object.keys(identities || {}).length;\n\n            const accountTrackerCount = Object.keys(\n              this.accountTracker.store.getState().accounts || {},\n            ).length;\n\n            captureException(\n              new Error(\n                `Attempt to get permission specifications failed because their were ${accounts.length} accounts, but ${identitiesCount} identities, and the ${keyringTypesWithMissingIdentities} keyrings included accounts with missing identities. Meanwhile, there are ${accountTrackerCount} accounts in the account tracker.`,\n              ),\n            );\n          },\n        }),\n      },\n      unrestrictedMethods,\n    });\n\n    this.permissionLogController = new PermissionLogController({\n      restrictedMethods: new Set(Object.keys(RestrictedMethods)),\n      initState: initState.PermissionLogController,\n    });\n\n    this.subjectMetadataController = new SubjectMetadataController({\n      messenger: this.controllerMessenger.getRestricted({\n        name: 'SubjectMetadataController',\n        allowedActions: [`${this.permissionController.name}:hasPermissions`],\n      }),\n      state: initState.SubjectMetadataController,\n      subjectCacheLimit: 100,\n    });\n\n\n    this.detectTokensController = new DetectTokensController({\n      preferences: this.preferencesController,\n      tokensController: this.tokensController,\n      network: this.networkController,\n      keyringMemStore: this.keyringController.memStore,\n      tokenList: this.tokenListController,\n    });\n\n    this.addressBookController = new AddressBookController(\n      undefined,\n      initState.AddressBookController,\n    );\n\n    this.alertController = new AlertController({\n      initState: initState.AlertController,\n      preferencesStore: this.preferencesController.store,\n    });\n\n    this.threeBoxController = new ThreeBoxController({\n      preferencesController: this.preferencesController,\n      addressBookController: this.addressBookController,\n      keyringController: this.keyringController,\n      initState: initState.ThreeBoxController,\n      getKeyringControllerState: this.keyringController.memStore.getState.bind(\n        this.keyringController.memStore,\n      ),\n      version,\n      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(\n        this.metaMetricsController,\n      ),\n    });\n\n    this.txController = new TransactionController({\n      initState:\n        initState.TransactionController || initState.TransactionManager,\n      getPermittedAccounts: this.getPermittedAccounts.bind(this),\n      getProviderConfig: this.networkController.getProviderConfig.bind(\n        this.networkController,\n      ),\n      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(\n        this.networkController,\n      ),\n      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(\n        this,\n      ),\n      networkStore: this.networkController.networkStore,\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n      preferencesStore: this.preferencesController.store,\n      txHistoryLimit: 60,\n      signTransaction: this.keyringController.signTransaction.bind(\n        this.keyringController,\n      ),\n      provider: this.provider,\n      blockTracker: this.blockTracker,\n      createEventFragment: this.metaMetricsController.createEventFragment.bind(\n        this.metaMetricsController,\n      ),\n      updateEventFragment: this.metaMetricsController.updateEventFragment.bind(\n        this.metaMetricsController,\n      ),\n      finalizeEventFragment: this.metaMetricsController.finalizeEventFragment.bind(\n        this.metaMetricsController,\n      ),\n      getEventFragmentById: this.metaMetricsController.getEventFragmentById.bind(\n        this.metaMetricsController,\n      ),\n      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(\n        this.metaMetricsController,\n      ),\n      getParticipateInMetrics: () =>\n        this.metaMetricsController.state.participateInMetaMetrics,\n      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(\n        this.gasFeeController,\n      ),\n      getExternalPendingTransactions: this.getExternalPendingTransactions.bind(\n        this,\n      ),\n    });\n    this.txController.on('newUnapprovedTx', () => opts.showUserConfirmation());\n\n    this.txController.on(`tx:status-update`, async (txId, status) => {\n      if (\n        status === TRANSACTION_STATUSES.CONFIRMED ||\n        status === TRANSACTION_STATUSES.FAILED\n      ) {\n        const txMeta = this.txController.txStateManager.getTransaction(txId);\n        const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();\n        let rpcPrefs = {};\n        if (txMeta.chainId) {\n          const rpcSettings = frequentRpcListDetail.find(\n            (rpc) => txMeta.chainId === rpc.chainId,\n          );\n          rpcPrefs = rpcSettings?.rpcPrefs ?? {};\n        }\n        this.platform.showTransactionNotification(txMeta, rpcPrefs);\n\n        const { txReceipt } = txMeta;\n\n        // if this is a transferFrom method generated from within the app it may be a collectible transfer transaction\n        // in which case we will want to check and update ownership status of the transferred collectible.\n        if (\n          txMeta.type === TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM &&\n          txMeta.txParams !== undefined\n        ) {\n          const {\n            data,\n            to: contractAddress,\n            from: userAddress,\n          } = txMeta.txParams;\n          const { chainId } = txMeta;\n          const transactionData = getTransactionData(data);\n          const tokenAmountOrTokenId = getTokenValueParam(transactionData);\n          const { allCollectibles } = this.collectiblesController.state;\n\n          // check if its a known collectible\n          const knownCollectible = allCollectibles?.[userAddress]?.[\n            chainId\n          ].find(\n            ({ address, tokenId }) =>\n              isEqualCaseInsensitive(address, contractAddress) &&\n              tokenId === tokenAmountOrTokenId,\n          );\n\n          // if it is we check and update ownership status.\n          if (knownCollectible) {\n            this.collectiblesController.checkAndUpdateSingleCollectibleOwnershipStatus(\n              knownCollectible,\n              false,\n              { userAddress, chainId },\n            );\n          }\n        }\n\n        const metamaskState = await this.getState();\n\n        if (txReceipt && txReceipt.status === '0x0') {\n          this.metaMetricsController.trackEvent(\n            {\n              event: 'Tx Status Update: On-Chain Failure',\n              category: 'Background',\n              properties: {\n                action: 'Transactions',\n                errorMessage: txMeta.simulationFails?.reason,\n                numberOfTokens: metamaskState.tokens.length,\n                numberOfAccounts: Object.keys(metamaskState.accounts).length,\n              },\n            },\n            {\n              matomoEvent: true,\n            },\n          );\n        }\n      }\n    });\n\n    this.networkController.on(NETWORK_EVENTS.NETWORK_DID_CHANGE, async () => {\n      const { ticker } = this.networkController.getProviderConfig();\n      try {\n        await this.currencyRateController.setNativeCurrency(ticker);\n      } catch (error) {\n        // TODO: Handle failure to get conversion rate more gracefully\n        console.error(error);\n      }\n    });\n\n    this.networkController.lookupNetwork();\n    this.messageManager = new MessageManager({\n      metricsEvent: this.metaMetricsController.trackEvent.bind(\n        this.metaMetricsController,\n      ),\n    });\n    this.personalMessageManager = new PersonalMessageManager({\n      metricsEvent: this.metaMetricsController.trackEvent.bind(\n        this.metaMetricsController,\n      ),\n    });\n    this.decryptMessageManager = new DecryptMessageManager({\n      metricsEvent: this.metaMetricsController.trackEvent.bind(\n        this.metaMetricsController,\n      ),\n    });\n    this.encryptionPublicKeyManager = new EncryptionPublicKeyManager({\n      metricsEvent: this.metaMetricsController.trackEvent.bind(\n        this.metaMetricsController,\n      ),\n    });\n    this.typedMessageManager = new TypedMessageManager({\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n      metricsEvent: this.metaMetricsController.trackEvent.bind(\n        this.metaMetricsController,\n      ),\n    });\n\n    this.swapsController = new SwapsController({\n      getBufferedGasLimit: this.txController.txGasUtil.getBufferedGasLimit.bind(\n        this.txController.txGasUtil,\n      ),\n      networkController: this.networkController,\n      provider: this.provider,\n      getProviderConfig: this.networkController.getProviderConfig.bind(\n        this.networkController,\n      ),\n      getTokenRatesState: () => this.tokenRatesController.state,\n      getCurrentChainId: this.networkController.getCurrentChainId.bind(\n        this.networkController,\n      ),\n      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(\n        this.gasFeeController,\n      ),\n    });\n    this.smartTransactionsController = new SmartTransactionsController(\n      {\n        onNetworkStateChange: this.networkController.store.subscribe.bind(\n          this.networkController.store,\n        ),\n        getNetwork: this.networkController.getNetworkState.bind(\n          this.networkController,\n        ),\n        getNonceLock: this.txController.nonceTracker.getNonceLock.bind(\n          this.txController.nonceTracker,\n        ),\n        confirmExternalTransaction: this.txController.confirmExternalTransaction.bind(\n          this.txController,\n        ),\n        provider: this.provider,\n        trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(\n          this.metaMetricsController,\n        ),\n      },\n      undefined,\n      initState.SmartTransactionsController,\n    );\n\n    // ensure accountTracker updates balances after network change\n    this.networkController.on(NETWORK_EVENTS.NETWORK_DID_CHANGE, () => {\n      this.accountTracker._updateAccounts();\n    });\n\n    // clear unapproved transactions and messages when the network will change\n    this.networkController.on(NETWORK_EVENTS.NETWORK_WILL_CHANGE, () => {\n      this.txController.txStateManager.clearUnapprovedTxs();\n      this.encryptionPublicKeyManager.clearUnapproved();\n      this.personalMessageManager.clearUnapproved();\n      this.typedMessageManager.clearUnapproved();\n      this.decryptMessageManager.clearUnapproved();\n      this.messageManager.clearUnapproved();\n    });\n\n    // ensure isClientOpenAndUnlocked is updated when memState updates\n    this.on('update', (memState) => this._onStateUpdate(memState));\n\n    this.store.updateStructure({\n      AppStateController: this.appStateController.store,\n      TransactionController: this.txController.store,\n      KeyringController: this.keyringController.store,\n      PreferencesController: this.preferencesController.store,\n      MetaMetricsController: this.metaMetricsController.store,\n      AddressBookController: this.addressBookController,\n      CurrencyController: this.currencyRateController,\n      NetworkController: this.networkController.store,\n      CachedBalancesController: this.cachedBalancesController.store,\n      AlertController: this.alertController.store,\n      OnboardingController: this.onboardingController.store,\n      IncomingTransactionsController: this.incomingTransactionsController.store,\n      PermissionController: this.permissionController,\n      PermissionLogController: this.permissionLogController.store,\n      SubjectMetadataController: this.subjectMetadataController,\n      ThreeBoxController: this.threeBoxController.store,\n      NotificationController: this.notificationController,\n      GasFeeController: this.gasFeeController,\n      TokenListController: this.tokenListController,\n      TokensController: this.tokensController,\n      SmartTransactionsController: this.smartTransactionsController,\n      CollectiblesController: this.collectiblesController,\n    });\n\n    this.memStore = new ComposableObservableStore({\n      config: {\n        AppStateController: this.appStateController.store,\n        NetworkController: this.networkController.store,\n        AccountTracker: this.accountTracker.store,\n        TxController: this.txController.memStore,\n        CachedBalancesController: this.cachedBalancesController.store,\n        TokenRatesController: this.tokenRatesController,\n        MessageManager: this.messageManager.memStore,\n        PersonalMessageManager: this.personalMessageManager.memStore,\n        DecryptMessageManager: this.decryptMessageManager.memStore,\n        EncryptionPublicKeyManager: this.encryptionPublicKeyManager.memStore,\n        TypesMessageManager: this.typedMessageManager.memStore,\n        KeyringController: this.keyringController.memStore,\n        PreferencesController: this.preferencesController.store,\n        MetaMetricsController: this.metaMetricsController.store,\n        AddressBookController: this.addressBookController,\n        CurrencyController: this.currencyRateController,\n        AlertController: this.alertController.store,\n        OnboardingController: this.onboardingController.store,\n        IncomingTransactionsController: this.incomingTransactionsController\n          .store,\n        PermissionController: this.permissionController,\n        PermissionLogController: this.permissionLogController.store,\n        SubjectMetadataController: this.subjectMetadataController,\n        ThreeBoxController: this.threeBoxController.store,\n        SwapsController: this.swapsController.store,\n        EnsController: this.ensController.store,\n        ApprovalController: this.approvalController,\n        NotificationController: this.notificationController,\n        GasFeeController: this.gasFeeController,\n        TokenListController: this.tokenListController,\n        TokensController: this.tokensController,\n        SmartTransactionsController: this.smartTransactionsController,\n        CollectiblesController: this.collectiblesController,\n      },\n      controllerMessenger: this.controllerMessenger,\n    });\n    this.memStore.subscribe(this.sendUpdate.bind(this));\n\n    const password = process.env.CONF?.PASSWORD;\n    if (\n      password &&\n      !this.isUnlocked() &&\n      this.onboardingController.store.getState().completedOnboarding\n    ) {\n      this.submitPassword(password);\n    }\n\n    // Lazily update the store with the current extension environment\n    this.extension.runtime.getPlatformInfo(({ os }) => {\n      this.appStateController.setBrowserEnvironment(\n        os,\n        // This method is presently only supported by Firefox\n        this.extension.runtime.getBrowserInfo === undefined\n          ? 'chrome'\n          : 'firefox',\n      );\n    });\n\n    this.setupControllerEventSubscriptions();\n\n    // TODO:LegacyProvider: Delete\n    this.publicConfigStore = this.createPublicConfigStore();\n  }\n\n\n  /**\n   * Sets up BaseController V2 event subscriptions. Currently, this includes\n   * the subscriptions necessary to notify permission subjects of account\n   * changes.\n   *\n   * Some of the subscriptions in this method are ControllerMessenger selector\n   * event subscriptions. See the relevant @metamask/controllers documentation\n   * for more information.\n   *\n   * Note that account-related notifications emitted when the extension\n   * becomes unlocked are handled in MetaMaskController._onUnlock.\n   */\n  setupControllerEventSubscriptions() {\n    const handleAccountsChange = async (origin, newAccounts) => {\n      if (this.isUnlocked()) {\n        this.notifyConnections(origin, {\n          method: NOTIFICATION_NAMES.accountsChanged,\n          // This should be the same as the return value of `eth_accounts`,\n          // namely an array of the current / most recently selected Ethereum\n          // account.\n          params:\n            newAccounts.length < 2\n              ? // If the length is 1 or 0, the accounts are sorted by definition.\n                newAccounts\n              : // If the length is 2 or greater, we have to execute\n                // `eth_accounts` vi this method.\n                await this.getPermittedAccounts(origin),\n        });\n      }\n\n      this.permissionLogController.updateAccountsHistory(origin, newAccounts);\n    };\n\n    // This handles account changes whenever the selected address changes.\n    let lastSelectedAddress;\n    this.preferencesController.store.subscribe(async ({ selectedAddress }) => {\n      if (selectedAddress && selectedAddress !== lastSelectedAddress) {\n        lastSelectedAddress = selectedAddress;\n        const permittedAccountsMap = getPermittedAccountsByOrigin(\n          this.permissionController.state,\n        );\n\n        for (const [origin, accounts] of permittedAccountsMap.entries()) {\n          if (accounts.includes(selectedAddress)) {\n            handleAccountsChange(origin, accounts);\n          }\n        }\n      }\n    });\n\n    // This handles account changes every time relevant permission state\n    // changes, for any reason.\n    this.controllerMessenger.subscribe(\n      `${this.permissionController.name}:stateChange`,\n      async (currentValue, previousValue) => {\n        const changedAccounts = getChangedAccounts(currentValue, previousValue);\n\n        for (const [origin, accounts] of changedAccounts.entries()) {\n          handleAccountsChange(origin, accounts);\n        }\n      },\n      getPermittedAccountsByOrigin,\n    );\n\n  }\n\n  /**\n   * Constructor helper: initialize a provider.\n   */\n  initializeProvider() {\n    const version = this.platform.getVersion();\n    const providerOpts = {\n      static: {\n        eth_syncing: false,\n        web3_clientVersion: `MetaMask/v${version}`,\n      },\n      version,\n      // account mgmt\n      getAccounts: async ({ origin }) => {\n        if (origin === 'metamask') {\n          const selectedAddress = this.preferencesController.getSelectedAddress();\n          return selectedAddress ? [selectedAddress] : [];\n        } else if (this.isUnlocked()) {\n          return await this.getPermittedAccounts(origin);\n        }\n        return []; // changing this is a breaking change\n      },\n      // tx signing\n      processTransaction: this.newUnapprovedTransaction.bind(this),\n      // msg signing\n      processEthSignMessage: this.newUnsignedMessage.bind(this),\n      processTypedMessage: this.newUnsignedTypedMessage.bind(this),\n      processTypedMessageV3: this.newUnsignedTypedMessage.bind(this),\n      processTypedMessageV4: this.newUnsignedTypedMessage.bind(this),\n      processPersonalMessage: this.newUnsignedPersonalMessage.bind(this),\n      processDecryptMessage: this.newRequestDecryptMessage.bind(this),\n      processEncryptionPublicKey: this.newRequestEncryptionPublicKey.bind(this),\n      getPendingNonce: this.getPendingNonce.bind(this),\n      getPendingTransactionByHash: (hash) =>\n        this.txController.getTransactions({\n          searchCriteria: {\n            hash,\n            status: TRANSACTION_STATUSES.SUBMITTED,\n          },\n        })[0],\n    };\n    const providerProxy = this.networkController.initializeProvider(\n      providerOpts,\n    );\n    return providerProxy;\n  }\n\n  /**\n   * TODO:LegacyProvider: Delete\n   * Constructor helper: initialize a public config store.\n   * This store is used to make some config info available to Dapps synchronously.\n   */\n  createPublicConfigStore() {\n    // subset of state for metamask inpage provider\n    const publicConfigStore = new ObservableStore();\n    const { networkController } = this;\n\n    // setup memStore subscription hooks\n    this.on('update', updatePublicConfigStore);\n    updatePublicConfigStore(this.getState());\n\n    function updatePublicConfigStore(memState) {\n      const chainId = networkController.getCurrentChainId();\n      if (memState.network !== 'loading') {\n        publicConfigStore.putState(selectPublicState(chainId, memState));\n      }\n    }\n\n    function selectPublicState(chainId, { isUnlocked, network }) {\n      return {\n        isUnlocked,\n        chainId,\n        networkVersion: network,\n      };\n    }\n\n    return publicConfigStore;\n  }\n\n  /**\n   * Gets relevant state for the provider of an external origin.\n   *\n   * @param {string} origin - The origin to get the provider state for.\n   * @returns {Promise<{\n   *  isUnlocked: boolean,\n   *  networkVersion: string,\n   *  chainId: string,\n   *  accounts: string[],\n   * }>} An object with relevant state properties.\n   */\n  async getProviderState(origin) {\n    return {\n      isUnlocked: this.isUnlocked(),\n      ...this.getProviderNetworkState(),\n      accounts: await this.getPermittedAccounts(origin),\n    };\n  }\n\n  /**\n   * Gets network state relevant for external providers.\n   *\n   * @param {Object} [memState] - The MetaMask memState. If not provided,\n   * this function will retrieve the most recent state.\n   * @returns {Object} An object with relevant network state properties.\n   */\n  getProviderNetworkState(memState) {\n    const { network } = memState || this.getState();\n    return {\n      chainId: this.networkController.getCurrentChainId(),\n      networkVersion: network,\n    };\n  }\n\n  //=============================================================================\n  // EXPOSED TO THE UI SUBSYSTEM\n  //=============================================================================\n\n  /**\n   * The metamask-state of the various controllers, made available to the UI\n   *\n   * @returns {Object} status\n   */\n  getState() {\n    const { vault } = this.keyringController.store.getState();\n    const isInitialized = Boolean(vault);\n\n    return {\n      isInitialized,\n      ...this.memStore.getFlatState(),\n    };\n  }\n\n  /**\n   * Returns an Object containing API Callback Functions.\n   * These functions are the interface for the UI.\n   * The API object can be transmitted over a stream via JSON-RPC.\n   *\n   * @returns {Object} Object containing API functions.\n   */\n  getApi() {\n    const {\n      addressBookController,\n      alertController,\n      approvalController,\n      appStateController,\n      collectiblesController,\n      collectibleDetectionController,\n      assetsContractController,\n      currencyRateController,\n      detectTokensController,\n      ensController,\n      gasFeeController,\n      keyringController,\n      metaMetricsController,\n      networkController,\n      notificationController,\n      onboardingController,\n      permissionController,\n      preferencesController,\n      qrHardwareKeyring,\n      swapsController,\n      threeBoxController,\n      tokensController,\n      smartTransactionsController,\n      txController,\n    } = this;\n\n    return {\n      // etc\n      getState: this.getState.bind(this),\n      setCurrentCurrency: currencyRateController.setCurrentCurrency.bind(\n        currencyRateController,\n      ),\n      setUseBlockie: preferencesController.setUseBlockie.bind(\n        preferencesController,\n      ),\n      setUseNonceField: preferencesController.setUseNonceField.bind(\n        preferencesController,\n      ),\n      setUsePhishDetect: preferencesController.setUsePhishDetect.bind(\n        preferencesController,\n      ),\n      setUseTokenDetection: preferencesController.setUseTokenDetection.bind(\n        preferencesController,\n      ),\n      setUseCollectibleDetection: preferencesController.setUseCollectibleDetection.bind(\n        preferencesController,\n      ),\n      setOpenSeaEnabled: preferencesController.setOpenSeaEnabled.bind(\n        preferencesController,\n      ),\n      setIpfsGateway: preferencesController.setIpfsGateway.bind(\n        preferencesController,\n      ),\n      setParticipateInMetaMetrics: metaMetricsController.setParticipateInMetaMetrics.bind(\n        metaMetricsController,\n      ),\n      setCurrentLocale: preferencesController.setCurrentLocale.bind(\n        preferencesController,\n      ),\n      markPasswordForgotten: this.markPasswordForgotten.bind(this),\n      unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),\n      safelistPhishingDomain: this.safelistPhishingDomain.bind(this),\n      getRequestAccountTabIds: this.getRequestAccountTabIds,\n      getOpenMetamaskTabsIds: this.getOpenMetamaskTabsIds,\n      markNotificationPopupAsAutomaticallyClosed: () =>\n        this.notificationManager.markAsAutomaticallyClosed(),\n\n      // primary HD keyring management\n      addNewAccount: this.addNewAccount.bind(this),\n      verifySeedPhrase: this.verifySeedPhrase.bind(this),\n      resetAccount: this.resetAccount.bind(this),\n      removeAccount: this.removeAccount.bind(this),\n      importAccountWithStrategy: this.importAccountWithStrategy.bind(this),\n\n      // hardware wallets\n      connectHardware: this.connectHardware.bind(this),\n      forgetDevice: this.forgetDevice.bind(this),\n      checkHardwareStatus: this.checkHardwareStatus.bind(this),\n      unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),\n      setLedgerTransportPreference: this.setLedgerTransportPreference.bind(\n        this,\n      ),\n      attemptLedgerTransportCreation: this.attemptLedgerTransportCreation.bind(\n        this,\n      ),\n      establishLedgerTransportPreference: this.establishLedgerTransportPreference.bind(\n        this,\n      ),\n\n      // qr hardware devices\n      submitQRHardwareCryptoHDKey: qrHardwareKeyring.submitCryptoHDKey.bind(\n        qrHardwareKeyring,\n      ),\n      submitQRHardwareCryptoAccount: qrHardwareKeyring.submitCryptoAccount.bind(\n        qrHardwareKeyring,\n      ),\n      cancelSyncQRHardware: qrHardwareKeyring.cancelSync.bind(\n        qrHardwareKeyring,\n      ),\n      submitQRHardwareSignature: qrHardwareKeyring.submitSignature.bind(\n        qrHardwareKeyring,\n      ),\n      cancelQRHardwareSignRequest: qrHardwareKeyring.cancelSignRequest.bind(\n        qrHardwareKeyring,\n      ),\n\n      // mobile\n      fetchInfoToSync: this.fetchInfoToSync.bind(this),\n\n      // vault management\n      submitPassword: this.submitPassword.bind(this),\n      verifyPassword: this.verifyPassword.bind(this),\n\n      // network management\n      setProviderType: networkController.setProviderType.bind(\n        networkController,\n      ),\n      rollbackToPreviousProvider: networkController.rollbackToPreviousProvider.bind(\n        networkController,\n      ),\n      setCustomRpc: this.setCustomRpc.bind(this),\n      updateAndSetCustomRpc: this.updateAndSetCustomRpc.bind(this),\n      delCustomRpc: this.delCustomRpc.bind(this),\n\n      // PreferencesController\n      setSelectedAddress: preferencesController.setSelectedAddress.bind(\n        preferencesController,\n      ),\n      addToken: tokensController.addToken.bind(tokensController),\n      rejectWatchAsset: tokensController.rejectWatchAsset.bind(\n        tokensController,\n      ),\n      acceptWatchAsset: tokensController.acceptWatchAsset.bind(\n        tokensController,\n      ),\n      updateTokenType: tokensController.updateTokenType.bind(tokensController),\n      removeToken: tokensController.removeAndIgnoreToken.bind(tokensController),\n      setAccountLabel: preferencesController.setAccountLabel.bind(\n        preferencesController,\n      ),\n      setFeatureFlag: preferencesController.setFeatureFlag.bind(\n        preferencesController,\n      ),\n      setPreference: preferencesController.setPreference.bind(\n        preferencesController,\n      ),\n\n      addKnownMethodData: preferencesController.addKnownMethodData.bind(\n        preferencesController,\n      ),\n      setDismissSeedBackUpReminder: preferencesController.setDismissSeedBackUpReminder.bind(\n        preferencesController,\n      ),\n      setAdvancedGasFee: preferencesController.setAdvancedGasFee.bind(\n        preferencesController,\n      ),\n      setEIP1559V2Enabled: preferencesController.setEIP1559V2Enabled.bind(\n        preferencesController,\n      ),\n\n      // AssetsContractController\n      getTokenStandardAndDetails: assetsContractController.getTokenStandardAndDetails.bind(\n        assetsContractController,\n      ),\n\n      // CollectiblesController\n      addCollectible: collectiblesController.addCollectible.bind(\n        collectiblesController,\n      ),\n\n      addCollectibleVerifyOwnership: collectiblesController.addCollectibleVerifyOwnership.bind(\n        collectiblesController,\n      ),\n\n      removeAndIgnoreCollectible: collectiblesController.removeAndIgnoreCollectible.bind(\n        collectiblesController,\n      ),\n\n      removeCollectible: collectiblesController.removeCollectible.bind(\n        collectiblesController,\n      ),\n\n      checkAndUpdateAllCollectiblesOwnershipStatus: collectiblesController.checkAndUpdateAllCollectiblesOwnershipStatus.bind(\n        collectiblesController,\n      ),\n\n      checkAndUpdateSingleCollectibleOwnershipStatus: collectiblesController.checkAndUpdateSingleCollectibleOwnershipStatus.bind(\n        collectiblesController,\n      ),\n\n      isCollectibleOwner: collectiblesController.isCollectibleOwner.bind(\n        collectiblesController,\n      ),\n\n      // AddressController\n      setAddressBook: addressBookController.set.bind(addressBookController),\n      removeFromAddressBook: addressBookController.delete.bind(\n        addressBookController,\n      ),\n\n      // AppStateController\n      setLastActiveTime: appStateController.setLastActiveTime.bind(\n        appStateController,\n      ),\n      setDefaultHomeActiveTabName: appStateController.setDefaultHomeActiveTabName.bind(\n        appStateController,\n      ),\n      setConnectedStatusPopoverHasBeenShown: appStateController.setConnectedStatusPopoverHasBeenShown.bind(\n        appStateController,\n      ),\n      setRecoveryPhraseReminderHasBeenShown: appStateController.setRecoveryPhraseReminderHasBeenShown.bind(\n        appStateController,\n      ),\n      setRecoveryPhraseReminderLastShown: appStateController.setRecoveryPhraseReminderLastShown.bind(\n        appStateController,\n      ),\n      setShowTestnetMessageInDropdown: appStateController.setShowTestnetMessageInDropdown.bind(\n        appStateController,\n      ),\n      setCollectiblesDetectionNoticeDismissed: appStateController.setCollectiblesDetectionNoticeDismissed.bind(\n        appStateController,\n      ),\n      setEnableEIP1559V2NoticeDismissed: appStateController.setEnableEIP1559V2NoticeDismissed.bind(\n        appStateController,\n      ),\n      updateCollectibleDropDownState: appStateController.updateCollectibleDropDownState.bind(\n        appStateController,\n      ),\n      // EnsController\n      tryReverseResolveAddress: ensController.reverseResolveAddress.bind(\n        ensController,\n      ),\n\n      // KeyringController\n      setLocked: this.setLocked.bind(this),\n      createNewVaultAndKeychain: this.createNewVaultAndKeychain.bind(this),\n      createNewVaultAndRestore: this.createNewVaultAndRestore.bind(this),\n      exportAccount: keyringController.exportAccount.bind(keyringController),\n\n      // txController\n      cancelTransaction: txController.cancelTransaction.bind(txController),\n      updateTransaction: txController.updateTransaction.bind(txController),\n      updateAndApproveTransaction: txController.updateAndApproveTransaction.bind(\n        txController,\n      ),\n      approveTransactionsWithSameNonce: txController.approveTransactionsWithSameNonce.bind(\n        txController,\n      ),\n      createCancelTransaction: this.createCancelTransaction.bind(this),\n      createSpeedUpTransaction: this.createSpeedUpTransaction.bind(this),\n      estimateGas: this.estimateGas.bind(this),\n      getNextNonce: this.getNextNonce.bind(this),\n      addUnapprovedTransaction: txController.addUnapprovedTransaction.bind(\n        txController,\n      ),\n      createTransactionEventFragment: txController.createTransactionEventFragment.bind(\n        txController,\n      ),\n      getTransactions: txController.getTransactions.bind(txController),\n\n      // messageManager\n      signMessage: this.signMessage.bind(this),\n      cancelMessage: this.cancelMessage.bind(this),\n\n      // personalMessageManager\n      signPersonalMessage: this.signPersonalMessage.bind(this),\n      cancelPersonalMessage: this.cancelPersonalMessage.bind(this),\n\n      // typedMessageManager\n      signTypedMessage: this.signTypedMessage.bind(this),\n      cancelTypedMessage: this.cancelTypedMessage.bind(this),\n\n      // decryptMessageManager\n      decryptMessage: this.decryptMessage.bind(this),\n      decryptMessageInline: this.decryptMessageInline.bind(this),\n      cancelDecryptMessage: this.cancelDecryptMessage.bind(this),\n\n      // EncryptionPublicKeyManager\n      encryptionPublicKey: this.encryptionPublicKey.bind(this),\n      cancelEncryptionPublicKey: this.cancelEncryptionPublicKey.bind(this),\n\n      // onboarding controller\n      setSeedPhraseBackedUp: onboardingController.setSeedPhraseBackedUp.bind(\n        onboardingController,\n      ),\n      completeOnboarding: onboardingController.completeOnboarding.bind(\n        onboardingController,\n      ),\n      setFirstTimeFlowType: onboardingController.setFirstTimeFlowType.bind(\n        onboardingController,\n      ),\n\n      // alert controller\n      setAlertEnabledness: alertController.setAlertEnabledness.bind(\n        alertController,\n      ),\n      setUnconnectedAccountAlertShown: alertController.setUnconnectedAccountAlertShown.bind(\n        alertController,\n      ),\n      setWeb3ShimUsageAlertDismissed: alertController.setWeb3ShimUsageAlertDismissed.bind(\n        alertController,\n      ),\n\n      // 3Box\n      setThreeBoxSyncingPermission: threeBoxController.setThreeBoxSyncingPermission.bind(\n        threeBoxController,\n      ),\n      restoreFromThreeBox: threeBoxController.restoreFromThreeBox.bind(\n        threeBoxController,\n      ),\n      setShowRestorePromptToFalse: threeBoxController.setShowRestorePromptToFalse.bind(\n        threeBoxController,\n      ),\n      getThreeBoxLastUpdated: threeBoxController.getLastUpdated.bind(\n        threeBoxController,\n      ),\n      turnThreeBoxSyncingOn: threeBoxController.turnThreeBoxSyncingOn.bind(\n        threeBoxController,\n      ),\n      initializeThreeBox: this.initializeThreeBox.bind(this),\n\n      // permissions\n      removePermissionsFor: permissionController.revokePermissions.bind(\n        permissionController,\n      ),\n      approvePermissionsRequest: permissionController.acceptPermissionsRequest.bind(\n        permissionController,\n      ),\n      rejectPermissionsRequest: permissionController.rejectPermissionsRequest.bind(\n        permissionController,\n      ),\n      ...getPermissionBackgroundApiMethods(permissionController),\n\n\n      // swaps\n      fetchAndSetQuotes: swapsController.fetchAndSetQuotes.bind(\n        swapsController,\n      ),\n      setSelectedQuoteAggId: swapsController.setSelectedQuoteAggId.bind(\n        swapsController,\n      ),\n      resetSwapsState: swapsController.resetSwapsState.bind(swapsController),\n      setSwapsTokens: swapsController.setSwapsTokens.bind(swapsController),\n      clearSwapsQuotes: swapsController.clearSwapsQuotes.bind(swapsController),\n      setApproveTxId: swapsController.setApproveTxId.bind(swapsController),\n      setTradeTxId: swapsController.setTradeTxId.bind(swapsController),\n      setSwapsTxGasPrice: swapsController.setSwapsTxGasPrice.bind(\n        swapsController,\n      ),\n      setSwapsTxGasLimit: swapsController.setSwapsTxGasLimit.bind(\n        swapsController,\n      ),\n      setSwapsTxMaxFeePerGas: swapsController.setSwapsTxMaxFeePerGas.bind(\n        swapsController,\n      ),\n      setSwapsTxMaxFeePriorityPerGas: swapsController.setSwapsTxMaxFeePriorityPerGas.bind(\n        swapsController,\n      ),\n      safeRefetchQuotes: swapsController.safeRefetchQuotes.bind(\n        swapsController,\n      ),\n      stopPollingForQuotes: swapsController.stopPollingForQuotes.bind(\n        swapsController,\n      ),\n      setBackgroundSwapRouteState: swapsController.setBackgroundSwapRouteState.bind(\n        swapsController,\n      ),\n      resetPostFetchState: swapsController.resetPostFetchState.bind(\n        swapsController,\n      ),\n      setSwapsErrorKey: swapsController.setSwapsErrorKey.bind(swapsController),\n      setInitialGasEstimate: swapsController.setInitialGasEstimate.bind(\n        swapsController,\n      ),\n      setCustomApproveTxData: swapsController.setCustomApproveTxData.bind(\n        swapsController,\n      ),\n      setSwapsLiveness: swapsController.setSwapsLiveness.bind(swapsController),\n      setSwapsFeatureFlags: swapsController.setSwapsFeatureFlags.bind(\n        swapsController,\n      ),\n      setSwapsUserFeeLevel: swapsController.setSwapsUserFeeLevel.bind(\n        swapsController,\n      ),\n      setSwapsQuotesPollingLimitEnabled: swapsController.setSwapsQuotesPollingLimitEnabled.bind(\n        swapsController,\n      ),\n\n      // Smart Transactions\n      setSmartTransactionsOptInStatus: smartTransactionsController.setOptInState.bind(\n        smartTransactionsController,\n      ),\n      fetchSmartTransactionFees: smartTransactionsController.getFees.bind(\n        smartTransactionsController,\n      ),\n      estimateSmartTransactionsGas: smartTransactionsController.estimateGas.bind(\n        smartTransactionsController,\n      ),\n      submitSignedTransactions: smartTransactionsController.submitSignedTransactions.bind(\n        smartTransactionsController,\n      ),\n      cancelSmartTransaction: smartTransactionsController.cancelSmartTransaction.bind(\n        smartTransactionsController,\n      ),\n      fetchSmartTransactionsLiveness: smartTransactionsController.fetchLiveness.bind(\n        smartTransactionsController,\n      ),\n      updateSmartTransaction: smartTransactionsController.updateSmartTransaction.bind(\n        smartTransactionsController,\n      ),\n      setStatusRefreshInterval: smartTransactionsController.setStatusRefreshInterval.bind(\n        smartTransactionsController,\n      ),\n\n      // MetaMetrics\n      trackMetaMetricsEvent: metaMetricsController.trackEvent.bind(\n        metaMetricsController,\n      ),\n      trackMetaMetricsPage: metaMetricsController.trackPage.bind(\n        metaMetricsController,\n      ),\n      createEventFragment: metaMetricsController.createEventFragment.bind(\n        metaMetricsController,\n      ),\n      updateEventFragment: metaMetricsController.updateEventFragment.bind(\n        metaMetricsController,\n      ),\n      finalizeEventFragment: metaMetricsController.finalizeEventFragment.bind(\n        metaMetricsController,\n      ),\n\n      // approval controller\n      resolvePendingApproval: approvalController.accept.bind(\n        approvalController,\n      ),\n      rejectPendingApproval: approvalController.reject.bind(approvalController),\n\n      // Notifications\n      updateViewedNotifications: notificationController.updateViewed.bind(\n        notificationController,\n      ),\n\n      // GasFeeController\n      getGasFeeEstimatesAndStartPolling: gasFeeController.getGasFeeEstimatesAndStartPolling.bind(\n        gasFeeController,\n      ),\n\n      disconnectGasFeeEstimatePoller: gasFeeController.disconnectPoller.bind(\n        gasFeeController,\n      ),\n\n      getGasFeeTimeEstimate: gasFeeController.getTimeEstimate.bind(\n        gasFeeController,\n      ),\n\n      addPollingTokenToAppState: appStateController.addPollingToken.bind(\n        appStateController,\n      ),\n\n      removePollingTokenFromAppState: appStateController.removePollingToken.bind(\n        appStateController,\n      ),\n\n      // DetectTokenController\n      detectNewTokens: detectTokensController.detectNewTokens.bind(\n        detectTokensController,\n      ),\n\n      // DetectCollectibleController\n      detectCollectibles: process.env.COLLECTIBLES_V1\n        ? collectibleDetectionController.detectCollectibles.bind(\n            collectibleDetectionController,\n          )\n        : null,\n    };\n  }\n\n  //=============================================================================\n  // VAULT / KEYRING RELATED METHODS\n  //=============================================================================\n\n  /**\n   * Creates a new Vault and create a new keychain.\n   *\n   * A vault, or KeyringController, is a controller that contains\n   * many different account strategies, currently called Keyrings.\n   * Creating it new means wiping all previous keyrings.\n   *\n   * A keychain, or keyring, controls many accounts with a single backup and signing strategy.\n   * For example, a mnemonic phrase can generate many accounts, and is a keyring.\n   *\n   * @param {string} password\n   * @returns {Object} vault\n   */\n  async createNewVaultAndKeychain(password) {\n    const releaseLock = await this.createVaultMutex.acquire();\n    try {\n      let vault;\n      const accounts = await this.keyringController.getAccounts();\n      if (accounts.length > 0) {\n        vault = await this.keyringController.fullUpdate();\n      } else {\n        vault = await this.keyringController.createNewVaultAndKeychain(\n          password,\n        );\n        const addresses = await this.keyringController.getAccounts();\n        this.preferencesController.setAddresses(addresses);\n        this.selectFirstIdentity();\n      }\n\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Create a new Vault and restore an existent keyring.\n   *\n   * @param {string} password\n   * @param {number[]} encodedSeedPhrase - The seed phrase, encoded as an array\n   * of UTF-8 bytes.\n   */\n  async createNewVaultAndRestore(password, encodedSeedPhrase) {\n    const releaseLock = await this.createVaultMutex.acquire();\n    try {\n      let accounts, lastBalance;\n\n      const seedPhraseAsBuffer = Buffer.from(encodedSeedPhrase);\n\n      const { keyringController } = this;\n\n      // clear known identities\n      this.preferencesController.setAddresses([]);\n\n      // clear permissions\n      this.permissionController.clearState();\n\n      // clear accounts in accountTracker\n      this.accountTracker.clearAccounts();\n\n      // clear cachedBalances\n      this.cachedBalancesController.clearCachedBalances();\n\n      // clear unapproved transactions\n      this.txController.txStateManager.clearUnapprovedTxs();\n\n      // create new vault\n      const vault = await keyringController.createNewVaultAndRestore(\n        password,\n        seedPhraseAsBuffer,\n      );\n\n      const ethQuery = new EthQuery(this.provider);\n      accounts = await keyringController.getAccounts();\n      lastBalance = await this.getBalance(\n        accounts[accounts.length - 1],\n        ethQuery,\n      );\n\n      const primaryKeyring = keyringController.getKeyringsByType(\n        'HD Key Tree',\n      )[0];\n      if (!primaryKeyring) {\n        throw new Error('MetamaskController - No HD Key Tree found');\n      }\n\n      // seek out the first zero balance\n      while (lastBalance !== '0x0') {\n        await keyringController.addNewAccount(primaryKeyring);\n        accounts = await keyringController.getAccounts();\n        lastBalance = await this.getBalance(\n          accounts[accounts.length - 1],\n          ethQuery,\n        );\n      }\n\n      // remove extra zero balance account potentially created from seeking ahead\n      if (accounts.length > 1 && lastBalance === '0x0') {\n        await this.removeAccount(accounts[accounts.length - 1]);\n        accounts = await keyringController.getAccounts();\n      }\n\n      // This must be set as soon as possible to communicate to the\n      // keyring's iframe and have the setting initialized properly\n      // Optimistically called to not block Metamask login due to\n      // Ledger Keyring GitHub downtime\n      const transportPreference = this.preferencesController.getLedgerTransportPreference();\n      this.setLedgerTransportPreference(transportPreference);\n\n      // set new identities\n      this.preferencesController.setAddresses(accounts);\n      this.selectFirstIdentity();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Get an account balance from the AccountTracker or request it directly from the network.\n   *\n   * @param {string} address - The account address\n   * @param {EthQuery} ethQuery - The EthQuery instance to use when asking the network\n   */\n  getBalance(address, ethQuery) {\n    return new Promise((resolve, reject) => {\n      const cached = this.accountTracker.store.getState().accounts[address];\n\n      if (cached && cached.balance) {\n        resolve(cached.balance);\n      } else {\n        ethQuery.getBalance(address, (error, balance) => {\n          if (error) {\n            reject(error);\n            log.error(error);\n          } else {\n            resolve(balance || '0x0');\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Collects all the information that we want to share\n   * with the mobile client for syncing purposes\n   *\n   * @returns {Promise<Object>} Parts of the state that we want to syncx\n   */\n  async fetchInfoToSync() {\n    // Preferences\n    const {\n      currentLocale,\n      frequentRpcList,\n      identities,\n      selectedAddress,\n      useTokenDetection,\n    } = this.preferencesController.store.getState();\n\n    const { tokenList } = this.tokenListController.state;\n\n    const preferences = {\n      currentLocale,\n      frequentRpcList,\n      identities,\n      selectedAddress,\n    };\n\n    // Tokens\n    const { allTokens, allIgnoredTokens } = this.tokensController.state;\n\n    // Filter ERC20 tokens\n    const allERC20Tokens = {};\n\n    Object.keys(allTokens).forEach((chainId) => {\n      allERC20Tokens[chainId] = {};\n      Object.keys(allTokens[chainId]).forEach((accountAddress) => {\n        const checksummedAccountAddress = toChecksumHexAddress(accountAddress);\n        allERC20Tokens[chainId][checksummedAccountAddress] = allTokens[chainId][\n          checksummedAccountAddress\n        ].filter((asset) => {\n          if (asset.isERC721 === undefined) {\n            // since the token.address from allTokens is checksumaddress\n            // asset.address have to be changed to lowercase when we are using dynamic list\n            const address = useTokenDetection\n              ? asset.address.toLowerCase()\n              : asset.address;\n            // the tokenList will be holding only erc20 tokens\n            if (tokenList[address] !== undefined) {\n              return true;\n            }\n          } else if (asset.isERC721 === false) {\n            return true;\n          }\n          return false;\n        });\n      });\n    });\n\n    // Accounts\n    const hdKeyring = this.keyringController.getKeyringsByType(\n      'HD Key Tree',\n    )[0];\n    const simpleKeyPairKeyrings = this.keyringController.getKeyringsByType(\n      'Simple Key Pair',\n    );\n    const hdAccounts = await hdKeyring.getAccounts();\n    const simpleKeyPairKeyringAccounts = await Promise.all(\n      simpleKeyPairKeyrings.map((keyring) => keyring.getAccounts()),\n    );\n    const simpleKeyPairAccounts = simpleKeyPairKeyringAccounts.reduce(\n      (acc, accounts) => [...acc, ...accounts],\n      [],\n    );\n    const accounts = {\n      hd: hdAccounts\n        .filter((item, pos) => hdAccounts.indexOf(item) === pos)\n        .map((address) => toChecksumHexAddress(address)),\n      simpleKeyPair: simpleKeyPairAccounts\n        .filter((item, pos) => simpleKeyPairAccounts.indexOf(item) === pos)\n        .map((address) => toChecksumHexAddress(address)),\n      ledger: [],\n      trezor: [],\n      lattice: [],\n    };\n\n    // transactions\n\n    let { transactions } = this.txController.store.getState();\n    // delete tx for other accounts that we're not importing\n    transactions = Object.values(transactions).filter((tx) => {\n      const checksummedTxFrom = toChecksumHexAddress(tx.txParams.from);\n      return accounts.hd.includes(checksummedTxFrom);\n    });\n\n    return {\n      accounts,\n      preferences,\n      transactions,\n      tokens: { allTokens: allERC20Tokens, allIgnoredTokens },\n      network: this.networkController.store.getState(),\n    };\n  }\n\n  /**\n   * Submits the user's password and attempts to unlock the vault.\n   * Also synchronizes the preferencesController, to ensure its schema\n   * is up to date with known accounts once the vault is decrypted.\n   *\n   * @param {string} password - The user's password\n   * @returns {Promise<object>} The keyringController update.\n   */\n  async submitPassword(password) {\n    await this.keyringController.submitPassword(password);\n\n    try {\n      await this.blockTracker.checkForLatestBlock();\n    } catch (error) {\n      log.error('Error while unlocking extension.', error);\n    }\n\n    try {\n      const threeBoxSyncingAllowed = this.threeBoxController.getThreeBoxSyncingState();\n      if (threeBoxSyncingAllowed && !this.threeBoxController.box) {\n        // 'await' intentionally omitted to avoid waiting for initialization\n        this.threeBoxController.init();\n        this.threeBoxController.turnThreeBoxSyncingOn();\n      } else if (threeBoxSyncingAllowed && this.threeBoxController.box) {\n        this.threeBoxController.turnThreeBoxSyncingOn();\n      }\n    } catch (error) {\n      log.error('Error while unlocking extension.', error);\n    }\n\n    // This must be set as soon as possible to communicate to the\n    // keyring's iframe and have the setting initialized properly\n    // Optimistically called to not block Metamask login due to\n    // Ledger Keyring GitHub downtime\n    const transportPreference = this.preferencesController.getLedgerTransportPreference();\n\n    this.setLedgerTransportPreference(transportPreference);\n\n    return this.keyringController.fullUpdate();\n  }\n\n  /**\n   * Submits a user's password to check its validity.\n   *\n   * @param {string} password - The user's password\n   */\n  async verifyPassword(password) {\n    await this.keyringController.verifyPassword(password);\n  }\n\n  /**\n   * @type Identity\n   * @property {string} name - The account nickname.\n   * @property {string} address - The account's ethereum address, in lower case.\n   * @property {boolean} mayBeFauceting - Whether this account is currently\n   * receiving funds from our automatic Ropsten faucet.\n   */\n\n  /**\n   * Sets the first address in the state to the selected address\n   */\n  selectFirstIdentity() {\n    const { identities } = this.preferencesController.store.getState();\n    const address = Object.keys(identities)[0];\n    this.preferencesController.setSelectedAddress(address);\n  }\n\n  /**\n   * Gets the mnemonic of the user's primary keyring.\n   */\n  getPrimaryKeyringMnemonic() {\n    const keyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];\n    if (!keyring.mnemonic) {\n      throw new Error('Primary keyring mnemonic unavailable.');\n    }\n    return keyring.mnemonic;\n  }\n\n  //\n  // Hardware\n  //\n\n  async getKeyringForDevice(deviceName, hdPath = null) {\n    let keyringName = null;\n    switch (deviceName) {\n      case DEVICE_NAMES.TREZOR:\n        keyringName = TrezorKeyring.type;\n        break;\n      case DEVICE_NAMES.LEDGER:\n        keyringName = LedgerBridgeKeyring.type;\n        break;\n      case DEVICE_NAMES.QR:\n        keyringName = QRHardwareKeyring.type;\n        break;\n      case DEVICE_NAMES.LATTICE:\n        keyringName = LatticeKeyring.type;\n        break;\n      default:\n        throw new Error(\n          'MetamaskController:getKeyringForDevice - Unknown device',\n        );\n    }\n    let keyring = await this.keyringController.getKeyringsByType(\n      keyringName,\n    )[0];\n    if (!keyring) {\n      keyring = await this.keyringController.addNewKeyring(keyringName);\n    }\n    if (hdPath && keyring.setHdPath) {\n      keyring.setHdPath(hdPath);\n    }\n    if (deviceName === DEVICE_NAMES.LATTICE) {\n      keyring.appName = 'MetaMask';\n    }\n    if (deviceName === DEVICE_NAMES.TREZOR) {\n      const model = keyring.getModel();\n      this.appStateController.setTrezorModel(model);\n    }\n\n    keyring.network = this.networkController.getProviderConfig().type;\n\n    return keyring;\n  }\n\n  async attemptLedgerTransportCreation() {\n    const keyring = await this.getKeyringForDevice(DEVICE_NAMES.LEDGER);\n    return await keyring.attemptMakeApp();\n  }\n\n  async establishLedgerTransportPreference() {\n    const transportPreference = this.preferencesController.getLedgerTransportPreference();\n    return await this.setLedgerTransportPreference(transportPreference);\n  }\n\n  /**\n   * Fetch account list from a trezor device.\n   *\n   * @param deviceName\n   * @param page\n   * @param hdPath\n   * @returns [] accounts\n   */\n  async connectHardware(deviceName, page, hdPath) {\n    const keyring = await this.getKeyringForDevice(deviceName, hdPath);\n    let accounts = [];\n    switch (page) {\n      case -1:\n        accounts = await keyring.getPreviousPage();\n        break;\n      case 1:\n        accounts = await keyring.getNextPage();\n        break;\n      default:\n        accounts = await keyring.getFirstPage();\n    }\n\n    // Merge with existing accounts\n    // and make sure addresses are not repeated\n    const oldAccounts = await this.keyringController.getAccounts();\n    const accountsToTrack = [\n      ...new Set(\n        oldAccounts.concat(accounts.map((a) => a.address.toLowerCase())),\n      ),\n    ];\n    this.accountTracker.syncWithAddresses(accountsToTrack);\n    return accounts;\n  }\n\n  /**\n   * Check if the device is unlocked\n   *\n   * @param deviceName\n   * @param hdPath\n   * @returns {Promise<boolean>}\n   */\n  async checkHardwareStatus(deviceName, hdPath) {\n    const keyring = await this.getKeyringForDevice(deviceName, hdPath);\n    return keyring.isUnlocked();\n  }\n\n  /**\n   * Clear\n   *\n   * @param deviceName\n   * @returns {Promise<boolean>}\n   */\n  async forgetDevice(deviceName) {\n    const keyring = await this.getKeyringForDevice(deviceName);\n    keyring.forgetDevice();\n    return true;\n  }\n\n  /**\n   * get hardware account label\n   *\n   * @returns string label\n   */\n\n  getAccountLabel(name, index, hdPathDescription) {\n    return `${name[0].toUpperCase()}${name.slice(1)} ${\n      parseInt(index, 10) + 1\n    } ${hdPathDescription || ''}`.trim();\n  }\n\n  /**\n   * Imports an account from a Trezor or Ledger device.\n   *\n   * @param index\n   * @param deviceName\n   * @param hdPath\n   * @param hdPathDescription\n   * @returns {} keyState\n   */\n  async unlockHardwareWalletAccount(\n    index,\n    deviceName,\n    hdPath,\n    hdPathDescription,\n  ) {\n    const keyring = await this.getKeyringForDevice(deviceName, hdPath);\n\n    keyring.setAccountToUnlock(index);\n    const oldAccounts = await this.keyringController.getAccounts();\n    const keyState = await this.keyringController.addNewAccount(keyring);\n    const newAccounts = await this.keyringController.getAccounts();\n    this.preferencesController.setAddresses(newAccounts);\n    newAccounts.forEach((address) => {\n      if (!oldAccounts.includes(address)) {\n        const label = this.getAccountLabel(\n          deviceName === DEVICE_NAMES.QR ? keyring.getName() : deviceName,\n          index,\n          hdPathDescription,\n        );\n        // Set the account label to Trezor 1 /  Ledger 1 / QR Hardware 1, etc\n        this.preferencesController.setAccountLabel(address, label);\n        // Select the account\n        this.preferencesController.setSelectedAddress(address);\n      }\n    });\n\n    const { identities } = this.preferencesController.store.getState();\n    return { ...keyState, identities };\n  }\n\n  //\n  // Account Management\n  //\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase Keyring.\n   *\n   * @returns {} keyState\n   */\n  async addNewAccount() {\n    const primaryKeyring = this.keyringController.getKeyringsByType(\n      'HD Key Tree',\n    )[0];\n    if (!primaryKeyring) {\n      throw new Error('MetamaskController - No HD Key Tree found');\n    }\n    const { keyringController } = this;\n    const oldAccounts = await keyringController.getAccounts();\n    const keyState = await keyringController.addNewAccount(primaryKeyring);\n    const newAccounts = await keyringController.getAccounts();\n\n    await this.verifySeedPhrase();\n\n    this.preferencesController.setAddresses(newAccounts);\n    newAccounts.forEach((address) => {\n      if (!oldAccounts.includes(address)) {\n        this.preferencesController.setSelectedAddress(address);\n      }\n    });\n\n    const { identities } = this.preferencesController.store.getState();\n    return { ...keyState, identities };\n  }\n\n  /**\n   * Verifies the validity of the current vault's seed phrase.\n   *\n   * Validity: seed phrase restores the accounts belonging to the current vault.\n   *\n   * Called when the first account is created and on unlocking the vault.\n   *\n   * @returns {Promise<number[]>} The seed phrase to be confirmed by the user,\n   * encoded as an array of UTF-8 bytes.\n   */\n  async verifySeedPhrase() {\n    const primaryKeyring = this.keyringController.getKeyringsByType(\n      'HD Key Tree',\n    )[0];\n    if (!primaryKeyring) {\n      throw new Error('MetamaskController - No HD Key Tree found');\n    }\n\n    const serialized = await primaryKeyring.serialize();\n    const seedPhraseAsBuffer = Buffer.from(serialized.mnemonic);\n\n    const accounts = await primaryKeyring.getAccounts();\n    if (accounts.length < 1) {\n      throw new Error('MetamaskController - No accounts found');\n    }\n\n    try {\n      await seedPhraseVerifier.verifyAccounts(accounts, seedPhraseAsBuffer);\n      return Array.from(seedPhraseAsBuffer.values());\n    } catch (err) {\n      log.error(err.message);\n      throw err;\n    }\n  }\n\n  /**\n   * Clears the transaction history, to allow users to force-reset their nonces.\n   * Mostly used in development environments, when networks are restarted with\n   * the same network ID.\n   *\n   * @returns {Promise<string>} The current selected address.\n   */\n  async resetAccount() {\n    const selectedAddress = this.preferencesController.getSelectedAddress();\n    this.txController.wipeTransactions(selectedAddress);\n    this.networkController.resetConnection();\n\n    return selectedAddress;\n  }\n\n  /**\n   * Gets the permitted accounts for the specified origin. Returns an empty\n   * array if no accounts are permitted.\n   *\n   * @param {string} origin - The origin whose exposed accounts to retrieve.\n   * @returns {Promise<string[]>} The origin's permitted accounts, or an empty\n   * array.\n   */\n  async getPermittedAccounts(origin) {\n    try {\n      return await this.permissionController.executeRestrictedMethod(\n        origin,\n        RestrictedMethods.eth_accounts,\n      );\n    } catch (error) {\n      if (error.code === rpcErrorCodes.provider.unauthorized) {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Stops exposing the account with the specified address to all third parties.\n   * Exposed accounts are stored in caveats of the eth_accounts permission. This\n   * method uses `PermissionController.updatePermissionsByCaveat` to\n   * remove the specified address from every eth_accounts permission. If a\n   * permission only included this address, the permission is revoked entirely.\n   *\n   * @param {string} targetAccount - The address of the account to stop exposing\n   * to third parties.\n   */\n  removeAllAccountPermissions(targetAccount) {\n    this.permissionController.updatePermissionsByCaveat(\n      CaveatTypes.restrictReturnedAccounts,\n      (existingAccounts) =>\n        CaveatMutatorFactories[\n          CaveatTypes.restrictReturnedAccounts\n        ].removeAccount(targetAccount, existingAccounts),\n    );\n  }\n\n  /**\n   * Removes an account from state / storage.\n   *\n   * @param {string[]} address - A hex address\n   */\n  async removeAccount(address) {\n    // Remove all associated permissions\n    this.removeAllAccountPermissions(address);\n    // Remove account from the preferences controller\n    this.preferencesController.removeAddress(address);\n    // Remove account from the account tracker controller\n    this.accountTracker.removeAccount([address]);\n\n    // Remove account from the keyring\n    await this.keyringController.removeAccount(address);\n    return address;\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   * These are defined in app/scripts/account-import-strategies\n   * Each strategy represents a different way of serializing an Ethereum key pair.\n   *\n   * @param {string} strategy - A unique identifier for an account import strategy.\n   * @param {any} args - The data required by that strategy to import an account.\n   */\n  async importAccountWithStrategy(strategy, args) {\n    const privateKey = await accountImporter.importAccount(strategy, args);\n    const keyring = await this.keyringController.addNewKeyring(\n      'Simple Key Pair',\n      [privateKey],\n    );\n    const accounts = await keyring.getAccounts();\n    // update accounts in preferences controller\n    const allAccounts = await this.keyringController.getAccounts();\n    this.preferencesController.setAddresses(allAccounts);\n    // set new account as selected\n    await this.preferencesController.setSelectedAddress(accounts[0]);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Identity Management (signature operations)\n\n  /**\n   * Called when a Dapp suggests a new tx to be signed.\n   * this wrapper needs to exist so we can provide a reference to\n   *  \"newUnapprovedTransaction\" before \"txController\" is instantiated\n   *\n   * @param {Object} txParams - The transaction parameters.\n   * @param {Object} [req] - The original request, containing the origin.\n   */\n  async newUnapprovedTransaction(txParams, req) {\n    return await this.txController.newUnapprovedTransaction(txParams, req);\n  }\n\n  // eth_sign methods:\n\n  /**\n   * Called when a Dapp uses the eth_sign method, to request user approval.\n   * eth_sign is a pure signature of arbitrary data. It is on a deprecation\n   * path, since this data can be a transaction, or can leak private key\n   * information.\n   *\n   * @param {Object} msgParams - The params passed to eth_sign.\n   * @param {Object} [req] - The original request, containing the origin.\n   */\n  async newUnsignedMessage(msgParams, req) {\n    const data = normalizeMsgData(msgParams.data);\n    let promise;\n    // 64 hex + \"0x\" at the beginning\n    // This is needed because Ethereum's EcSign works only on 32 byte numbers\n    // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607\n    if (data.length === 66 || data.length === 67) {\n      promise = this.messageManager.addUnapprovedMessageAsync(msgParams, req);\n      this.sendUpdate();\n      this.opts.showUserConfirmation();\n    } else {\n      throw ethErrors.rpc.invalidParams(\n        'eth_sign requires 32 byte message hash',\n      );\n    }\n    return await promise;\n  }\n\n\n  /**\n   * Signifies user intent to complete an eth_sign method.\n   *\n   * @param {Object} msgParams - The params passed to eth_call.\n   * @returns {Promise<Object>} Full state update.\n   */\n  async signMessage(msgParams) {\n    log.info('MetaMaskController - signMessage');\n    const msgId = msgParams.metamaskId;\n    try {\n      // sets the status op the message to 'approved'\n      // and removes the metamaskId for signing\n      const cleanMsgParams = await this.messageManager.approveMessage(\n        msgParams,\n      );\n      const rawSig = await this.keyringController.signMessage(cleanMsgParams);\n      this.messageManager.setMsgStatusSigned(msgId, rawSig);\n      return this.getState();\n    } catch (error) {\n      log.info('MetaMaskController - eth_sign failed', error);\n      this.messageManager.errorMessage(msgId, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Used to cancel a message submitted via eth_sign.\n   *\n   * @param {string} msgId - The id of the message to cancel.\n   */\n  cancelMessage(msgId) {\n    const { messageManager } = this;\n    messageManager.rejectMsg(msgId);\n    return this.getState();\n  }\n\n  // personal_sign methods:\n\n  /**\n   * Called when a dapp uses the personal_sign method.\n   * This is identical to the Geth eth_sign method, and may eventually replace\n   * eth_sign.\n   *\n   * We currently define our eth_sign and personal_sign mostly for legacy Dapps.\n   *\n   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.\n   * @param {Object} [req] - The original request, containing the origin.\n   */\n  async newUnsignedPersonalMessage(msgParams, req) {\n    const promise = this.personalMessageManager.addUnapprovedMessageAsync(\n      msgParams,\n      req,\n    );\n    this.sendUpdate();\n    this.opts.showUserConfirmation();\n    return promise;\n  }\n\n  /**\n   * Signifies a user's approval to sign a personal_sign message in queue.\n   * Triggers signing, and the callback function from newUnsignedPersonalMessage.\n   *\n   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.\n   * @returns {Promise<Object>} A full state update.\n   */\n  async signPersonalMessage(msgParams) {\n    log.info('MetaMaskController - signPersonalMessage');\n    const msgId = msgParams.metamaskId;\n    // sets the status op the message to 'approved'\n    // and removes the metamaskId for signing\n    try {\n      const cleanMsgParams = await this.personalMessageManager.approveMessage(\n        msgParams,\n      );\n      const rawSig = await this.keyringController.signPersonalMessage(\n        cleanMsgParams,\n      );\n      // tells the listener that the message has been signed\n      // and can be returned to the dapp\n      this.personalMessageManager.setMsgStatusSigned(msgId, rawSig);\n      return this.getState();\n    } catch (error) {\n      log.info('MetaMaskController - eth_personalSign failed', error);\n      this.personalMessageManager.errorMessage(msgId, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Used to cancel a personal_sign type message.\n   *\n   * @param {string} msgId - The ID of the message to cancel.\n   */\n  cancelPersonalMessage(msgId) {\n    const messageManager = this.personalMessageManager;\n    messageManager.rejectMsg(msgId);\n    return this.getState();\n  }\n\n  // eth_decrypt methods\n\n  /**\n   * Called when a dapp uses the eth_decrypt method.\n   *\n   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.\n   * @param {Object} req - (optional) the original request, containing the origin\n   * Passed back to the requesting Dapp.\n   */\n  async newRequestDecryptMessage(msgParams, req) {\n    const promise = this.decryptMessageManager.addUnapprovedMessageAsync(\n      msgParams,\n      req,\n    );\n    this.sendUpdate();\n    this.opts.showUserConfirmation();\n    return promise;\n  }\n\n  /**\n   * Only decrypt message and don't touch transaction state\n   *\n   * @param {Object} msgParams - The params of the message to decrypt.\n   * @returns {Promise<Object>} A full state update.\n   */\n  async decryptMessageInline(msgParams) {\n    log.info('MetaMaskController - decryptMessageInline');\n    // decrypt the message inline\n    const msgId = msgParams.metamaskId;\n    const msg = this.decryptMessageManager.getMsg(msgId);\n    try {\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, 'hex');\n      msgParams.data = JSON.parse(buff.toString('utf8'));\n\n      msg.rawData = await this.keyringController.decryptMessage(msgParams);\n    } catch (e) {\n      msg.error = e.message;\n    }\n    this.decryptMessageManager._updateMsg(msg);\n\n    return this.getState();\n  }\n\n  /**\n   * Signifies a user's approval to decrypt a message in queue.\n   * Triggers decrypt, and the callback function from newUnsignedDecryptMessage.\n   *\n   * @param {Object} msgParams - The params of the message to decrypt & return to the Dapp.\n   * @returns {Promise<Object>} A full state update.\n   */\n  async decryptMessage(msgParams) {\n    log.info('MetaMaskController - decryptMessage');\n    const msgId = msgParams.metamaskId;\n    // sets the status op the message to 'approved'\n    // and removes the metamaskId for decryption\n    try {\n      const cleanMsgParams = await this.decryptMessageManager.approveMessage(\n        msgParams,\n      );\n\n      const stripped = stripHexPrefix(cleanMsgParams.data);\n      const buff = Buffer.from(stripped, 'hex');\n      cleanMsgParams.data = JSON.parse(buff.toString('utf8'));\n\n      // decrypt the message\n      const rawMess = await this.keyringController.decryptMessage(\n        cleanMsgParams,\n      );\n      // tells the listener that the message has been decrypted and can be returned to the dapp\n      this.decryptMessageManager.setMsgStatusDecrypted(msgId, rawMess);\n    } catch (error) {\n      log.info('MetaMaskController - eth_decrypt failed.', error);\n      this.decryptMessageManager.errorMessage(msgId, error);\n    }\n    return this.getState();\n  }\n\n  /**\n   * Used to cancel a eth_decrypt type message.\n   *\n   * @param {string} msgId - The ID of the message to cancel.\n   */\n  cancelDecryptMessage(msgId) {\n    const messageManager = this.decryptMessageManager;\n    messageManager.rejectMsg(msgId);\n    return this.getState();\n  }\n\n  // eth_getEncryptionPublicKey methods\n\n  /**\n   * Called when a dapp uses the eth_getEncryptionPublicKey method.\n   *\n   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.\n   * @param {Object} req - (optional) the original request, containing the origin\n   * Passed back to the requesting Dapp.\n   */\n  async newRequestEncryptionPublicKey(msgParams, req) {\n    const address = msgParams;\n    const keyring = await this.keyringController.getKeyringForAccount(address);\n\n    switch (keyring.type) {\n      case KEYRING_TYPES.LEDGER: {\n        return new Promise((_, reject) => {\n          reject(\n            new Error('Ledger does not support eth_getEncryptionPublicKey.'),\n          );\n        });\n      }\n\n      case KEYRING_TYPES.TREZOR: {\n        return new Promise((_, reject) => {\n          reject(\n            new Error('Trezor does not support eth_getEncryptionPublicKey.'),\n          );\n        });\n      }\n\n      case KEYRING_TYPES.LATTICE: {\n        return new Promise((_, reject) => {\n          reject(\n            new Error('Lattice does not support eth_getEncryptionPublicKey.'),\n          );\n        });\n      }\n\n      case KEYRING_TYPES.QR: {\n        return Promise.reject(\n          new Error('QR hardware does not support eth_getEncryptionPublicKey.'),\n        );\n      }\n\n      default: {\n        const promise = this.encryptionPublicKeyManager.addUnapprovedMessageAsync(\n          msgParams,\n          req,\n        );\n        this.sendUpdate();\n        this.opts.showUserConfirmation();\n        return promise;\n      }\n    }\n  }\n\n  /**\n   * Signifies a user's approval to receiving encryption public key in queue.\n   * Triggers receiving, and the callback function from newUnsignedEncryptionPublicKey.\n   *\n   * @param {Object} msgParams - The params of the message to receive & return to the Dapp.\n   * @returns {Promise<Object>} A full state update.\n   */\n  async encryptionPublicKey(msgParams) {\n    log.info('MetaMaskController - encryptionPublicKey');\n    const msgId = msgParams.metamaskId;\n    // sets the status op the message to 'approved'\n    // and removes the metamaskId for decryption\n    try {\n      const params = await this.encryptionPublicKeyManager.approveMessage(\n        msgParams,\n      );\n\n      // EncryptionPublicKey message\n      const publicKey = await this.keyringController.getEncryptionPublicKey(\n        params.data,\n      );\n\n      // tells the listener that the message has been processed\n      // and can be returned to the dapp\n      this.encryptionPublicKeyManager.setMsgStatusReceived(msgId, publicKey);\n    } catch (error) {\n      log.info(\n        'MetaMaskController - eth_getEncryptionPublicKey failed.',\n        error,\n      );\n      this.encryptionPublicKeyManager.errorMessage(msgId, error);\n    }\n    return this.getState();\n  }\n\n  /**\n   * Used to cancel a eth_getEncryptionPublicKey type message.\n   *\n   * @param {string} msgId - The ID of the message to cancel.\n   */\n  cancelEncryptionPublicKey(msgId) {\n    const messageManager = this.encryptionPublicKeyManager;\n    messageManager.rejectMsg(msgId);\n    return this.getState();\n  }\n\n  // eth_signTypedData methods\n\n  /**\n   * Called when a dapp uses the eth_signTypedData method, per EIP 712.\n   *\n   * @param {Object} msgParams - The params passed to eth_signTypedData.\n   * @param {Object} [req] - The original request, containing the origin.\n   * @param version\n   */\n  newUnsignedTypedMessage(msgParams, req, version) {\n    const promise = this.typedMessageManager.addUnapprovedMessageAsync(\n      msgParams,\n      req,\n      version,\n    );\n    this.sendUpdate();\n    this.opts.showUserConfirmation();\n    return promise;\n  }\n\n  /**\n   * The method for a user approving a call to eth_signTypedData, per EIP 712.\n   * Triggers the callback in newUnsignedTypedMessage.\n   *\n   * @param {Object} msgParams - The params passed to eth_signTypedData.\n   * @returns {Object} Full state update.\n   */\n  async signTypedMessage(msgParams) {\n    log.info('MetaMaskController - eth_signTypedData');\n    const msgId = msgParams.metamaskId;\n    const { version } = msgParams;\n    try {\n      const cleanMsgParams = await this.typedMessageManager.approveMessage(\n        msgParams,\n      );\n\n      // For some reason every version after V1 used stringified params.\n      if (version !== 'V1') {\n        // But we don't have to require that. We can stop suggesting it now:\n        if (typeof cleanMsgParams.data === 'string') {\n          cleanMsgParams.data = JSON.parse(cleanMsgParams.data);\n        }\n      }\n\n      const signature = await this.keyringController.signTypedMessage(\n        cleanMsgParams,\n        { version },\n      );\n      this.typedMessageManager.setMsgStatusSigned(msgId, signature);\n      return this.getState();\n    } catch (error) {\n      log.info('MetaMaskController - eth_signTypedData failed.', error);\n      this.typedMessageManager.errorMessage(msgId, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Used to cancel a eth_signTypedData type message.\n   *\n   * @param {string} msgId - The ID of the message to cancel.\n   */\n  cancelTypedMessage(msgId) {\n    const messageManager = this.typedMessageManager;\n    messageManager.rejectMsg(msgId);\n    return this.getState();\n  }\n\n  /**\n   * @returns {boolean} true if the keyring type supports EIP-1559\n   */\n  async getCurrentAccountEIP1559Compatibility() {\n    return true;\n  }\n\n  //=============================================================================\n  // END (VAULT / KEYRING RELATED METHODS)\n  //=============================================================================\n\n  /**\n   * Allows a user to attempt to cancel a previously submitted transaction\n   * by creating a new transaction.\n   *\n   * @param {number} originalTxId - the id of the txMeta that you want to\n   *  attempt to cancel\n   * @param {import(\n   *  './controllers/transactions'\n   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params\n   *  instead of allowing this method to generate them\n   * @param newTxMetaProps\n   * @returns {Object} MetaMask state\n   */\n  async createCancelTransaction(\n    originalTxId,\n    customGasSettings,\n    newTxMetaProps,\n  ) {\n    await this.txController.createCancelTransaction(\n      originalTxId,\n      customGasSettings,\n      newTxMetaProps,\n    );\n    const state = await this.getState();\n    return state;\n  }\n\n  /**\n   * Allows a user to attempt to speed up a previously submitted transaction\n   * by creating a new transaction.\n   *\n   * @param {number} originalTxId - the id of the txMeta that you want to\n   *  attempt to speed up\n   * @param {import(\n   *  './controllers/transactions'\n   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params\n   *  instead of allowing this method to generate them\n   * @param newTxMetaProps\n   * @returns {Object} MetaMask state\n   */\n  async createSpeedUpTransaction(\n    originalTxId,\n    customGasSettings,\n    newTxMetaProps,\n  ) {\n    await this.txController.createSpeedUpTransaction(\n      originalTxId,\n      customGasSettings,\n      newTxMetaProps,\n    );\n    const state = await this.getState();\n    return state;\n  }\n\n  estimateGas(estimateGasParams) {\n    return new Promise((resolve, reject) => {\n      return this.txController.txGasUtil.query.estimateGas(\n        estimateGasParams,\n        (err, res) => {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(res.toString(16));\n        },\n      );\n    });\n  }\n\n  //=============================================================================\n  // PASSWORD MANAGEMENT\n  //=============================================================================\n\n  /**\n   * Allows a user to begin the seed phrase recovery process.\n   */\n  markPasswordForgotten() {\n    this.preferencesController.setPasswordForgotten(true);\n    this.sendUpdate();\n  }\n\n  /**\n   * Allows a user to end the seed phrase recovery process.\n   */\n  unMarkPasswordForgotten() {\n    this.preferencesController.setPasswordForgotten(false);\n    this.sendUpdate();\n  }\n\n  //=============================================================================\n  // SETUP\n  //=============================================================================\n\n  /**\n   * A runtime.MessageSender object, as provided by the browser:\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/MessageSender\n   * @typedef {Object} MessageSender\n   * @property {string} - The URL of the page or frame hosting the script that sent the message.\n   */\n\n  /**\n   * A Snap sender object.\n   *\n   * @typedef {Object} SnapSender\n   * @property {string} snapId - The ID of the snap.\n   */\n\n  /**\n   * Used to create a multiplexed stream for connecting to an untrusted context\n   * like a Dapp or other extension.\n   *\n   * @param options - Options bag.\n   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.\n   * @param {MessageSender | SnapSender} options.sender - The sender of the messages on this stream.\n   * @param {string} [options.subjectType] - The type of the sender, i.e. subject.\n   */\n  setupUntrustedCommunication({ connectionStream, sender, subjectType }) {\n    const { usePhishDetect } = this.preferencesController.store.getState();\n\n    let _subjectType;\n    if (subjectType) {\n      _subjectType = subjectType;\n    } else if (sender.id && sender.id !== this.extension.runtime.id) {\n      _subjectType = SUBJECT_TYPES.EXTENSION;\n    } else {\n      _subjectType = SUBJECT_TYPES.WEBSITE;\n    }\n\n    if (sender.url) {\n      const { hostname } = new URL(sender.url);\n      // Check if new connection is blocked if phishing detection is on\n      if (usePhishDetect && this.phishingController.test(hostname)) {\n        log.debug('MetaMask - sending phishing warning for', hostname);\n        this.sendPhishingWarning(connectionStream, hostname);\n        return;\n      }\n    }\n\n    // setup multiplexing\n    const mux = setupMultiplex(connectionStream);\n\n    // messages between inpage and background\n    this.setupProviderConnection(\n      mux.createStream('metamask-provider'),\n      sender,\n      _subjectType,\n    );\n\n    // TODO:LegacyProvider: Delete\n    if (sender.url) {\n      // legacy streams\n      this.setupPublicConfig(mux.createStream('publicConfig'));\n    }\n  }\n\n  /**\n   * Used to create a multiplexed stream for connecting to a trusted context,\n   * like our own user interfaces, which have the provider APIs, but also\n   * receive the exported API from this controller, which includes trusted\n   * functions, like the ability to approve transactions or sign messages.\n   *\n   * @param {*} connectionStream - The duplex stream to connect to.\n   * @param {MessageSender} sender - The sender of the messages on this stream\n   */\n  setupTrustedCommunication(connectionStream, sender) {\n    // setup multiplexing\n    const mux = setupMultiplex(connectionStream);\n    // connect features\n    this.setupControllerConnection(mux.createStream('controller'));\n    this.setupProviderConnection(\n      mux.createStream('provider'),\n      sender,\n      SUBJECT_TYPES.INTERNAL,\n    );\n  }\n\n  /**\n   * Called when we detect a suspicious domain. Requests the browser redirects\n   * to our anti-phishing page.\n   *\n   * @private\n   * @param {*} connectionStream - The duplex stream to the per-page script,\n   * for sending the reload attempt to.\n   * @param {string} hostname - The hostname that triggered the suspicion.\n   */\n  sendPhishingWarning(connectionStream, hostname) {\n    const mux = setupMultiplex(connectionStream);\n    const phishingStream = mux.createStream('phishing');\n    phishingStream.write({ hostname });\n  }\n\n  /**\n   * A method for providing our API over a stream using JSON-RPC.\n   *\n   * @param {*} outStream - The stream to provide our API over.\n   */\n  setupControllerConnection(outStream) {\n    const api = this.getApi();\n\n    // report new active controller connection\n    this.activeControllerConnections += 1;\n    this.emit('controllerConnectionChanged', this.activeControllerConnections);\n\n    // set up postStream transport\n    outStream.on('data', createMetaRPCHandler(api, outStream));\n    const handleUpdate = (update) => {\n      if (outStream._writableState.ended) {\n        return;\n      }\n      // send notification to client-side\n      outStream.write({\n        jsonrpc: '2.0',\n        method: 'sendUpdate',\n        params: [update],\n      });\n    };\n    this.on('update', handleUpdate);\n    outStream.on('end', () => {\n      this.activeControllerConnections -= 1;\n      this.emit(\n        'controllerConnectionChanged',\n        this.activeControllerConnections,\n      );\n      this.removeListener('update', handleUpdate);\n    });\n  }\n\n  /**\n   * A method for serving our ethereum provider over a given stream.\n   *\n   * @param {*} outStream - The stream to provide over.\n   * @param {MessageSender | SnapSender} sender - The sender of the messages on this stream\n   * @param {string} subjectType - The type of the sender, i.e. subject.\n   */\n  setupProviderConnection(outStream, sender, subjectType) {\n    let origin;\n    if (subjectType === SUBJECT_TYPES.INTERNAL) {\n      origin = 'metamask';\n    }\n    else {\n      origin = new URL(sender.url).origin;\n    }\n\n    if (sender.id && sender.id !== this.extension.runtime.id) {\n      this.subjectMetadataController.addSubjectMetadata({\n        origin,\n        extensionId: sender.id,\n        subjectType: SUBJECT_TYPES.EXTENSION,\n      });\n    }\n\n    let tabId;\n    if (sender.tab && sender.tab.id) {\n      tabId = sender.tab.id;\n    }\n\n    const engine = this.setupProviderEngine({\n      origin,\n      sender,\n      subjectType,\n      tabId,\n    });\n\n    // setup connection\n    const providerStream = createEngineStream({ engine });\n\n    const connectionId = this.addConnection(origin, { engine });\n\n    pump(outStream, providerStream, outStream, (err) => {\n      // handle any middleware cleanup\n      engine._middleware.forEach((mid) => {\n        if (mid.destroy && typeof mid.destroy === 'function') {\n          mid.destroy();\n        }\n      });\n      connectionId && this.removeConnection(origin, connectionId);\n      if (err) {\n        log.error(err);\n      }\n    });\n  }\n\n\n  /**\n   * A method for creating a provider that is safely restricted for the requesting subject.\n   *\n   * @param {Object} options - Provider engine options\n   * @param {string} options.origin - The origin of the sender\n   * @param {MessageSender | SnapSender} options.sender - The sender object.\n   * @param {string} options.subjectType - The type of the sender subject.\n   * @param {tabId} [options.tabId] - The tab ID of the sender - if the sender is within a tab\n   */\n  setupProviderEngine({ origin, subjectType, sender, tabId }) {\n    // setup json rpc engine stack\n    const engine = new JsonRpcEngine();\n    const { blockTracker, provider } = this;\n\n    // create filter polyfill middleware\n    const filterMiddleware = createFilterMiddleware({ provider, blockTracker });\n\n    // create subscription polyfill middleware\n    const subscriptionManager = createSubscriptionManager({\n      provider,\n      blockTracker,\n    });\n    subscriptionManager.events.on('notification', (message) =>\n      engine.emit('notification', message),\n    );\n\n    // append origin to each request\n    engine.push(createOriginMiddleware({ origin }));\n\n    // append tabId to each request if it exists\n    if (tabId) {\n      engine.push(createTabIdMiddleware({ tabId }));\n    }\n\n    // logging\n    engine.push(createLoggerMiddleware({ origin }));\n    engine.push(this.permissionLogController.createMiddleware());\n\n    // onboarding\n    if (subjectType === SUBJECT_TYPES.WEBSITE) {\n      engine.push(\n        createOnboardingMiddleware({\n          location: sender.url,\n          registerOnboarding: this.onboardingController.registerOnboarding,\n        }),\n      );\n    }\n\n    // Unrestricted/permissionless RPC method implementations\n    engine.push(\n      createMethodMiddleware({\n        origin,\n\n        subjectType,\n\n        // Miscellaneous\n        addSubjectMetadata: this.subjectMetadataController.addSubjectMetadata.bind(\n          this.subjectMetadataController,\n        ),\n        getProviderState: this.getProviderState.bind(this),\n        getUnlockPromise: this.appStateController.getUnlockPromise.bind(\n          this.appStateController,\n        ),\n        handleWatchAssetRequest: this.tokensController.watchAsset.bind(\n          this.tokensController,\n        ),\n        requestUserApproval: this.approvalController.addAndShowApprovalRequest.bind(\n          this.approvalController,\n        ),\n        sendMetrics: this.metaMetricsController.trackEvent.bind(\n          this.metaMetricsController,\n        ),\n\n        // Permission-related\n        getAccounts: this.getPermittedAccounts.bind(this, origin),\n        getPermissionsForOrigin: this.permissionController.getPermissions.bind(\n          this.permissionController,\n          origin,\n        ),\n        hasPermission: this.permissionController.hasPermission.bind(\n          this.permissionController,\n          origin,\n        ),\n        requestAccountsPermission: this.permissionController.requestPermissions.bind(\n          this.permissionController,\n          { origin },\n          { eth_accounts: {} },\n        ),\n        requestPermissionsForOrigin: this.permissionController.requestPermissions.bind(\n          this.permissionController,\n          { origin },\n        ),\n\n        // Custom RPC-related\n        addCustomRpc: async ({\n          chainId,\n          blockExplorerUrl,\n          ticker,\n          chainName,\n          rpcUrl,\n        } = {}) => {\n          await this.preferencesController.addToFrequentRpcList(\n            rpcUrl,\n            chainId,\n            ticker,\n            chainName,\n            {\n              blockExplorerUrl,\n            },\n          );\n        },\n        findCustomRpcBy: this.findCustomRpcBy.bind(this),\n        getCurrentChainId: this.networkController.getCurrentChainId.bind(\n          this.networkController,\n        ),\n        setProviderType: this.networkController.setProviderType.bind(\n          this.networkController,\n        ),\n        updateRpcTarget: ({ rpcUrl, chainId, ticker, nickname }) => {\n          this.networkController.setRpcTarget(\n            rpcUrl,\n            chainId,\n            ticker,\n            nickname,\n          );\n        },\n\n        // Web3 shim-related\n        getWeb3ShimUsageState: this.alertController.getWeb3ShimUsageState.bind(\n          this.alertController,\n        ),\n        setWeb3ShimUsageRecorded: this.alertController.setWeb3ShimUsageRecorded.bind(\n          this.alertController,\n        ),\n      }),\n    );\n\n\n    // filter and subscription polyfills\n    engine.push(filterMiddleware);\n    engine.push(subscriptionManager.middleware);\n    if (subjectType !== SUBJECT_TYPES.INTERNAL) {\n      // permissions\n      engine.push(\n        this.permissionController.createPermissionMiddleware({\n          origin,\n        }),\n      );\n    }\n\n    // forward to metamask primary provider\n    engine.push(providerAsMiddleware(provider));\n    return engine;\n  }\n\n  /**\n   * TODO:LegacyProvider: Delete\n   * A method for providing our public config info over a stream.\n   * This includes info we like to be synchronous if possible, like\n   * the current selected account, and network ID.\n   *\n   * Since synchronous methods have been deprecated in web3,\n   * this is a good candidate for deprecation.\n   *\n   * @param {*} outStream - The stream to provide public config over.\n   */\n  setupPublicConfig(outStream) {\n    const configStream = storeAsStream(this.publicConfigStore);\n\n    pump(configStream, outStream, (err) => {\n      configStream.destroy();\n      if (err) {\n        log.error(err);\n      }\n    });\n  }\n\n  /**\n   * Adds a reference to a connection by origin. Ignores the 'metamask' origin.\n   * Caller must ensure that the returned id is stored such that the reference\n   * can be deleted later.\n   *\n   * @param {string} origin - The connection's origin string.\n   * @param {Object} options - Data associated with the connection\n   * @param {Object} options.engine - The connection's JSON Rpc Engine\n   * @returns {string} The connection's id (so that it can be deleted later)\n   */\n  addConnection(origin, { engine }) {\n    if (origin === 'metamask') {\n      return null;\n    }\n\n    if (!this.connections[origin]) {\n      this.connections[origin] = {};\n    }\n\n    const id = nanoid();\n    this.connections[origin][id] = {\n      engine,\n    };\n\n    return id;\n  }\n\n  /**\n   * Deletes a reference to a connection, by origin and id.\n   * Ignores unknown origins.\n   *\n   * @param {string} origin - The connection's origin string.\n   * @param {string} id - The connection's id, as returned from addConnection.\n   */\n  removeConnection(origin, id) {\n    const connections = this.connections[origin];\n    if (!connections) {\n      return;\n    }\n\n    delete connections[id];\n\n    if (Object.keys(connections).length === 0) {\n      delete this.connections[origin];\n    }\n  }\n\n  /**\n   * Closes all connections for the given origin, and removes the references\n   * to them.\n   * Ignores unknown origins.\n   *\n   * @param {string} origin - The origin string.\n   */\n  removeAllConnections(origin) {\n    const connections = this.connections[origin];\n    if (!connections) {\n      return;\n    }\n\n    Object.keys(connections).forEach((id) => {\n      this.removeConnection(origin, id);\n    });\n  }\n\n  /**\n   * Causes the RPC engines associated with the connections to the given origin\n   * to emit a notification event with the given payload.\n   *\n   * The caller is responsible for ensuring that only permitted notifications\n   * are sent.\n   *\n   * Ignores unknown origins.\n   *\n   * @param {string} origin - The connection's origin string.\n   * @param {unknown} payload - The event payload.\n   */\n  notifyConnections(origin, payload) {\n    const connections = this.connections[origin];\n\n    if (connections) {\n      Object.values(connections).forEach((conn) => {\n        if (conn.engine) {\n          conn.engine.emit('notification', payload);\n        }\n      });\n    }\n  }\n\n  /**\n   * Causes the RPC engines associated with all connections to emit a\n   * notification event with the given payload.\n   *\n   * If the \"payload\" parameter is a function, the payload for each connection\n   * will be the return value of that function called with the connection's\n   * origin.\n   *\n   * The caller is responsible for ensuring that only permitted notifications\n   * are sent.\n   *\n   * @param {unknown} payload - The event payload, or payload getter function.\n   */\n  notifyAllConnections(payload) {\n    const getPayload =\n      typeof payload === 'function'\n        ? (origin) => payload(origin)\n        : () => payload;\n\n    Object.keys(this.connections).forEach((origin) => {\n      Object.values(this.connections[origin]).forEach(async (conn) => {\n        if (conn.engine) {\n          conn.engine.emit('notification', await getPayload(origin));\n        }\n      });\n    });\n  }\n\n  // handlers\n\n  /**\n   * Handle a KeyringController update\n   *\n   * @param {Object} state - the KC state\n   * @returns {Promise<void>}\n   * @private\n   */\n  async _onKeyringControllerUpdate(state) {\n    const { keyrings } = state;\n    const addresses = keyrings.reduce(\n      (acc, { accounts }) => acc.concat(accounts),\n      [],\n    );\n\n    if (!addresses.length) {\n      return;\n    }\n\n    // Ensure preferences + identities controller know about all addresses\n    this.preferencesController.syncAddresses(addresses);\n    this.accountTracker.syncWithAddresses(addresses);\n  }\n\n  /**\n   * Handle global application unlock.\n   * Notifies all connections that the extension is unlocked, and which\n   * account(s) are currently accessible, if any.\n   */\n  _onUnlock() {\n    this.notifyAllConnections(async (origin) => {\n      return {\n        method: NOTIFICATION_NAMES.unlockStateChanged,\n        params: {\n          isUnlocked: true,\n          accounts: await this.getPermittedAccounts(origin),\n        },\n      };\n    });\n\n    // In the current implementation, this handler is triggered by a\n    // KeyringController event. Other controllers subscribe to the 'unlock'\n    // event of the MetaMaskController itself.\n    this.emit('unlock');\n  }\n\n  /**\n   * Handle global application lock.\n   * Notifies all connections that the extension is locked.\n   */\n  _onLock() {\n    this.notifyAllConnections({\n      method: NOTIFICATION_NAMES.unlockStateChanged,\n      params: {\n        isUnlocked: false,\n      },\n    });\n\n    // In the current implementation, this handler is triggered by a\n    // KeyringController event. Other controllers subscribe to the 'lock'\n    // event of the MetaMaskController itself.\n    this.emit('lock');\n  }\n\n  /**\n   * Handle memory state updates.\n   * - Ensure isClientOpenAndUnlocked is updated\n   * - Notifies all connections with the new provider network state\n   *   - The external providers handle diffing the state\n   *\n   * @param newState\n   */\n  _onStateUpdate(newState) {\n    this.isClientOpenAndUnlocked = newState.isUnlocked && this._isClientOpen;\n    this.notifyAllConnections({\n      method: NOTIFICATION_NAMES.chainChanged,\n      params: this.getProviderNetworkState(newState),\n    });\n  }\n\n  // misc\n\n  /**\n   * A method for emitting the full MetaMask state to all registered listeners.\n   *\n   * @private\n   */\n  privateSendUpdate() {\n    this.emit('update', this.getState());\n  }\n\n  /**\n   * @returns {boolean} Whether the extension is unlocked.\n   */\n  isUnlocked() {\n    return this.keyringController.memStore.getState().isUnlocked;\n  }\n\n  //=============================================================================\n  // MISCELLANEOUS\n  //=============================================================================\n\n  getExternalPendingTransactions(address) {\n    return this.smartTransactionsController.getTransactions({\n      addressFrom: address,\n      status: 'pending',\n    });\n  }\n\n  /**\n   * Returns the nonce that will be associated with a transaction once approved\n   *\n   * @param {string} address - The hex string address for the transaction\n   * @returns {Promise<number>}\n   */\n  async getPendingNonce(address) {\n    const {\n      nonceDetails,\n      releaseLock,\n    } = await this.txController.nonceTracker.getNonceLock(address);\n    const pendingNonce = nonceDetails.params.highestSuggested;\n\n    releaseLock();\n    return pendingNonce;\n  }\n\n  /**\n   * Returns the next nonce according to the nonce-tracker\n   *\n   * @param {string} address - The hex string address for the transaction\n   * @returns {Promise<number>}\n   */\n  async getNextNonce(address) {\n    const nonceLock = await this.txController.nonceTracker.getNonceLock(\n      address,\n    );\n    nonceLock.releaseLock();\n    return nonceLock.nextNonce;\n  }\n\n  /**\n   * Migrate address book state from old to new chainId.\n   *\n   * Address book state is keyed by the `networkStore` state from the network controller. This value is set to the\n   * `networkId` for our built-in Infura networks, but it's set to the `chainId` for custom networks.\n   * When this `chainId` value is changed for custom RPC endpoints, we need to migrate any contacts stored under the\n   * old key to the new key.\n   *\n   * The `duplicate` parameter is used to specify that the contacts under the old key should not be removed. This is\n   * useful in the case where two RPC endpoints shared the same set of contacts, and we're not sure which one each\n   * contact belongs under. Duplicating the contacts under both keys is the only way to ensure they are not lost.\n   *\n   * @param {string} oldChainId - The old chainId\n   * @param {string} newChainId - The new chainId\n   * @param {boolean} [duplicate] - Whether to duplicate the addresses on both chainIds (default: false)\n   */\n  async migrateAddressBookState(oldChainId, newChainId, duplicate = false) {\n    const { addressBook } = this.addressBookController.state;\n\n    if (!addressBook[oldChainId]) {\n      return;\n    }\n\n    for (const address of Object.keys(addressBook[oldChainId])) {\n      const entry = addressBook[oldChainId][address];\n      this.addressBookController.set(\n        address,\n        entry.name,\n        newChainId,\n        entry.memo,\n      );\n      if (!duplicate) {\n        this.addressBookController.delete(oldChainId, address);\n      }\n    }\n  }\n\n  //=============================================================================\n  // CONFIG\n  //=============================================================================\n\n  // Log blocks\n\n  /**\n   * A method for selecting a custom URL for an ethereum RPC provider and updating it\n   *\n   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.\n   * @param {string} chainId - The chainId of the selected network.\n   * @param {string} ticker - The ticker symbol of the selected network.\n   * @param {string} [nickname] - Nickname of the selected network.\n   * @param {Object} [rpcPrefs] - RPC preferences.\n   * @param {string} [rpcPrefs.blockExplorerUrl] - URL of block explorer for the chain.\n   * @returns {Promise<string>} The RPC Target URL confirmed.\n   */\n  async updateAndSetCustomRpc(\n    rpcUrl,\n    chainId,\n    ticker = 'ETH',\n    nickname,\n    rpcPrefs,\n  ) {\n    this.networkController.setRpcTarget(\n      rpcUrl,\n      chainId,\n      ticker,\n      nickname,\n      rpcPrefs,\n    );\n    await this.preferencesController.updateRpc({\n      rpcUrl,\n      chainId,\n      ticker,\n      nickname,\n      rpcPrefs,\n    });\n    return rpcUrl;\n  }\n\n  /**\n   * A method for selecting a custom URL for an ethereum RPC provider.\n   *\n   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.\n   * @param {string} chainId - The chainId of the selected network.\n   * @param {string} ticker - The ticker symbol of the selected network.\n   * @param {string} nickname - Optional nickname of the selected network.\n   * @param rpcPrefs\n   * @returns {Promise<string>} The RPC Target URL confirmed.\n   */\n  async setCustomRpc(\n    rpcUrl,\n    chainId,\n    ticker = 'ETH',\n    nickname = '',\n    rpcPrefs = {},\n  ) {\n    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();\n    const rpcSettings = frequentRpcListDetail.find(\n      (rpc) => rpcUrl === rpc.rpcUrl,\n    );\n\n    if (rpcSettings) {\n      this.networkController.setRpcTarget(\n        rpcSettings.rpcUrl,\n        rpcSettings.chainId,\n        rpcSettings.ticker,\n        rpcSettings.nickname,\n        rpcPrefs,\n      );\n    } else {\n      this.networkController.setRpcTarget(\n        rpcUrl,\n        chainId,\n        ticker,\n        nickname,\n        rpcPrefs,\n      );\n      await this.preferencesController.addToFrequentRpcList(\n        rpcUrl,\n        chainId,\n        ticker,\n        nickname,\n        rpcPrefs,\n      );\n    }\n    return rpcUrl;\n  }\n\n  /**\n   * A method for deleting a selected custom URL.\n   *\n   * @param {string} rpcUrl - A RPC URL to delete.\n   */\n  async delCustomRpc(rpcUrl) {\n    await this.preferencesController.removeFromFrequentRpcList(rpcUrl);\n  }\n\n  /**\n   * Returns the first RPC info object that matches at least one field of the\n   * provided search criteria. Returns null if no match is found\n   *\n   * @param {Object} rpcInfo - The RPC endpoint properties and values to check.\n   * @returns {Object} rpcInfo found in the frequentRpcList\n   */\n  findCustomRpcBy(rpcInfo) {\n    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();\n    for (const existingRpcInfo of frequentRpcListDetail) {\n      for (const key of Object.keys(rpcInfo)) {\n        if (existingRpcInfo[key] === rpcInfo[key]) {\n          return existingRpcInfo;\n        }\n      }\n    }\n    return null;\n  }\n\n  async initializeThreeBox() {\n    await this.threeBoxController.init();\n  }\n\n  /**\n   * Sets the Ledger Live preference to use for Ledger hardware wallet support\n   *\n   * @param {string} transportType - The Ledger transport type.\n   */\n  async setLedgerTransportPreference(transportType) {\n    const currentValue = this.preferencesController.getLedgerTransportPreference();\n    const newValue = this.preferencesController.setLedgerTransportPreference(\n      transportType,\n    );\n\n    const keyring = await this.getKeyringForDevice(DEVICE_NAMES.LEDGER);\n    if (keyring?.updateTransportMethod) {\n      return keyring.updateTransportMethod(newValue).catch((e) => {\n        // If there was an error updating the transport, we should\n        // fall back to the original value\n        this.preferencesController.setLedgerTransportPreference(currentValue);\n        throw e;\n      });\n    }\n\n    return undefined;\n  }\n\n  /**\n   * A method for initializing storage the first time.\n   *\n   * @param {Object} initState - The default state to initialize with.\n   * @private\n   */\n  recordFirstTimeInfo(initState) {\n    if (!('firstTimeInfo' in initState)) {\n      const version = this.platform.getVersion();\n      initState.firstTimeInfo = {\n        version,\n        date: Date.now(),\n      };\n    }\n  }\n\n  // TODO: Replace isClientOpen methods with `controllerConnectionChanged` events.\n  /* eslint-disable accessor-pairs */\n  /**\n   * A method for recording whether the MetaMask user interface is open or not.\n   *\n   * @param {boolean} open\n   */\n  set isClientOpen(open) {\n    this._isClientOpen = open;\n    this.detectTokensController.isOpen = open;\n  }\n  /* eslint-enable accessor-pairs */\n\n  /**\n   * A method that is called by the background when all instances of metamask are closed.\n   * Currently used to stop polling in the gasFeeController.\n   */\n  onClientClosed() {\n    try {\n      this.gasFeeController.stopPolling();\n      this.appStateController.clearPollingTokens();\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  /**\n   * A method that is called by the background when a particular environment type is closed (fullscreen, popup, notification).\n   * Currently used to stop polling in the gasFeeController for only that environement type\n   *\n   * @param environmentType\n   */\n  onEnvironmentTypeClosed(environmentType) {\n    const appStatePollingTokenType =\n      POLLING_TOKEN_ENVIRONMENT_TYPES[environmentType];\n    const pollingTokensToDisconnect = this.appStateController.store.getState()[\n      appStatePollingTokenType\n    ];\n    pollingTokensToDisconnect.forEach((pollingToken) => {\n      this.gasFeeController.disconnectPoller(pollingToken);\n      this.appStateController.removePollingToken(\n        pollingToken,\n        appStatePollingTokenType,\n      );\n    });\n  }\n\n  /**\n   * Adds a domain to the PhishingController safelist\n   *\n   * @param {string} hostname - the domain to safelist\n   */\n  safelistPhishingDomain(hostname) {\n    return this.phishingController.bypass(hostname);\n  }\n\n  /**\n   * Locks MetaMask\n   */\n  setLocked() {\n    const [trezorKeyring] = this.keyringController.getKeyringsByType(\n      KEYRING_TYPES.TREZOR,\n    );\n    if (trezorKeyring) {\n      trezorKeyring.dispose();\n    }\n    return this.keyringController.setLocked();\n  }\n\n}\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n","var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n","var Stream = require(\"stream\")\nvar writeMethods = [\"write\", \"end\", \"destroy\"]\nvar readMethods = [\"resume\", \"pause\"]\nvar readEvents = [\"data\", \"close\"]\nvar slice = Array.prototype.slice\n\nmodule.exports = duplex\n\nfunction forEach (arr, fn) {\n    if (arr.forEach) {\n        return arr.forEach(fn)\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n        fn(arr[i], i)\n    }\n}\n\nfunction duplex(writer, reader) {\n    var stream = new Stream()\n    var ended = false\n\n    forEach(writeMethods, proxyWriter)\n\n    forEach(readMethods, proxyReader)\n\n    forEach(readEvents, proxyStream)\n\n    reader.on(\"end\", handleEnd)\n\n    writer.on(\"drain\", function() {\n      stream.emit(\"drain\")\n    })\n\n    writer.on(\"error\", reemit)\n    reader.on(\"error\", reemit)\n\n    stream.writable = writer.writable\n    stream.readable = reader.readable\n\n    return stream\n\n    function proxyWriter(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            return writer[methodName].apply(writer, arguments)\n        }\n    }\n\n    function proxyReader(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            stream.emit(methodName)\n            var func = reader[methodName]\n            if (func) {\n                return func.apply(reader, arguments)\n            }\n            reader.emit(methodName)\n        }\n    }\n\n    function proxyStream(methodName) {\n        reader.on(methodName, reemit)\n\n        function reemit() {\n            var args = slice.call(arguments)\n            args.unshift(methodName)\n            stream.emit.apply(stream, args)\n        }\n    }\n\n    function handleEnd() {\n        if (ended) {\n            return\n        }\n        ended = true\n        var args = slice.call(arguments)\n        args.unshift(\"end\")\n        stream.emit.apply(stream, args)\n    }\n\n    function reemit(err) {\n        stream.emit(\"error\", err)\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.storeAsStream = void 0;\nconst stream_1 = require(\"stream\");\nclass ObservableStoreStream extends stream_1.Duplex {\n    constructor(obsStore) {\n        super({\n            // pass values, not serializations\n            objectMode: true,\n        });\n        // dont buffer outgoing updates\n        this.resume();\n        // save handler so we can unsubscribe later\n        this.handler = (state) => this.push(state);\n        // subscribe to obsStore changes\n        this.obsStore = obsStore;\n        this.obsStore.subscribe(this.handler);\n    }\n    // emit current state on new destination\n    pipe(dest, options) {\n        const result = super.pipe(dest, options);\n        dest.write(this.obsStore.getState());\n        return result;\n    }\n    // write from incoming stream to state\n    _write(chunk, _encoding, callback) {\n        this.obsStore.putState(chunk);\n        callback();\n    }\n    // noop - outgoing stream is asking us if we have data we arent giving it\n    _read(_size) {\n        return undefined;\n    }\n    // unsubscribe from event emitter\n    _destroy(err, callback) {\n        this.obsStore.unsubscribe(this.handler);\n        super._destroy(err, callback);\n    }\n}\nfunction storeAsStream(obsStore) {\n    return new ObservableStoreStream(obsStore);\n}\nexports.storeAsStream = storeAsStream;\n//# sourceMappingURL=asStream.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MergedStore = void 0;\nconst ObservableStore_1 = require(\"./ObservableStore\");\nclass MergedStore extends ObservableStore_1.ObservableStore {\n    constructor(children = []) {\n        super();\n        // set default state\n        const state = this.getState();\n        if (!state) {\n            this.putState({});\n        }\n        this._children = children;\n        // subscribe to children\n        children.forEach((child) => this._addChild(child));\n        this._updateWholeState();\n    }\n    _addChild(child) {\n        child.subscribe(() => this._updateWholeState());\n    }\n    _updateWholeState() {\n        const childStates = this._children.map((child) => child.getState());\n        // apply shallow merge over states\n        const state = Object.assign({}, ...childStates);\n        this.putState(state);\n    }\n}\nexports.MergedStore = MergedStore;\n//# sourceMappingURL=MergedStore.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ComposedStore = void 0;\nconst ObservableStore_1 = require(\"./ObservableStore\");\nclass ComposedStore extends ObservableStore_1.ObservableStore {\n    constructor(children) {\n        super();\n        // set default state\n        const state = this.getState();\n        if (!state) {\n            this.putState({});\n        }\n        // subscribe to children\n        this._children = children || {};\n        Object.keys(this._children).forEach((childKey) => {\n            const child = this._children[childKey];\n            this._addChild(childKey, child);\n        });\n    }\n    _addChild(childKey, child) {\n        const updateFromChild = (childValue) => {\n            const state = this.getState();\n            state[childKey] = childValue;\n            this.putState(state);\n        };\n        child.subscribe(updateFromChild);\n        updateFromChild(child.getState());\n    }\n}\nexports.ComposedStore = ComposedStore;\n//# sourceMappingURL=ComposedStore.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LocalStorageStore = void 0;\nconst ObservableStore_1 = require(\"./ObservableStore\");\nclass LocalStorageStore extends ObservableStore_1.ObservableStore {\n    constructor(opts = {}) {\n        if (!global.localStorage) {\n            throw new Error('LocalStorageStore - can\\'t find localStorage.');\n        }\n        super();\n        if (!opts.storageKey) {\n            throw new Error('LocalStorageStore - no storageKey specified.');\n        }\n        this._storageKey = opts.storageKey;\n    }\n    //\n    // private\n    //\n    // read from persistence\n    _getState() {\n        const serialized = global.localStorage.getItem(this._storageKey);\n        return serialized ? JSON.parse(serialized) : undefined;\n    }\n    // write to persistence\n    _putState(newState) {\n        const serialized = JSON.stringify(newState);\n        return global.localStorage.setItem(this._storageKey, serialized);\n    }\n}\nexports.LocalStorageStore = LocalStorageStore;\n//# sourceMappingURL=LocalStorageStore.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservableStore = void 0;\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nclass ObservableStore extends safe_event_emitter_1.default {\n    constructor(initState = {}) {\n        super();\n        // set init state\n        this._state = initState;\n    }\n    // wrapper around internal getState\n    getState() {\n        return this._getState();\n    }\n    // wrapper around internal putState\n    putState(newState) {\n        this._putState(newState);\n        this.emit('update', newState);\n    }\n    updateState(partialState) {\n        // if non-null object, merge\n        if (partialState && typeof partialState === 'object') {\n            const state = this.getState();\n            const newState = Object.assign({}, state, partialState);\n            this.putState(newState);\n            // if not object, use new value\n        }\n        else {\n            this.putState(partialState);\n        }\n    }\n    // subscribe to changes\n    subscribe(handler) {\n        this.on('update', handler);\n    }\n    // unsubscribe to changes\n    unsubscribe(handler) {\n        this.removeListener('update', handler);\n    }\n    //\n    // private\n    //\n    // read from persistence\n    _getState() {\n        return this._state;\n    }\n    // write to persistence\n    _putState(newState) {\n        this._state = newState;\n    }\n}\nexports.ObservableStore = ObservableStore;\n//# sourceMappingURL=ObservableStore.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.storeTransformStream = void 0;\nconst through2_1 = require(\"through2\");\nfunction storeTransformStream(syncTransformFn) {\n    return through2_1.obj((state, _encoding, cb) => {\n        try {\n            const newState = syncTransformFn(state);\n            cb(null, newState);\n            return undefined;\n        }\n        catch (err) {\n            cb(err);\n            return undefined;\n        }\n    });\n}\nexports.storeTransformStream = storeTransformStream;\n//# sourceMappingURL=transform.js.map","import { cloneDeep } from 'lodash';\n\nconst version = 3;\nconst oldTestRpc = 'https://rawtestrpc.metamask.io/';\nconst newTestRpc = 'https://testrpc.metamask.io/';\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      if (versionedData.data.config.provider.rpcTarget === oldTestRpc) {\n        versionedData.data.config.provider.rpcTarget = newTestRpc;\n      }\n    } catch (_) {\n      // empty\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n","import { cloneDeep } from 'lodash';\n\nconst version = 2;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      if (versionedData.data.config.provider.type === 'etherscan') {\n        versionedData.data.config.provider.type = 'rpc';\n        versionedData.data.config.provider.rpcTarget =\n          'https://rpc.metamask.io/';\n      }\n    } catch (_) {\n      // empty\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n","/*\n\nThis migration breaks out the ShapeShiftController substate\n\n*/\n\nimport { cloneDeep, merge } from 'lodash';\n\nconst version = 10;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = merge({}, state, {\n    ShapeShiftController: {\n      shapeShiftTxList: state.shapeShiftTxList || [],\n    },\n  });\n  delete newState.shapeShiftTxList;\n\n  return newState;\n}\n","/*\n\nThis migration breaks out the CurrencyController substate\n\n*/\n\nimport { cloneDeep, merge } from 'lodash';\n\nconst version = 9;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = merge({}, state, {\n    CurrencyController: {\n      currentCurrency: state.currentFiat || state.fiatCurrency || 'USD',\n      conversionRate: state.conversionRate,\n      conversionDate: state.conversionDate,\n    },\n  });\n  delete newState.currentFiat;\n  delete newState.fiatCurrency;\n  delete newState.conversionRate;\n  delete newState.conversionDate;\n\n  return newState;\n}\n","/*\n\nThis migration sets transactions who were retried and marked as failed to submitted\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 17;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = newState.TransactionController;\n    newState.TransactionController.transactions = transactions.map((txMeta) => {\n      if (!txMeta.status === TRANSACTION_STATUSES.FAILED) {\n        return txMeta;\n      }\n      if (txMeta.retryCount > 0 && txMeta.retryCount < 2) {\n        txMeta.status = TRANSACTION_STATUSES.SUBMITTED;\n        delete txMeta.err;\n      }\n      return txMeta;\n    });\n  }\n  return newState;\n}\n","/*\n\nThis migration sets transactions with the 'Gave up submitting tx.' err message\nto a 'failed' stated\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 15;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = TransactionController;\n    newState.TransactionController.transactions = transactions.map((txMeta) => {\n      if (!txMeta.err) {\n        return txMeta;\n      } else if (txMeta.err.message === 'Gave up submitting tx.') {\n        txMeta.status = TRANSACTION_STATUSES.FAILED;\n      }\n      return txMeta;\n    });\n  }\n  return newState;\n}\n","/*\n\nThis migration moves the identities stored in the KeyringController\n into the PreferencesController\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 26;\n\nexport default {\n  version,\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      versionedData.data = transformState(state);\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n      return Promise.reject(err);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  if (!state.KeyringController || !state.PreferencesController) {\n    return state;\n  }\n\n  if (!state.KeyringController.walletNicknames) {\n    return state;\n  }\n\n  state.PreferencesController.identities = Object.keys(\n    state.KeyringController.walletNicknames,\n  ).reduce((identities, address) => {\n    identities[address] = {\n      name: state.KeyringController.walletNicknames[address],\n      address,\n    };\n    return identities;\n  }, {});\n  delete state.KeyringController.walletNicknames;\n  return state;\n}\n","/*\n\nThis migration modifies the network config from ambiguous 'testnet' to explicit 'ropsten'\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 13;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  const { config } = newState;\n  if (config && config.provider) {\n    if (config.provider.type === 'testnet') {\n      newState.config.provider.type = 'ropsten';\n    }\n  }\n  return newState;\n}\n","/*\n\nThis migration removes provider from config and moves it too NetworkController.\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 14;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  newState.NetworkController = {};\n  newState.NetworkController.provider = newState.config.provider;\n  delete newState.config.provider;\n  return newState;\n}\n","// next version number\n/*\n\nnormalizes txParams on unconfirmed txs\n\n*/\nimport { cloneDeep } from 'lodash';\n\nconst version = 28;\n\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n\n  if (newState.PreferencesController) {\n    if (\n      newState.PreferencesController.tokens &&\n      newState.PreferencesController.identities\n    ) {\n      const { identities, tokens } = newState.PreferencesController;\n      newState.PreferencesController.accountTokens = {};\n      Object.keys(identities).forEach((identity) => {\n        newState.PreferencesController.accountTokens[identity] = {\n          mainnet: tokens,\n        };\n      });\n      newState.PreferencesController.tokens = [];\n    }\n  }\n\n  return newState;\n}\n","// next version number\n/*\n\nnormalizes txParams on unconfirmed txs\n\n*/\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 27;\n\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n\n  if (newState.TransactionController) {\n    if (newState.TransactionController.transactions) {\n      const { transactions } = newState.TransactionController;\n      newState.TransactionController.transactions = transactions.filter(\n        (txMeta) => txMeta.status !== TRANSACTION_STATUSES.REJECTED,\n      );\n    }\n  }\n\n  return newState;\n}\n","/*\n\nThis migration ensures that the from address in txParams is to lower case for\nall unapproved transactions\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 24;\n\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  if (!newState.TransactionController) {\n    return newState;\n  }\n  const { transactions } = newState.TransactionController;\n  newState.TransactionController.transactions = transactions.map(\n    (txMeta, _) => {\n      if (\n        txMeta.status === TRANSACTION_STATUSES.UNAPPROVED &&\n        txMeta.txParams &&\n        txMeta.txParams.from\n      ) {\n        txMeta.txParams.from = txMeta.txParams.from.toLowerCase();\n      }\n      return txMeta;\n    },\n  );\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 36;\n\n/**\n * The purpose of this migration is to remove the {@code privacyMode} feature flag.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const { PreferencesController } = state;\n\n  if (PreferencesController) {\n    const featureFlags = PreferencesController.featureFlags || {};\n\n    if (typeof featureFlags.privacyMode !== 'undefined') {\n      delete featureFlags.privacyMode;\n    }\n  }\n\n  return state;\n}\n","import { cloneDeep } from 'lodash';\nimport { toChecksumHexAddress } from '../../../shared/modules/hexstring-utils';\n\nconst version = 39;\n\nconst DAI_V1_CONTRACT_ADDRESS = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359';\nconst DAI_V1_TOKEN_SYMBOL = 'DAI';\nconst SAI_TOKEN_SYMBOL = 'SAI';\n\nfunction isOldDai(token = {}) {\n  return (\n    token &&\n    typeof token === 'object' &&\n    token.symbol === DAI_V1_TOKEN_SYMBOL &&\n    toChecksumHexAddress(token.address) === DAI_V1_CONTRACT_ADDRESS\n  );\n}\n\n/**\n * This migration renames the Dai token to Sai.\n *\n * As of 2019-11-18 Dai is now called Sai (refs https://git.io/JeooP) to facilitate\n * Maker's upgrade to Multi-Collateral Dai and this migration renames the token\n * at the old address.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const { PreferencesController } = state;\n\n  if (PreferencesController) {\n    const tokens = PreferencesController.tokens || [];\n    if (Array.isArray(tokens)) {\n      for (const token of tokens) {\n        if (isOldDai(token)) {\n          token.symbol = SAI_TOKEN_SYMBOL;\n        }\n      }\n    }\n\n    const accountTokens = PreferencesController.accountTokens || {};\n    if (accountTokens && typeof accountTokens === 'object') {\n      for (const address of Object.keys(accountTokens)) {\n        const networkTokens = accountTokens[address];\n        if (networkTokens && typeof networkTokens === 'object') {\n          for (const network of Object.keys(networkTokens)) {\n            const tokensOnNetwork = networkTokens[network];\n            if (Array.isArray(tokensOnNetwork)) {\n              for (const token of tokensOnNetwork) {\n                if (isOldDai(token)) {\n                  token.symbol = SAI_TOKEN_SYMBOL;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return state;\n}\n","import { cloneDeep } from 'lodash';\nimport {\n  GOERLI,\n  GOERLI_CHAIN_ID,\n  KOVAN,\n  KOVAN_CHAIN_ID,\n  MAINNET,\n  MAINNET_CHAIN_ID,\n  NETWORK_TYPE_RPC,\n  RINKEBY,\n  RINKEBY_CHAIN_ID,\n  ROPSTEN,\n  ROPSTEN_CHAIN_ID,\n} from '../../../shared/constants/network';\n\nconst version = 52;\n\n/**\n * Migrate tokens in Preferences to be keyed by chainId instead of\n * providerType. To prevent breaking user's MetaMask and selected\n * tokens, this migration copies the RPC entry into *every* custom RPC\n * chainId.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state = {}) {\n  if (state.PreferencesController) {\n    const {\n      accountTokens,\n      accountHiddenTokens,\n      frequentRpcListDetail,\n    } = state.PreferencesController;\n\n    const newAccountTokens = {};\n    const newAccountHiddenTokens = {};\n\n    if (accountTokens && Object.keys(accountTokens).length > 0) {\n      for (const address of Object.keys(accountTokens)) {\n        newAccountTokens[address] = {};\n        if (accountTokens[address][NETWORK_TYPE_RPC]) {\n          frequentRpcListDetail.forEach((detail) => {\n            newAccountTokens[address][detail.chainId] =\n              accountTokens[address][NETWORK_TYPE_RPC];\n          });\n        }\n        for (const providerType of Object.keys(accountTokens[address])) {\n          switch (providerType) {\n            case MAINNET:\n              newAccountTokens[address][MAINNET_CHAIN_ID] =\n                accountTokens[address][MAINNET];\n              break;\n            case ROPSTEN:\n              newAccountTokens[address][ROPSTEN_CHAIN_ID] =\n                accountTokens[address][ROPSTEN];\n              break;\n            case RINKEBY:\n              newAccountTokens[address][RINKEBY_CHAIN_ID] =\n                accountTokens[address][RINKEBY];\n              break;\n            case GOERLI:\n              newAccountTokens[address][GOERLI_CHAIN_ID] =\n                accountTokens[address][GOERLI];\n              break;\n            case KOVAN:\n              newAccountTokens[address][KOVAN_CHAIN_ID] =\n                accountTokens[address][KOVAN];\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      state.PreferencesController.accountTokens = newAccountTokens;\n    }\n\n    if (accountHiddenTokens && Object.keys(accountHiddenTokens).length > 0) {\n      for (const address of Object.keys(accountHiddenTokens)) {\n        newAccountHiddenTokens[address] = {};\n        if (accountHiddenTokens[address][NETWORK_TYPE_RPC]) {\n          frequentRpcListDetail.forEach((detail) => {\n            newAccountHiddenTokens[address][detail.chainId] =\n              accountHiddenTokens[address][NETWORK_TYPE_RPC];\n          });\n        }\n        for (const providerType of Object.keys(accountHiddenTokens[address])) {\n          switch (providerType) {\n            case MAINNET:\n              newAccountHiddenTokens[address][MAINNET_CHAIN_ID] =\n                accountHiddenTokens[address][MAINNET];\n              break;\n            case ROPSTEN:\n              newAccountHiddenTokens[address][ROPSTEN_CHAIN_ID] =\n                accountHiddenTokens[address][ROPSTEN];\n              break;\n            case RINKEBY:\n              newAccountHiddenTokens[address][RINKEBY_CHAIN_ID] =\n                accountHiddenTokens[address][RINKEBY];\n              break;\n            case GOERLI:\n              newAccountHiddenTokens[address][GOERLI_CHAIN_ID] =\n                accountHiddenTokens[address][GOERLI];\n              break;\n            case KOVAN:\n              newAccountHiddenTokens[address][KOVAN_CHAIN_ID] =\n                accountHiddenTokens[address][KOVAN];\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      state.PreferencesController.accountHiddenTokens = newAccountHiddenTokens;\n    }\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 32;\n\n/**\n * The purpose of this migration is to set the {@code completedUiMigration} flag based on the user's UI preferences\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const { PreferencesController } = state;\n\n  if (PreferencesController) {\n    const { betaUI } = PreferencesController.featureFlags || {};\n    // Users who have been using the \"beta\" UI are considered to have completed the migration\n    // as they'll see no difference in this version\n    PreferencesController.completedUiMigration = betaUI;\n  }\n\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 44;\n\n/**\n * Remove unused 'mkrMigrationReminderTimestamp' state from the `AppStateController`\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (\n    typeof state?.AppStateController?.mkrMigrationReminderTimestamp !==\n    'undefined'\n  ) {\n    delete state.AppStateController.mkrMigrationReminderTimestamp;\n  }\n  return state;\n}\n","/*\n\nThis migration sets transactions with the 'Gave up submitting tx.' err message\nto a 'failed' stated\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 16;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = newState.TransactionController;\n\n    newState.TransactionController.transactions = transactions.map((txMeta) => {\n      if (!txMeta.err) {\n        return txMeta;\n      }\n      if (\n        txMeta.err === 'transaction with the same hash was already imported.'\n      ) {\n        txMeta.status = TRANSACTION_STATUSES.SUBMITTED;\n        delete txMeta.err;\n      }\n      return txMeta;\n    });\n  }\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 41;\n\n/**\n * PreferencesController.autoLogoutTimeLimit -> autoLockTimeLimit\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (state.PreferencesController && state.PreferencesController.preferences) {\n    state.PreferencesController.preferences.autoLockTimeLimit =\n      state.PreferencesController.preferences.autoLogoutTimeLimit;\n    delete state.PreferencesController.preferences.autoLogoutTimeLimit;\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 45;\n\n/**\n * Replaces {@code PreferencesController.ipfsGateway} with 'dweb.link' if set\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nconst outdatedGateways = ['ipfs.io', 'ipfs.dweb.link'];\n\nfunction transformState(state) {\n  if (outdatedGateways.includes(state?.PreferencesController?.ipfsGateway)) {\n    state.PreferencesController.ipfsGateway = 'dweb.link';\n  }\n  return state;\n}\n","/*\n\nThis migration adds submittedTime to the txMeta if it is not their\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 22;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = newState.TransactionController;\n\n    newState.TransactionController.transactions = transactions.map((txMeta) => {\n      if (\n        txMeta.status !== TRANSACTION_STATUSES.SUBMITTED ||\n        txMeta.submittedTime\n      ) {\n        return txMeta;\n      }\n      txMeta.submittedTime = new Date().getTime();\n      return txMeta;\n    });\n  }\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 42;\n\n/**\n * Initialize `connectedStatusPopoverHasBeenShown` to `false` if it hasn't yet been set,\n * so that existing users are introduced to the new connected status indicator\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (state.AppStateController) {\n    state.AppStateController.connectedStatusPopoverHasBeenShown = false;\n  } else {\n    state.AppStateController = {\n      connectedStatusPopoverHasBeenShown: false,\n    };\n  }\n  return state;\n}\n","// next version number\n/*\n\nCleans up notices and assocated notice controller code\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 33;\n\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  // transform state here\n  if (state.NoticeController) {\n    delete newState.NoticeController;\n  }\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 34;\n\n/**\n * The purpose of this migration is to enable the {@code privacyMode} feature flag and set the user as being migrated\n * if it was {@code false}.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const { PreferencesController } = state;\n\n  if (PreferencesController) {\n    const featureFlags = PreferencesController.featureFlags || {};\n\n    if (\n      !featureFlags.privacyMode &&\n      typeof PreferencesController.migratedPrivacyMode === 'undefined'\n    ) {\n      // Mark the state has being migrated and enable Privacy Mode\n      PreferencesController.migratedPrivacyMode = true;\n      featureFlags.privacyMode = true;\n    }\n  }\n\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 47;\n\n/**\n * Stringify the `metamaskNetworkId` property of all transactions\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const transactions = state?.TransactionController?.transactions;\n  if (Array.isArray(transactions)) {\n    transactions.forEach((transaction) => {\n      if (typeof transaction.metamaskNetworkId === 'number') {\n        transaction.metamaskNetworkId = transaction.metamaskNetworkId.toString();\n      }\n    });\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 58;\n\n/**\n * Deletes the swapsWelcomeMessageHasBeenShown property from state\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  delete state.AppStateController?.swapsWelcomeMessageHasBeenShown;\n\n  return state;\n}\n","// next version number\nimport { cloneDeep } from 'lodash';\n\nconst version = 31;\n\n/*\n * The purpose of this migration is to properly set the completedOnboarding flag based on the state\n * of the KeyringController.\n */\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const { KeyringController, PreferencesController } = state;\n\n  if (KeyringController && PreferencesController) {\n    const { vault } = KeyringController;\n    PreferencesController.completedOnboarding = Boolean(vault);\n  }\n\n  return state;\n}\n","import {\n  cloneDeep,\n  concat,\n  groupBy,\n  keyBy,\n  pickBy,\n  isPlainObject,\n} from 'lodash';\nimport { TRANSACTION_TYPES } from '../../../shared/constants/transaction';\n\nconst version = 59;\n\n/**\n * Removes orphaned cancel and retry transactions that no longer have the\n * original transaction in state, which results in bugs.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const transactions = state?.TransactionController?.transactions;\n  if (isPlainObject(transactions)) {\n    const nonceNetworkGroupedObject = groupBy(\n      Object.values(transactions),\n      (tx) => {\n        return `${tx.txParams?.nonce}-${tx.chainId ?? tx.metamaskNetworkId}`;\n      },\n    );\n\n    const withoutOrphans = pickBy(nonceNetworkGroupedObject, (group) => {\n      return group.some(\n        (tx) =>\n          tx.type !== TRANSACTION_TYPES.CANCEL &&\n          tx.type !== TRANSACTION_TYPES.RETRY,\n      );\n    });\n    state.TransactionController.transactions = keyBy(\n      concat(...Object.values(withoutOrphans)),\n      (tx) => tx.id,\n    );\n  }\n\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 56;\n\n/**\n * Remove tokens that don't have an address due to\n * lack of previous addToken validation.  Also removes\n * an unwanted, undefined image property\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n\n    const { PreferencesController } = versionedData.data;\n\n    if (Array.isArray(PreferencesController?.tokens)) {\n      PreferencesController.tokens = PreferencesController.tokens.filter(\n        ({ address }) => address,\n      );\n    }\n\n    if (\n      PreferencesController?.accountTokens &&\n      typeof PreferencesController.accountTokens === 'object'\n    ) {\n      Object.keys(PreferencesController.accountTokens).forEach((account) => {\n        const chains = Object.keys(\n          PreferencesController.accountTokens[account],\n        );\n        chains.forEach((chain) => {\n          PreferencesController.accountTokens[account][\n            chain\n          ] = PreferencesController.accountTokens[account][chain].filter(\n            ({ address }) => address,\n          );\n        });\n      });\n    }\n\n    if (\n      PreferencesController?.assetImages &&\n      'undefined' in PreferencesController.assetImages\n    ) {\n      delete PreferencesController.assetImages.undefined;\n    }\n\n    return versionedData;\n  },\n};\n","import { cloneDeep } from 'lodash';\n\nconst version = 50;\n\nconst LEGACY_LOCAL_STORAGE_KEYS = [\n  'METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED',\n  'METASWAP_GAS_PRICE_ESTIMATES',\n  'cachedFetch',\n  'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED',\n  'BASIC_PRICE_ESTIMATES',\n  'BASIC_GAS_AND_TIME_API_ESTIMATES',\n  'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED',\n  'GAS_API_ESTIMATES_LAST_RETRIEVED',\n  'GAS_API_ESTIMATES',\n];\n\n/**\n * Migrate metaMetrics state to the new MetaMetrics controller\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n\n    LEGACY_LOCAL_STORAGE_KEYS.forEach((key) =>\n      window.localStorage?.removeItem(key),\n    );\n\n    return versionedData;\n  },\n};\n","import { cloneDeep } from 'lodash';\n\nconst version = 46;\n\n/**\n * Delete {@code ABTestController} state\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (typeof state?.ABTestController !== 'undefined') {\n    delete state.ABTestController;\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 40;\n\n/**\n * Site connections are now managed by the PermissionsController, and the\n * ProviderApprovalController is removed. This migration deletes all\n * ProviderApprovalController state.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  delete state.ProviderApprovalController;\n  return state;\n}\n","import { cloneDeep } from 'lodash';\nimport { NETWORK_TYPE_TO_ID_MAP } from '../../../shared/constants/network';\n\nconst version = 51;\n\n/**\n * Set the chainId in the Network Controller provider data for all infura networks\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const { chainId, type } = state?.NetworkController?.provider || {};\n  const enumChainId = NETWORK_TYPE_TO_ID_MAP[type]?.chainId;\n\n  if (enumChainId && chainId !== enumChainId) {\n    state.NetworkController.provider.chainId = enumChainId;\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 61;\n\n/**\n * Initialize attributes related to recovery seed phrase reminder\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const currentTime = new Date().getTime();\n  if (state.AppStateController) {\n    state.AppStateController.recoveryPhraseReminderHasBeenShown = false;\n    state.AppStateController.recoveryPhraseReminderLastShown = currentTime;\n  } else {\n    state.AppStateController = {\n      recoveryPhraseReminderHasBeenShown: false,\n      recoveryPhraseReminderLastShown: currentTime,\n    };\n  }\n  return state;\n}\n","// next version number\n/*\n\nremoves invalid chaids from preferences and networkController for custom rpcs\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 30;\n\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  if (state.PreferencesController) {\n    const { frequentRpcListDetail } = newState.PreferencesController;\n    if (frequentRpcListDetail) {\n      frequentRpcListDetail.forEach((rpc, index) => {\n        // eslint-disable-next-line radix\n        if (Boolean(rpc.chainId) && Number.isNaN(parseInt(rpc.chainId))) {\n          delete frequentRpcListDetail[index].chainId;\n        }\n      });\n      newState.PreferencesController.frequentRpcListDetail = frequentRpcListDetail;\n    }\n  }\n  if (state.NetworkController) {\n    if (\n      newState.NetworkController.network &&\n      // eslint-disable-next-line radix\n      Number.isNaN(parseInt(newState.NetworkController.network))\n    ) {\n      delete newState.NetworkController.network;\n    }\n\n    if (\n      newState.NetworkController.provider &&\n      newState.NetworkController.provider.chainId &&\n      // eslint-disable-next-line radix\n      Number.isNaN(parseInt(newState.NetworkController.provider.chainId))\n    ) {\n      delete newState.NetworkController.provider.chainId;\n    }\n  }\n\n  return newState;\n}\n","/*\n\nThis migration removes transactions that are no longer usefull down to 40 total\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 23;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = newState.TransactionController;\n\n    if (transactions.length <= 40) {\n      return newState;\n    }\n\n    const reverseTxList = transactions.reverse();\n    let stripping = true;\n    while (reverseTxList.length > 40 && stripping) {\n      const txIndex = reverseTxList.findIndex((txMeta) => {\n        return (\n          txMeta.status === TRANSACTION_STATUSES.FAILED ||\n          txMeta.status === TRANSACTION_STATUSES.REJECTED ||\n          txMeta.status === TRANSACTION_STATUSES.CONFIRMED ||\n          txMeta.status === TRANSACTION_STATUSES.DROPPED\n        );\n      });\n      if (txIndex < 0) {\n        stripping = false;\n      } else {\n        reverseTxList.splice(txIndex, 1);\n      }\n    }\n\n    newState.TransactionController.transactions = reverseTxList.reverse();\n  }\n  return newState;\n}\n","// next version number\n/*\n\nnormalizes txParams on unconfirmed txs\n\n*/\nimport { cloneDeep } from 'lodash';\nimport { addHexPrefix } from '../lib/util';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 25;\n\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n\n  if (newState.TransactionController) {\n    if (newState.TransactionController.transactions) {\n      const { transactions } = newState.TransactionController;\n      newState.TransactionController.transactions = transactions.map(\n        (txMeta) => {\n          if (txMeta.status !== TRANSACTION_STATUSES.UNAPPROVED) {\n            return txMeta;\n          }\n          txMeta.txParams = normalizeTxParams(txMeta.txParams);\n          return txMeta;\n        },\n      );\n    }\n  }\n\n  return newState;\n}\n\nfunction normalizeTxParams(txParams) {\n  // functions that handle normalizing of that key in txParams\n  const whiteList = {\n    from: (from) => addHexPrefix(from).toLowerCase(),\n    to: () => addHexPrefix(txParams.to).toLowerCase(),\n    nonce: (nonce) => addHexPrefix(nonce),\n    value: (value) => addHexPrefix(value),\n    data: (data) => addHexPrefix(data),\n    gas: (gas) => addHexPrefix(gas),\n    gasPrice: (gasPrice) => addHexPrefix(gasPrice),\n  };\n\n  // apply only keys in the whiteList\n  const normalizedTxParams = {};\n  Object.keys(whiteList).forEach((key) => {\n    if (txParams[key]) {\n      normalizedTxParams[key] = whiteList[key](txParams[key]);\n    }\n  });\n\n  return normalizedTxParams;\n}\n","/*\n\nThis migration sets transactions as failed\nwhos nonce is too high\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nconst version = 19;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = newState.TransactionController;\n\n    newState.TransactionController.transactions = transactions.map(\n      (txMeta, _, txList) => {\n        if (txMeta.status !== TRANSACTION_STATUSES.SUBMITTED) {\n          return txMeta;\n        }\n\n        const confirmedTxs = txList\n          .filter((tx) => tx.status === TRANSACTION_STATUSES.CONFIRMED)\n          .filter((tx) => tx.txParams.from === txMeta.txParams.from)\n          .filter(\n            (tx) => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from,\n          );\n        const highestConfirmedNonce = getHighestNonce(confirmedTxs);\n\n        const pendingTxs = txList\n          .filter((tx) => tx.status === TRANSACTION_STATUSES.SUBMITTED)\n          .filter((tx) => tx.txParams.from === txMeta.txParams.from)\n          .filter(\n            (tx) => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from,\n          );\n        const highestContinuousNonce = getHighestContinuousFrom(\n          pendingTxs,\n          highestConfirmedNonce,\n        );\n\n        const maxNonce = Math.max(\n          highestContinuousNonce,\n          highestConfirmedNonce,\n        );\n\n        if (parseInt(txMeta.txParams.nonce, 16) > maxNonce + 1) {\n          txMeta.status = TRANSACTION_STATUSES.FAILED;\n          txMeta.err = {\n            message: 'nonce too high',\n            note: 'migration 019 custom error',\n          };\n        }\n        return txMeta;\n      },\n    );\n  }\n  return newState;\n}\n\nfunction getHighestContinuousFrom(txList, startPoint) {\n  const nonces = txList.map((txMeta) => {\n    const { nonce } = txMeta.txParams;\n    return parseInt(nonce, 16);\n  });\n\n  let highest = startPoint;\n  while (nonces.includes(highest)) {\n    highest += 1;\n  }\n\n  return highest;\n}\n\nfunction getHighestNonce(txList) {\n  const nonces = txList.map((txMeta) => {\n    const { nonce } = txMeta.txParams;\n    return parseInt(nonce || '0x0', 16);\n  });\n  const highestNonce = Math.max.apply(null, nonces);\n  return highestNonce;\n}\n","import { cloneDeep, mapKeys } from 'lodash';\nimport { NETWORK_TYPE_TO_ID_MAP } from '../../../shared/constants/network';\n\nconst version = 55;\n\n/**\n * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nconst UNKNOWN_CHAIN_ID_KEY = 'UNKNOWN';\n\nfunction transformState(state) {\n  if (\n    state?.IncomingTransactionsController?.incomingTxLastFetchedBlocksByNetwork\n  ) {\n    state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId = mapKeys(\n      state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork,\n      // using optional chaining in case user's state has fetched blocks for\n      // RPC network types (which don't map to a single chainId). This should\n      // not be possible, but it's safer\n      (_, key) => NETWORK_TYPE_TO_ID_MAP[key]?.chainId ?? UNKNOWN_CHAIN_ID_KEY,\n    );\n    // Now that mainnet and test net last fetched blocks are keyed by their\n    // respective chainIds, we can safely delete anything we had for custom\n    // networks. Any custom network that shares a chainId with one of the\n    // aforementioned networks will use the value stored by chainId.\n    delete state.IncomingTransactionsController\n      .incomingTxLastFetchedBlockByChainId[UNKNOWN_CHAIN_ID_KEY];\n    delete state.IncomingTransactionsController\n      .incomingTxLastFetchedBlocksByNetwork;\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 62;\n\n/**\n * Removes metaMetricsSendCount from MetaMetrics controller\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (state.MetaMetricsController) {\n    const { metaMetricsSendCount } = state.MetaMetricsController;\n    if (metaMetricsSendCount !== undefined) {\n      delete state.MetaMetricsController.metaMetricsSendCount;\n    }\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 54;\n\nfunction isValidDecimals(decimals) {\n  return (\n    typeof decimals === 'number' ||\n    (typeof decimals === 'string' && decimals.match(/^(0x)?\\d+$/u))\n  );\n}\n\n/**\n * Migrates preference tokens with decimals typed as string to number.\n * It also removes any tokens with corrupted or inconvertible decimal values.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n\n  if (!newState.PreferencesController) {\n    return newState;\n  }\n\n  const tokens = newState.PreferencesController.tokens || [];\n  // Filter out any tokens with corrupted decimal values\n  const validTokens = tokens.filter(({ decimals }) =>\n    isValidDecimals(decimals),\n  );\n  for (const token of validTokens) {\n    // In the case of a decimal value type string, convert to a number.\n    if (typeof token.decimals === 'string') {\n      // eslint-disable-next-line radix\n      token.decimals = parseInt(token.decimals);\n    }\n  }\n  newState.PreferencesController.tokens = validTokens;\n\n  const { accountTokens } = newState.PreferencesController;\n  if (accountTokens && typeof accountTokens === 'object') {\n    for (const address of Object.keys(accountTokens)) {\n      const networkTokens = accountTokens[address];\n      if (networkTokens && typeof networkTokens === 'object') {\n        for (const network of Object.keys(networkTokens)) {\n          const tokensOnNetwork = networkTokens[network] || [];\n          // Filter out any tokens with corrupted decimal values\n          const validTokensOnNetwork = tokensOnNetwork.filter(({ decimals }) =>\n            isValidDecimals(decimals),\n          );\n          // In the case of a decimal value type string, convert to a number.\n          for (const token of validTokensOnNetwork) {\n            if (typeof token.decimals === 'string') {\n              // eslint-disable-next-line radix\n              token.decimals = parseInt(token.decimals);\n            }\n          }\n          networkTokens[network] = validTokensOnNetwork;\n        }\n      }\n    }\n  }\n  newState.PreferencesController.accountTokens = accountTokens;\n\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 49;\n\n/**\n * Migrate metaMetrics state to the new MetaMetrics controller\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state = {}) {\n  if (state.PreferencesController) {\n    const {\n      metaMetricsId,\n      participateInMetaMetrics,\n      metaMetricsSendCount,\n    } = state.PreferencesController;\n    state.MetaMetricsController = state.MetaMetricsController ?? {};\n\n    if (metaMetricsId !== undefined) {\n      state.MetaMetricsController.metaMetricsId = metaMetricsId;\n      delete state.PreferencesController.metaMetricsId;\n    }\n\n    if (participateInMetaMetrics !== undefined) {\n      state.MetaMetricsController.participateInMetaMetrics = participateInMetaMetrics;\n      delete state.PreferencesController.participateInMetaMetrics;\n    }\n\n    if (metaMetricsSendCount !== undefined) {\n      state.MetaMetricsController.metaMetricsSendCount = metaMetricsSendCount;\n      delete state.PreferencesController.metaMetricsSendCount;\n    }\n  }\n  return state;\n}\n","import { cloneDeep, isPlainObject } from 'lodash';\n\nconst version = 60;\nconst SUPPORT_NOTIFICATION_KEY = 2;\nconst SUPPORT_NOTIFICATION_DATE = '2020-08-31';\n\n/**\n * Removes the support survey notification\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const notifications = state?.NotificationController?.notifications;\n  if (isPlainObject(notifications)) {\n    if (\n      notifications[SUPPORT_NOTIFICATION_KEY]?.date ===\n      SUPPORT_NOTIFICATION_DATE\n    ) {\n      delete state.NotificationController.notifications[\n        SUPPORT_NOTIFICATION_KEY\n      ];\n    }\n  }\n  return state;\n}\n","import { cloneDeep, isPlainObject } from 'lodash';\nimport { TRANSACTION_TYPES } from '../../../shared/constants/transaction';\n\nconst version = 64;\n\nconst SENT_ETHER = 'sentEther'; // the legacy transaction type being replaced in this migration with TRANSACTION_TYPES.SIMPLE_SEND\n\n/**\n * Removes metaMetricsSendCount from MetaMetrics controller\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const transactions = state?.TransactionController?.transactions;\n  if (isPlainObject(transactions)) {\n    for (const tx of Object.values(transactions)) {\n      if (tx.type === SENT_ETHER) {\n        tx.type = TRANSACTION_TYPES.SIMPLE_SEND;\n      }\n      if (tx.history) {\n        tx.history.map((txEvent) => {\n          if (txEvent.type && txEvent.type === SENT_ETHER) {\n            txEvent.type = TRANSACTION_TYPES.SIMPLE_SEND;\n          }\n          return txEvent;\n        });\n      }\n    }\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 43;\n\n/**\n * Remove unused 'currentAccountTab' state\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (state?.PreferencesController?.currentAccountTab) {\n    delete state.PreferencesController.currentAccountTab;\n  }\n  return state;\n}\n","/*\n\nThis migration removes the discaimer state from our app, which was integrated into our notices.\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 11;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  delete newState.TOSHash;\n  delete newState.isDisclaimerConfirmed;\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 4;\n\nexport default {\n  version,\n\n  migrate(versionedData) {\n    const safeVersionedData = cloneDeep(versionedData);\n    safeVersionedData.meta.version = version;\n    try {\n      if (safeVersionedData.data.config.provider.type !== 'rpc') {\n        return Promise.resolve(safeVersionedData);\n      }\n      switch (safeVersionedData.data.config.provider.rpcTarget) {\n        case 'https://testrpc.metamask.io/':\n          safeVersionedData.data.config.provider = {\n            type: 'testnet',\n          };\n          break;\n        case 'https://rpc.metamask.io/':\n          safeVersionedData.data.config.provider = {\n            type: 'mainnet',\n          };\n          break;\n        // No default\n      }\n    } catch (_) {\n      // empty\n    }\n    return Promise.resolve(safeVersionedData);\n  },\n};\n","// next version number\n/*\n\nRemoves the deprecated 'seedWords' state\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 35;\n\nexport default {\n  version,\n\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    versionedData.data = transformState(versionedData.data);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (\n    state.PreferencesController &&\n    state.PreferencesController.seedWords !== undefined\n  ) {\n    delete state.PreferencesController.seedWords;\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\nimport { SUBJECT_TYPES } from '../../../shared/constants/app';\n\nconst version = 69;\n\n/**\n * Adds the `subjectType` property to all subject metadata.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (typeof state?.SubjectMetadataController?.subjectMetadata === 'object') {\n    const {\n      SubjectMetadataController: { subjectMetadata },\n    } = state;\n\n    // mutate SubjectMetadataController.subjectMetadata in place\n    Object.values(subjectMetadata).forEach((metadata) => {\n      if (\n        metadata &&\n        typeof metadata === 'object' &&\n        !Array.isArray(metadata)\n      ) {\n        metadata.subjectType = metadata.extensionId\n          ? SUBJECT_TYPES.EXTENSION\n          : SUBJECT_TYPES.WEBSITE;\n      }\n    });\n  }\n  return state;\n}\n","/*\n\nThis migration removes the BlackListController from disk state\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 21;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  delete newState.BlacklistController;\n  delete newState.RecentBlocks;\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 65;\n\n/**\n * Removes metaMetricsSendCount from MetaMetrics controller\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (state.PreferencesController) {\n    const {\n      completedOnboarding,\n      firstTimeFlowType,\n    } = state.PreferencesController;\n    state.OnboardingController = state.OnboardingController ?? {};\n\n    if (completedOnboarding !== undefined) {\n      state.OnboardingController.completedOnboarding = completedOnboarding;\n      delete state.PreferencesController.completedOnboarding;\n    }\n    if (firstTimeFlowType !== undefined) {\n      state.OnboardingController.firstTimeFlowType = firstTimeFlowType;\n      delete state.PreferencesController.firstTimeFlowType;\n    }\n  }\n\n  return state;\n}\n","/*\n\nThis migration modifies our notices to delete their body after being read.\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 12;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  newState.NoticeController.noticesList.forEach((notice) => {\n    if (notice.read) {\n      notice.body = '';\n    }\n  });\n  return newState;\n}\n","/*\n\nThis migration ensures previous installations\nget a `firstTimeInfo` key on the metamask state,\nso that we can version notices in the future.\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 20;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  if ('metamask' in newState && !('firstTimeInfo' in newState.metamask)) {\n    newState.metamask.firstTimeInfo = {\n      version: '3.12.0',\n      date: Date.now(),\n    };\n  }\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\nimport { util } from '@metamask/controllers';\n\nconst version = 37;\n\n/**\n * The purpose of this migration is to update the address book state\n * to the new schema with chainId as a key.\n * and to add the isEns flag to all entries\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (state.AddressBookController) {\n    const ab = state.AddressBookController.addressBook;\n\n    const chainIds = new Set();\n    const newAddressBook = {};\n\n    // add all of the chainIds to a set\n    Object.values(ab).forEach((v) => {\n      chainIds.add(v.chainId);\n    });\n\n    // fill the chainId object with the entries with the matching chainId\n    for (const id of chainIds.values()) {\n      // make an empty object entry for each chainId\n      newAddressBook[id] = {};\n      for (const address in ab) {\n        if (ab[address].chainId === id) {\n          ab[address].isEns = false;\n          if (util.normalizeEnsName(ab[address].name)) {\n            ab[address].isEns = true;\n          }\n          newAddressBook[id][address] = ab[address];\n        }\n      }\n    }\n\n    state.AddressBookController.addressBook = newAddressBook;\n  }\n\n  return state;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 38;\n\n/**\n * The purpose of this migration is to assign all users to a test group for the fullScreenVsPopup a/b test\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const { ABTestController: ABTestControllerState = {} } = state;\n  const { abTests = {} } = ABTestControllerState;\n\n  if (abTests.fullScreenVsPopup) {\n    return state;\n  }\n\n  return {\n    ...state,\n    ABTestController: {\n      ...ABTestControllerState,\n      abTests: {\n        ...abTests,\n        fullScreenVsPopup: 'control',\n      },\n    },\n  };\n}\n","// next version number\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\nimport failTxsThat from './fail-tx';\n\nconst version = 29;\n\n// time\nconst seconds = 1000;\nconst minutes = 60 * seconds;\nconst hours = 60 * minutes;\nconst unacceptableDelay = 12 * hours;\n\n/*\n\nnormalizes txParams on unconfirmed txs\n\n*/\n\nexport default {\n  version,\n\n  migrate: failTxsThat(\n    version,\n    'Stuck in approved state for too long.',\n    (txMeta) => {\n      const isApproved = txMeta.status === TRANSACTION_STATUSES.APPROVED;\n      const createdTime = txMeta.submittedTime;\n      const now = Date.now();\n      return isApproved && now - createdTime > unacceptableDelay;\n    },\n  ),\n};\n","import { cloneDeep, keyBy } from 'lodash';\nimport createId from '../../../shared/modules/random-id';\n\nconst version = 57;\n\n/**\n * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  if (\n    state?.TransactionController?.transactions &&\n    Array.isArray(state.TransactionController.transactions) &&\n    !state.TransactionController.transactions.some(\n      (item) =>\n        typeof item !== 'object' || typeof item.txParams === 'undefined',\n    )\n  ) {\n    state.TransactionController.transactions = keyBy(\n      state.TransactionController.transactions,\n      // In case for some reason any of a user's transactions do not have an id\n      // generate a new one for the transaction.\n      (tx) => {\n        if (typeof tx.id === 'undefined' || tx.id === null) {\n          // This mutates the item in the array, so will result in a change to\n          // the state.\n          tx.id = createId();\n        }\n        return tx.id;\n      },\n    );\n  }\n  return state;\n}\n","/*\n\nThis migration moves state from the flat state trie into KeyringController substate\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 5;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = selectSubstateForKeyringController(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #5${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction selectSubstateForKeyringController(state) {\n  const { config } = state;\n  const newState = {\n    ...state,\n    KeyringController: {\n      vault: state.vault,\n      selectedAccount: config.selectedAccount,\n      walletNicknames: state.walletNicknames,\n    },\n  };\n  delete newState.vault;\n  delete newState.walletNicknames;\n  delete newState.config.selectedAccount;\n\n  return newState;\n}\n","/*\n\nThis migration breaks out the TransactionManager substate\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 7;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = {\n    ...state,\n    TransactionManager: {\n      transactions: state.transactions || [],\n      gasMultiplier: state.gasMultiplier || 1,\n    },\n  };\n  delete newState.transactions;\n  delete newState.gasMultiplier;\n\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 48;\n\n/**\n * 1.  Delete NetworkController.settings\n * 2a. Migrate NetworkController.provider to Rinkeby if set to type 'rpc' or\n *     'localhost'.\n * 2b. Re-key provider.rpcTarget to provider.rpcUrl\n * 3.  Add localhost network to frequentRpcListDetail.\n * 4.  Delete CachedBalancesController.cachedBalances\n * 5.  Convert transactions metamaskNetworkId to decimal if they are hex\n * 6.  Convert address book keys from decimal to hex\n * 7.  Delete localhost key in IncomingTransactionsController\n * 8.  Merge 'localhost' tokens into 'rpc' tokens\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nconst hexRegEx = /^0x[0-9a-f]+$/iu;\nconst chainIdRegEx = /^0x[1-9a-f]+[0-9a-f]*$/iu;\n\nfunction transformState(state = {}) {\n  // 1. Delete NetworkController.settings\n  delete state.NetworkController?.settings;\n\n  // 2. Migrate NetworkController.provider to Rinkeby or rename rpcTarget key\n  const provider = state.NetworkController?.provider || {};\n  const isCustomRpcWithInvalidChainId =\n    provider.type === 'rpc' &&\n    (typeof provider.chainId !== 'string' ||\n      !chainIdRegEx.test(provider.chainId));\n  if (isCustomRpcWithInvalidChainId || provider.type === 'localhost') {\n    state.NetworkController.provider = {\n      type: 'rinkeby',\n      rpcUrl: '',\n      chainId: '0x4',\n      nickname: '',\n      rpcPrefs: {},\n      ticker: 'ETH',\n    };\n  } else if (state.NetworkController?.provider) {\n    if ('rpcTarget' in state.NetworkController.provider) {\n      const rpcUrl = state.NetworkController.provider.rpcTarget;\n      state.NetworkController.provider.rpcUrl = rpcUrl;\n    }\n    delete state.NetworkController?.provider?.rpcTarget;\n  }\n\n  // 3.  Add localhost network to frequentRpcListDetail.\n  if (!state.PreferencesController) {\n    state.PreferencesController = {};\n  }\n  if (!state.PreferencesController.frequentRpcListDetail) {\n    state.PreferencesController.frequentRpcListDetail = [];\n  }\n  state.PreferencesController.frequentRpcListDetail.unshift({\n    rpcUrl: 'http://localhost:8545',\n    chainId: '0x539',\n    ticker: 'ETH',\n    nickname: 'Localhost 8545',\n    rpcPrefs: {},\n  });\n\n  // 4.  Delete CachedBalancesController.cachedBalances\n  delete state.CachedBalancesController?.cachedBalances;\n\n  // 5.  Convert transactions metamaskNetworkId to decimal if they are hex\n  const transactions = state.TransactionController?.transactions;\n  if (Array.isArray(transactions)) {\n    transactions.forEach((transaction) => {\n      const metamaskNetworkId = transaction?.metamaskNetworkId;\n      if (\n        typeof metamaskNetworkId === 'string' &&\n        hexRegEx.test(metamaskNetworkId)\n      ) {\n        transaction.metamaskNetworkId = parseInt(\n          metamaskNetworkId,\n          16,\n        ).toString(10);\n      }\n    });\n  }\n\n  // 6.  Convert address book keys from decimal to hex\n  const addressBook = state.AddressBookController?.addressBook || {};\n  Object.keys(addressBook).forEach((networkKey) => {\n    if (/^\\d+$/iu.test(networkKey)) {\n      const chainId = `0x${parseInt(networkKey, 10).toString(16)}`;\n      updateChainIds(addressBook[networkKey], chainId);\n\n      if (addressBook[chainId]) {\n        mergeAddressBookKeys(addressBook, networkKey, chainId);\n      } else {\n        addressBook[chainId] = addressBook[networkKey];\n      }\n      delete addressBook[networkKey];\n    }\n  });\n\n  // 7.  Delete localhost key in IncomingTransactionsController\n  delete state.IncomingTransactionsController\n    ?.incomingTxLastFetchedBlocksByNetwork?.localhost;\n\n  // 8.  Merge 'localhost' tokens into 'rpc' tokens\n  const accountTokens = state.PreferencesController?.accountTokens;\n  if (accountTokens) {\n    Object.keys(accountTokens).forEach((account) => {\n      const localhostTokens = accountTokens[account]?.localhost || [];\n\n      if (localhostTokens.length > 0) {\n        const rpcTokens = accountTokens[account].rpc || [];\n\n        if (rpcTokens.length > 0) {\n          accountTokens[account].rpc = mergeTokenArrays(\n            localhostTokens,\n            rpcTokens,\n          );\n        } else {\n          accountTokens[account].rpc = localhostTokens;\n        }\n      }\n      delete accountTokens[account]?.localhost;\n    });\n  }\n\n  return state;\n}\n\n/**\n * Merges the two given keys for the given address book in place.\n *\n * @param addressBook\n * @param networkKey\n * @param chainIdKey\n */\nfunction mergeAddressBookKeys(addressBook, networkKey, chainIdKey) {\n  const networkKeyEntries = addressBook[networkKey] || {};\n  // For the new entries, start by copying the existing entries for the chainId\n  const newEntries = { ...addressBook[chainIdKey] };\n\n  // For each address of the old/networkId key entries\n  Object.keys(networkKeyEntries).forEach((address) => {\n    if (newEntries[address] && typeof newEntries[address] === 'object') {\n      const mergedEntry = {};\n\n      // Collect all keys from both entries and merge the corresponding chainId\n      // entry with the networkId entry\n      new Set([\n        ...Object.keys(newEntries[address]),\n        ...Object.keys(networkKeyEntries[address] || {}),\n      ]).forEach((key) => {\n        // Use non-empty value for the current key, if any\n        mergedEntry[key] =\n          newEntries[address][key] || networkKeyEntries[address]?.[key] || '';\n      });\n\n      newEntries[address] = mergedEntry;\n    } else if (\n      networkKeyEntries[address] &&\n      typeof networkKeyEntries[address] === 'object'\n    ) {\n      // If there is no corresponding chainId entry, just use the networkId entry\n      // directly\n      newEntries[address] = networkKeyEntries[address];\n    }\n  });\n\n  addressBook[chainIdKey] = newEntries;\n}\n\n/**\n * Updates the chainId key values to the given chainId in place for all values\n * of the given networkEntries object.\n *\n * @param networkEntries\n * @param chainId\n */\nfunction updateChainIds(networkEntries, chainId) {\n  Object.values(networkEntries).forEach((entry) => {\n    if (entry && typeof entry === 'object') {\n      entry.chainId = chainId;\n    }\n  });\n}\n\n/**\n * Merges the two given, non-empty arrays of token objects and returns a new\n * array.\n *\n * @param localhostTokens\n * @param rpcTokens\n * @returns {Array<Object>}\n */\nfunction mergeTokenArrays(localhostTokens, rpcTokens) {\n  const localhostTokensMap = tokenArrayToMap(localhostTokens);\n  const rpcTokensMap = tokenArrayToMap(rpcTokens);\n\n  const mergedTokens = [];\n  new Set([\n    ...Object.keys(localhostTokensMap),\n    ...Object.keys(rpcTokensMap),\n  ]).forEach((tokenAddress) => {\n    mergedTokens.push({\n      ...localhostTokensMap[tokenAddress],\n      ...rpcTokensMap[tokenAddress],\n    });\n  });\n\n  return mergedTokens;\n\n  function tokenArrayToMap(array) {\n    return array.reduce((map, token) => {\n      if (token?.address && typeof token?.address === 'string') {\n        map[token.address] = token;\n      }\n      return map;\n    }, {});\n  }\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 63;\n\n/**\n * Moves token state from preferences controller to TokensController\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const accountTokens = state?.PreferencesController?.accountTokens;\n  const accountHiddenTokens = state?.PreferencesController?.accountHiddenTokens;\n\n  const newAllTokens = {};\n  if (accountTokens) {\n    Object.keys(accountTokens).forEach((accountAddress) => {\n      Object.keys(accountTokens[accountAddress]).forEach((chainId) => {\n        const tokensArray = accountTokens[accountAddress][chainId];\n        if (newAllTokens[chainId] === undefined) {\n          newAllTokens[chainId] = { [accountAddress]: tokensArray };\n        } else {\n          newAllTokens[chainId] = {\n            ...newAllTokens[chainId],\n            [accountAddress]: tokensArray,\n          };\n        }\n      });\n    });\n  }\n\n  const newAllIgnoredTokens = {};\n  if (accountHiddenTokens) {\n    Object.keys(accountHiddenTokens).forEach((accountAddress) => {\n      Object.keys(accountHiddenTokens[accountAddress]).forEach((chainId) => {\n        const ignoredTokensArray = accountHiddenTokens[accountAddress][chainId];\n        if (newAllIgnoredTokens[chainId] === undefined) {\n          newAllIgnoredTokens[chainId] = {\n            [accountAddress]: ignoredTokensArray,\n          };\n        } else {\n          newAllIgnoredTokens[chainId] = {\n            ...newAllIgnoredTokens[chainId],\n            [accountAddress]: ignoredTokensArray,\n          };\n        }\n      });\n    });\n  }\n\n  if (state.TokensController) {\n    state.TokensController.allTokens = newAllTokens;\n    state.TokensController.allIgnoredTokens = newAllIgnoredTokens;\n  } else {\n    state.TokensController = {\n      allTokens: newAllTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n    };\n  }\n\n  delete state?.PreferencesController?.accountHiddenTokens;\n  delete state?.PreferencesController?.accountTokens;\n  delete state?.PreferencesController?.assetImages;\n  delete state?.PreferencesController?.hiddenTokens;\n  delete state?.PreferencesController?.tokens;\n  delete state?.PreferencesController?.suggestedTokens;\n\n  return state;\n}\n","/*\n\nThis migration breaks out the NoticeController substate\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 8;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = {\n    ...state,\n    NoticeController: {\n      noticesList: state.noticesList || [],\n    },\n  };\n  delete newState.noticesList;\n\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\nimport { LEDGER_TRANSPORT_TYPES } from '../../../shared/constants/hardware-wallets';\n\nconst version = 66;\n\n/**\n * Changes the useLedgerLive boolean property to the ledgerTransportType enum\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const defaultTransportType = window.navigator.hid\n    ? LEDGER_TRANSPORT_TYPES.WEBHID\n    : LEDGER_TRANSPORT_TYPES.U2F;\n  const useLedgerLive = Boolean(state.PreferencesController?.useLedgerLive);\n  const newState = {\n    ...state,\n    PreferencesController: {\n      ...state?.PreferencesController,\n      ledgerTransportType: useLedgerLive\n        ? LEDGER_TRANSPORT_TYPES.LIVE\n        : defaultTransportType,\n    },\n  };\n  delete newState.PreferencesController.useLedgerLive;\n  return newState;\n}\n","import { cloneDeep } from 'lodash';\n\nconst version = 68;\n\n/**\n * Transforms the PermissionsController and PermissionsMetadata substates\n * to match the new permission system.\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const {\n    PermissionsController = {},\n    PermissionsMetadata = {},\n    ...remainingState\n  } = state;\n\n  const {\n    domainMetadata = {},\n    permissionsHistory = {},\n    permissionsLog = [],\n  } = PermissionsMetadata;\n\n  return {\n    ...remainingState,\n    PermissionController: getPermissionControllerState(PermissionsController),\n    PermissionLogController: {\n      permissionActivityLog: permissionsLog,\n      permissionHistory: permissionsHistory,\n    },\n    SubjectMetadataController: getSubjectMetadataControllerState(\n      domainMetadata,\n    ),\n  };\n}\n\nfunction getPermissionControllerState(PermissionsController) {\n  const { domains = {} } = PermissionsController;\n\n  /**\n   * Example existing domain entry. Every existing domain will have a single\n   * eth_accounts permission, which simplifies the transform.\n   *\n   * 'https://metamask.github.io': {\n   *   permissions: [\n   *     {\n   *       '@context': ['https://github.com/MetaMask/rpc-cap'],\n   *       'caveats': [\n   *         {\n   *           name: 'primaryAccountOnly',\n   *           type: 'limitResponseLength',\n   *           value: 1,\n   *         },\n   *         {\n   *           name: 'exposedAccounts',\n   *           type: 'filterResponse',\n   *           value: ['0x0c97a5c81e50a02ff8be73cc3f0a0569e61f4ed8'],\n   *         },\n   *       ],\n   *       'date': 1616006369498,\n   *       'id': '3d0bdc27-e8e4-4fb0-a24b-340d61f6a3fa',\n   *       'invoker': 'https://metamask.github.io',\n   *       'parentCapability': 'eth_accounts',\n   *     },\n   *   ],\n   * },\n   */\n\n  const ETH_ACCOUNTS = 'eth_accounts';\n  const NEW_CAVEAT_TYPE = 'restrictReturnedAccounts';\n  const OLD_CAVEAT_NAME = 'exposedAccounts';\n\n  const subjects = Object.entries(domains).reduce(\n    (transformed, [origin, domainEntry]) => {\n      const {\n        permissions: [ethAccountsPermission],\n      } = domainEntry;\n\n      // There are two caveats for each eth_accounts permission, but we only\n      // need the value of one of them in the new permission system.\n      const oldCaveat = ethAccountsPermission.caveats.find(\n        (caveat) => caveat.name === OLD_CAVEAT_NAME,\n      );\n\n      const newPermission = {\n        ...ethAccountsPermission,\n        caveats: [{ type: NEW_CAVEAT_TYPE, value: oldCaveat.value }],\n      };\n\n      // We never used this, and just omit it in the new system.\n      delete newPermission['@context'];\n\n      transformed[origin] = {\n        origin,\n        permissions: {\n          [ETH_ACCOUNTS]: newPermission,\n        },\n      };\n      return transformed;\n    },\n    {},\n  );\n\n  return {\n    subjects,\n  };\n}\n\nfunction getSubjectMetadataControllerState(domainMetadata) {\n  /**\n   * Example existing domainMetadata entry.\n   *\n   * \"https://www.youtube.com\": {\n   *   \"host\": \"www.youtube.com\",\n   *   \"icon\": null,\n   *   \"lastUpdated\": 1637697914908,\n   *   \"name\": \"YouTube\"\n   * }\n   */\n\n  const subjectMetadata = Object.entries(domainMetadata).reduce(\n    (transformed, [origin, metadata]) => {\n      const {\n        name = null,\n        icon = null,\n        extensionId = null,\n        ...other\n      } = metadata;\n\n      // We're getting rid of these.\n      delete other.lastUpdated;\n      delete other.host;\n\n      if (origin) {\n        transformed[origin] = {\n          name,\n          iconUrl: icon,\n          extensionId,\n          ...other,\n          origin,\n        };\n      }\n      return transformed;\n    },\n    {},\n  );\n\n  return {\n    subjectMetadata,\n  };\n}\n","import { cloneDeep } from 'lodash';\nimport { TRANSACTION_TYPES } from '../../../shared/constants/transaction';\n\nconst version = 53;\n\n/**\n * Deprecate transactionCategory and consolidate on 'type'\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    versionedData.data = transformState(state);\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const transactions = state?.TransactionController?.transactions;\n  const incomingTransactions =\n    state?.IncomingTransactionsController?.incomingTransactions;\n  if (Array.isArray(transactions)) {\n    transactions.forEach((transaction) => {\n      if (transaction) {\n        if (\n          transaction.type !== TRANSACTION_TYPES.RETRY &&\n          transaction.type !== TRANSACTION_TYPES.CANCEL\n        ) {\n          transaction.type = transaction.transactionCategory;\n        }\n        delete transaction.transactionCategory;\n      }\n    });\n  }\n  if (incomingTransactions) {\n    const incomingTransactionsEntries = Object.entries(incomingTransactions);\n    incomingTransactionsEntries.forEach(([key, transaction]) => {\n      if (transaction) {\n        delete transaction.transactionCategory;\n        state.IncomingTransactionsController.incomingTransactions[key] = {\n          ...transaction,\n          type: TRANSACTION_TYPES.INCOMING,\n        };\n      }\n    });\n  }\n  return state;\n}\n","import { cloneDeep } from 'lodash';\nimport BigNumber from 'bignumber.js';\nimport { TEST_CHAINS } from '../../../shared/constants/network';\n\nconst hexNumberIsGreaterThanZero = (hexNumber) =>\n  new BigNumber(hexNumber || '0x0', 16).gt(0);\n\nconst version = 67;\n\n/**\n * Sets the showTestNetworks property to true if it was false or undefined, and there is evidence\n * that the user has used a test net\n */\nexport default {\n  version,\n  async migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    const state = versionedData.data;\n    const newState = transformState(state);\n    versionedData.data = newState;\n    return versionedData;\n  },\n};\n\nfunction transformState(state) {\n  const PreferencesController = state?.PreferencesController || {};\n  const preferences = PreferencesController.preferences || {};\n\n  if (preferences.showTestNetworks) {\n    return state;\n  }\n\n  const transactions = state?.TransactionController?.transactions || {};\n  const provider = state.NetworkController?.provider || {};\n  const cachedBalances = state.CachedBalancesController?.cachedBalances || {};\n\n  const userIsCurrentlyOnATestNet = TEST_CHAINS.includes(provider?.chainId);\n  const userHasMadeATestNetTransaction = Object.values(\n    transactions,\n  ).some(({ chainId }) => TEST_CHAINS.includes(chainId));\n  const userHasACachedBalanceOnATestnet = TEST_CHAINS.some((chainId) => {\n    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});\n    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(\n      hexNumberIsGreaterThanZero,\n    );\n    return userHasABalanceGreaterThanZeroOnThisChain;\n  });\n  const userHasUsedATestnet =\n    userIsCurrentlyOnATestNet ||\n    userHasMadeATestNetTransaction ||\n    userHasACachedBalanceOnATestnet;\n\n  const newState = {\n    ...state,\n    PreferencesController: {\n      ...PreferencesController,\n      preferences: {\n        ...preferences,\n        showTestNetworks: userHasUsedATestnet,\n      },\n    },\n  };\n\n  return newState;\n}\n","/*\n\nThis migration moves KeyringController.selectedAddress to PreferencesController.selectedAddress\n\n*/\n\nimport { cloneDeep } from 'lodash';\n\nconst version = 6;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = migrateState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction migrateState(state) {\n  const keyringSubstate = state.KeyringController;\n\n  // add new state\n  const newState = {\n    ...state,\n    PreferencesController: {\n      selectedAddress: keyringSubstate.selectedAccount,\n    },\n  };\n\n  // rm old state\n  delete newState.KeyringController.selectedAccount;\n\n  return newState;\n}\n","/*\n\nThis migration updates \"transaction state history\" to diffs style\n\n*/\n\nimport { cloneDeep } from 'lodash';\nimport {\n  snapshotFromTxMeta,\n  migrateFromSnapshotsToDiffs,\n} from '../controllers/transactions/lib/tx-state-history-helpers';\n\nconst version = 18;\n\nexport default {\n  version,\n\n  migrate(originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  },\n};\n\nfunction transformState(state) {\n  const newState = state;\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = newState.TransactionController;\n    newState.TransactionController.transactions = transactions.map((txMeta) => {\n      // no history: initialize\n      if (!txMeta.history || txMeta.history.length === 0) {\n        const snapshot = snapshotFromTxMeta(txMeta);\n        txMeta.history = [snapshot];\n        return txMeta;\n      }\n      // has history: migrate\n      const newHistory = migrateFromSnapshotsToDiffs(txMeta.history)\n        // remove empty diffs\n        .filter((entry) => {\n          return !Array.isArray(entry) || entry.length > 0;\n        });\n      txMeta.history = newHistory;\n      return txMeta;\n    });\n  }\n  return newState;\n}\n","var toDataView = require('to-data-view')\n\nvar RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\nvar RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'\nvar CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'\n\nmodule.exports = function base32Encode (data, variant, options) {\n  options = options || {}\n  var alphabet, defaultPadding\n\n  switch (variant) {\n    case 'RFC3548':\n    case 'RFC4648':\n      alphabet = RFC4648\n      defaultPadding = true\n      break\n    case 'RFC4648-HEX':\n      alphabet = RFC4648_HEX\n      defaultPadding = true\n      break\n    case 'Crockford':\n      alphabet = CROCKFORD\n      defaultPadding = false\n      break\n    default:\n      throw new Error('Unknown base32 variant: ' + variant)\n  }\n\n  var padding = (options.padding !== undefined ? options.padding : defaultPadding)\n  var view = toDataView(data)\n\n  var bits = 0\n  var value = 0\n  var output = ''\n\n  for (var i = 0; i < view.byteLength; i++) {\n    value = (value << 8) | view.getUint8(i)\n    bits += 8\n\n    while (bits >= 5) {\n      output += alphabet[(value >>> (bits - 5)) & 31]\n      bits -= 5\n    }\n  }\n\n  if (bits > 0) {\n    output += alphabet[(value << (5 - bits)) & 31]\n  }\n\n  if (padding) {\n    while ((output.length % 8) !== 0) {\n      output += '='\n    }\n  }\n\n  return output\n}\n","import namehash from 'eth-ens-namehash';\nimport Eth from 'ethjs-query';\nimport EthContract from 'ethjs-contract';\nimport contentHash from '@ensdomains/content-hash';\nimport registryAbi from './contracts/registry';\nimport resolverAbi from './contracts/resolver';\n\nexport default async function resolveEnsToIpfsContentId({ provider, name }) {\n  const eth = new Eth(provider);\n  const hash = namehash.hash(name);\n  const contract = new EthContract(eth);\n  // lookup registry\n  const chainId = Number.parseInt(await eth.net_version(), 10);\n  const registryAddress = getRegistryForChainId(chainId);\n  if (!registryAddress) {\n    throw new Error(\n      `EnsIpfsResolver - no known ens-ipfs registry for chainId \"${chainId}\"`,\n    );\n  }\n  const Registry = contract(registryAbi).at(registryAddress);\n  // lookup resolver\n  const resolverLookupResult = await Registry.resolver(hash);\n  const resolverAddress = resolverLookupResult[0];\n  if (hexValueIsEmpty(resolverAddress)) {\n    throw new Error(`EnsIpfsResolver - no resolver found for name \"${name}\"`);\n  }\n  const Resolver = contract(resolverAbi).at(resolverAddress);\n\n  const isEIP1577Compliant = await Resolver.supportsInterface('0xbc1c58d1');\n  const isLegacyResolver = await Resolver.supportsInterface('0xd8389dc5');\n  if (isEIP1577Compliant[0]) {\n    const contentLookupResult = await Resolver.contenthash(hash);\n    const rawContentHash = contentLookupResult[0];\n    let decodedContentHash = contentHash.decode(rawContentHash);\n    const type = contentHash.getCodec(rawContentHash);\n\n    if (type === 'ipfs-ns' || type === 'ipns-ns') {\n      decodedContentHash = contentHash.helpers.cidV0ToV1Base32(\n        decodedContentHash,\n      );\n    }\n\n    return { type, hash: decodedContentHash };\n  }\n  if (isLegacyResolver[0]) {\n    // lookup content id\n    const contentLookupResult = await Resolver.content(hash);\n    const content = contentLookupResult[0];\n    if (hexValueIsEmpty(content)) {\n      throw new Error(\n        `EnsIpfsResolver - no content ID found for name \"${name}\"`,\n      );\n    }\n    return { type: 'swarm-ns', hash: content.slice(2) };\n  }\n  throw new Error(\n    `EnsIpfsResolver - the resolver for name \"${name}\" is not standard, it should either supports contenthash() or content()`,\n  );\n}\n\nfunction hexValueIsEmpty(value) {\n  return [\n    undefined,\n    null,\n    '0x',\n    '0x0',\n    '0x0000000000000000000000000000000000000000000000000000000000000000',\n  ].includes(value);\n}\n\n/**\n * Returns the registry address for the given chain ID\n *\n * @param {number} chainId - the chain ID\n * @returns {string|null} the registry address if known, null otherwise\n */\nfunction getRegistryForChainId(chainId) {\n  switch (chainId) {\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n      // Mainnet, Ropsten, Rinkeby, and Goerli, respectively, use the same address\n      return '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';\n    default:\n      return null;\n  }\n}\n","/**\n * Returns a middleware that appends the DApp TabId to the request\n *\n * @param {{ tabId: number }} opts - The middleware options\n * @returns {Function}\n */\nexport default function createTabIdMiddleware(opts) {\n  return function tabIdMiddleware(\n    /** @type {any} */ req,\n    /** @type {any} */ _,\n    /** @type {Function} */ next,\n  ) {\n    req.tabId = opts.tabId;\n    next();\n  };\n}\n","/**\n * Returns a middleware that appends the DApp origin to request\n *\n * @param {{ origin: string }} opts - The middleware options\n * @returns {Function}\n */\nexport default function createOriginMiddleware(opts) {\n  return function originMiddleware(\n    /** @type {any} */ req,\n    /** @type {any} */ _,\n    /** @type {Function} */ next,\n  ) {\n    req.origin = opts.origin;\n    next();\n  };\n}\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nif (\"production\" !== 'production') {\n  // All bundlers will remove this block in production bundle\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n      'If you don’t need unpredictable IDs, you can use `nanoid/non-secure`. ' +\n      'For secure ID install `expo-random` locally and use `nanoid/async`.'\n    )\n  }\n  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n      'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nvar crypto = self.crypto || self.msCrypto\n\n// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Symbols are generated for smaller size.\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\nvar url = '-_'\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\nvar i = 36\nwhile (i--) {\n  // 36 is radix. Number.prototype.toString(36) returns number\n  // in Base36 representation. Base36 is like hex, but it uses 0–9 and a-z.\n  url += i.toString(36)\n}\n// Loop from 36 to 10 (from Z to A in Base36).\ni = 36\nwhile (i-- - 10) {\n  url += i.toString(36).toUpperCase()\n}\n\nmodule.exports = function (size) {\n  var id = ''\n  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))\n  i = size || 21\n\n  // Compact alternative for `for (var i = 0; i < size; i++)`\n  while (i--) {\n    // We can’t use bytes bigger than the alphabet. 63 is 00111111 bitmask.\n    // This mask reduces random byte 0-255 to 0-63 values.\n    // There is no need in `|| ''` and `* 1.6` hacks in here,\n    // because bitmask trim bytes exact to alphabet size.\n    id += url[bytes[i] & 63]\n  }\n  return id\n}\n","import { ethErrors, serializeError } from 'eth-rpc-errors';\n\nconst createMetaRPCHandler = (api, outStream) => {\n  return async (data) => {\n    if (outStream._writableState.ended) {\n      return;\n    }\n    if (!api[data.method]) {\n      outStream.write({\n        jsonrpc: '2.0',\n        error: ethErrors.rpc.methodNotFound({\n          message: `${data.method} not found`,\n        }),\n        id: data.id,\n      });\n      return;\n    }\n\n    let result;\n    let error;\n    try {\n      result = await api[data.method](...data.params);\n    } catch (err) {\n      error = err;\n    }\n\n    if (outStream._writableState.ended) {\n      if (error) {\n        console.error(error);\n      }\n      return;\n    }\n\n    if (error) {\n      outStream.write({\n        jsonrpc: '2.0',\n        error: serializeError(error, { shouldIncludeStack: true }),\n        id: data.id,\n      });\n    } else {\n      outStream.write({\n        jsonrpc: '2.0',\n        result,\n        id: data.id,\n      });\n    }\n  };\n};\n\nexport default createMetaRPCHandler;\n","const DuplexStream = require('readable-stream').Duplex\n\nmodule.exports = createEngineStream\n\nfunction createEngineStream({ engine }) {\n  if (!engine) throw new Error('Missing engine parameter!')\n  const stream = new DuplexStream({ objectMode: true, read, write })\n  // forward notifications\n  if (engine.on) {\n    engine.on('notification', (message) => {\n      stream.push(message)\n    })\n  }\n  return stream\n\n  function read () {\n    return false\n  }\n  function write (req, encoding, cb) {\n    engine.handle(req, (err, res) => {\n      this.push(res)\n    })\n    cb()\n  }\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./idRemapMiddleware\"), exports);\n__exportStar(require(\"./createAsyncMiddleware\"), exports);\n__exportStar(require(\"./createScaffoldMiddleware\"), exports);\n__exportStar(require(\"./getUniqueId\"), exports);\n__exportStar(require(\"./JsonRpcEngine\"), exports);\n__exportStar(require(\"./mergeMiddleware\"), exports);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsc0RBQW9DO0FBQ3BDLDBEQUF3QztBQUN4Qyw2REFBMkM7QUFDM0MsZ0RBQThCO0FBQzlCLGtEQUFnQztBQUNoQyxvREFBa0MifQ==","import log from 'loglevel';\nimport extension from 'extensionizer';\n\n/**\n * Returns a middleware that intercepts `wallet_registerOnboarding` messages\n *\n * @param {{ location: string, registerOnboarding: Function }} opts - The middleware options\n * @returns {(req: any, res: any, next: Function, end: Function) => void}\n */\nexport default function createOnboardingMiddleware({\n  location,\n  registerOnboarding,\n}) {\n  return async function originMiddleware(req, res, next, end) {\n    try {\n      if (req.method !== 'wallet_registerOnboarding') {\n        next();\n        return;\n      }\n      if (req.tabId && req.tabId !== extension.tabs.TAB_ID_NONE) {\n        await registerOnboarding(location, req.tabId);\n      } else {\n        log.debug(\n          `'wallet_registerOnboarding' message from ${location} ignored due to missing tabId`,\n        );\n      }\n      res.result = true;\n      end();\n    } catch (error) {\n      end(error);\n    }\n  };\n}\n","import { ObservableStore } from '@metamask/obs-store';\nimport { getPersistentState } from '@metamask/controllers';\n\n/**\n * @typedef {import('@metamask/controllers').ControllerMessenger} ControllerMessenger\n */\n\n/**\n * An ObservableStore that can composes a flat\n * structure of child stores based on configuration\n */\nexport default class ComposableObservableStore extends ObservableStore {\n  /**\n   * Describes which stores are being composed. The key is the name of the\n   * store, and the value is either an ObserableStore, or a controller that\n   * extends one of the two base controllers in the `@metamask/controllers`\n   * package.\n   *\n   * @type {Record<string, Object>}\n   */\n  config = {};\n\n  /**\n   * Create a new store\n   *\n   * @param {Object} options\n   * @param {Object} [options.config] - Map of internal state keys to child stores\n   * @param {ControllerMessenger} options.controllerMessenger - The controller\n   *   messenger, used for subscribing to events from BaseControllerV2-based\n   *   controllers.\n   * @param {Object} [options.state] - The initial store state\n   * @param {boolean} [options.persist] - Whether or not to apply the persistence for v2 controllers\n   */\n  constructor({ config, controllerMessenger, state, persist }) {\n    super(state);\n    this.persist = persist;\n    this.controllerMessenger = controllerMessenger;\n    if (config) {\n      this.updateStructure(config);\n    }\n  }\n\n  /**\n   * Composes a new internal store subscription structure\n   *\n   * @param {Record<string, Object>} config - Describes which stores are being\n   *   composed. The key is the name of the store, and the value is either an\n   *   ObserableStore, or a controller that extends one of the two base\n   *   controllers in the `@metamask/controllers` package.\n   */\n  updateStructure(config) {\n    this.config = config;\n    this.removeAllListeners();\n    for (const key of Object.keys(config)) {\n      if (!config[key]) {\n        throw new Error(`Undefined '${key}'`);\n      }\n      const store = config[key];\n      if (store.subscribe) {\n        config[key].subscribe((state) => {\n          this.updateState({ [key]: state });\n        });\n      } else {\n        this.controllerMessenger.subscribe(\n          `${store.name}:stateChange`,\n          (state) => {\n            let updatedState = state;\n            if (this.persist) {\n              updatedState = getPersistentState(state, config[key].metadata);\n            }\n            this.updateState({ [key]: updatedState });\n          },\n        );\n      }\n    }\n  }\n\n  /**\n   * Merges all child store state into a single object rather than\n   * returning an object keyed by child store class name\n   *\n   * @returns {Object} Object containing merged child store state\n   */\n  getFlatState() {\n    if (!this.config) {\n      return {};\n    }\n    let flatState = {};\n    for (const key of Object.keys(this.config)) {\n      const controller = this.config[key];\n      const state = controller.getState\n        ? controller.getState()\n        : controller.state;\n      flatState = { ...flatState, ...state };\n    }\n    return flatState;\n  }\n}\n","import EventEmitter from 'events';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { bufferToHex } from 'ethereumjs-util';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { MESSAGE_TYPE } from '../../../shared/constants/app';\nimport { METAMASK_CONTROLLER_EVENTS } from '../metamask-controller';\nimport createId from '../../../shared/modules/random-id';\n\n/**\n * Represents, and contains data about, an 'eth_sign' type signature request. These are created when a signature for\n * an eth_sign call is requested.\n *\n * @see {@link https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign}\n * @typedef {Object} Message\n * @property {number} id An id to track and identify the message object\n * @property {Object} msgParams The parameters to pass to the eth_sign method once the signature request is approved.\n * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.\n * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request\n * @property {number} time The epoch time at which the this message was created\n * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'\n * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' with\n * always have a 'eth_sign' type.\n */\n\nexport default class MessageManager extends EventEmitter {\n  /**\n   * Controller in charge of managing - storing, adding, removing, updating - Messages.\n   *\n   * @param {object} opts - Controller options\n   * @param {Function} opts.metricsEvent - A function for emitting a metric event.\n   */\n  constructor({ metricsEvent }) {\n    super();\n    this.memStore = new ObservableStore({\n      unapprovedMsgs: {},\n      unapprovedMsgCount: 0,\n    });\n    this.messages = [];\n    this.metricsEvent = metricsEvent;\n  }\n\n  /**\n   * A getter for the number of 'unapproved' Messages in this.messages\n   *\n   * @returns {number} The number of 'unapproved' Messages in this.messages\n   */\n  get unapprovedMsgCount() {\n    return Object.keys(this.getUnapprovedMsgs()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' Messages in this.messages\n   *\n   * @returns {Object} An index of Message ids to Messages, for all 'unapproved' Messages in this.messages\n   */\n  getUnapprovedMsgs() {\n    return this.messages\n      .filter((msg) => msg.status === 'unapproved')\n      .reduce((result, msg) => {\n        result[msg.id] = msg;\n        return result;\n      }, {});\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the\n   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.\n   *\n   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @returns {promise} after signature has been\n   */\n  async addUnapprovedMessageAsync(msgParams, req) {\n    const msgId = this.addUnapprovedMessage(msgParams, req);\n    return await new Promise((resolve, reject) => {\n      // await finished\n      this.once(`${msgId}:finished`, (data) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig);\n          case 'rejected':\n            return reject(\n              ethErrors.provider.userRejectedRequest(\n                'MetaMask Message Signature: User denied message signature.',\n              ),\n            );\n          case 'errored':\n            return reject(\n              new Error(`MetaMask Message Signature: ${data.error}`),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Message Signature: Unknown problem: ${JSON.stringify(\n                  msgParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the\n   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.\n   *\n   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.\n   * @param {Object} [req] - The original request object where the origin may be specified\n   * @returns {number} The id of the newly created message.\n   */\n  addUnapprovedMessage(msgParams, req) {\n    // add origin from request\n    if (req) {\n      msgParams.origin = req.origin;\n    }\n    msgParams.data = normalizeMsgData(msgParams.data);\n    // create txData obj with parameters and meta data\n    const time = new Date().getTime();\n    const msgId = createId();\n    const msgData = {\n      id: msgId,\n      msgParams,\n      time,\n      status: 'unapproved',\n      type: MESSAGE_TYPE.ETH_SIGN,\n    };\n    this.addMsg(msgData);\n\n    // signal update\n    this.emit('update');\n    return msgId;\n  }\n\n  /**\n   * Adds a passed Message to this.messages, and calls this._saveMsgList() to save the unapproved Messages from that\n   * list to this.memStore.\n   *\n   * @param {Message} msg - The Message to add to this.messages\n   */\n  addMsg(msg) {\n    this.messages.push(msg);\n    this._saveMsgList();\n  }\n\n  /**\n   * Returns a specified Message.\n   *\n   * @param {number} msgId - The id of the Message to get\n   * @returns {Message|undefined} The Message with the id that matches the passed msgId, or undefined if no Message has that id.\n   */\n  getMsg(msgId) {\n    return this.messages.find((msg) => msg.id === msgId);\n  }\n\n  /**\n   * Approves a Message. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise with\n   * any the message params modified for proper signing.\n   *\n   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.\n   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.\n   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.\n   */\n  approveMessage(msgParams) {\n    this.setMsgStatusApproved(msgParams.metamaskId);\n    return this.prepMsgForSigning(msgParams);\n  }\n\n  /**\n   * Sets a Message status to 'approved' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the Message to approve.\n   */\n  setMsgStatusApproved(msgId) {\n    this._setMsgStatus(msgId, 'approved');\n  }\n\n  /**\n   * Sets a Message status to 'signed' via a call to this._setMsgStatus and updates that Message in this.messages by\n   * adding the raw signature data of the signature request to the Message\n   *\n   * @param {number} msgId - The id of the Message to sign.\n   * @param {buffer} rawSig - The raw data of the signature request\n   */\n  setMsgStatusSigned(msgId, rawSig) {\n    const msg = this.getMsg(msgId);\n    msg.rawSig = rawSig;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'signed');\n  }\n\n  /**\n   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams\n   *\n   * @param {Object} msgParams - The msgParams to modify\n   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed\n   */\n  prepMsgForSigning(msgParams) {\n    delete msgParams.metamaskId;\n    return Promise.resolve(msgParams);\n  }\n\n  /**\n   * Sets a Message status to 'rejected' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the Message to reject.\n   * @param reason\n   */\n  rejectMsg(msgId, reason = undefined) {\n    if (reason) {\n      const msg = this.getMsg(msgId);\n      this.metricsEvent({\n        event: reason,\n        category: 'Transactions',\n        properties: {\n          action: 'Sign Request',\n          type: msg.type,\n        },\n      });\n    }\n    this._setMsgStatus(msgId, 'rejected');\n  }\n\n  /**\n   * Sets a Message status to 'errored' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the Message to error\n   * @param error\n   */\n  errorMessage(msgId, error) {\n    const msg = this.getMsg(msgId);\n    msg.error = error;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'errored');\n  }\n\n  /**\n   * Clears all unapproved messages from memory.\n   */\n  clearUnapproved() {\n    this.messages = this.messages.filter((msg) => msg.status !== 'unapproved');\n    this._saveMsgList();\n  }\n\n  /**\n   * Updates the status of a Message in this.messages via a call to this._updateMsg\n   *\n   * @private\n   * @param {number} msgId - The id of the Message to update.\n   * @param {string} status - The new status of the Message.\n   * @throws A 'MessageManager - Message not found for id: \"${msgId}\".' if there is no Message in this.messages with an\n   * id equal to the passed msgId\n   * @fires An event with a name equal to `${msgId}:${status}`. The Message is also fired.\n   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along with the message\n   */\n  _setMsgStatus(msgId, status) {\n    const msg = this.getMsg(msgId);\n    if (!msg) {\n      throw new Error(`MessageManager - Message not found for id: \"${msgId}\".`);\n    }\n    msg.status = status;\n    this._updateMsg(msg);\n    this.emit(`${msgId}:${status}`, msg);\n    if (status === 'rejected' || status === 'signed') {\n      this.emit(`${msgId}:finished`, msg);\n    }\n  }\n\n  /**\n   * Sets a Message in this.messages to the passed Message if the ids are equal. Then saves the unapprovedMsg list to\n   * storage via this._saveMsgList\n   *\n   * @private\n   * @param {Message} msg - A Message that will replace an existing Message (with the same id) in this.messages\n   */\n  _updateMsg(msg) {\n    const index = this.messages.findIndex((message) => message.id === msg.id);\n    if (index !== -1) {\n      this.messages[index] = msg;\n    }\n    this._saveMsgList();\n  }\n\n  /**\n   * Saves the unapproved messages, and their count, to this.memStore\n   *\n   * @private\n   * @fires 'updateBadge'\n   */\n  _saveMsgList() {\n    const unapprovedMsgs = this.getUnapprovedMsgs();\n    const unapprovedMsgCount = Object.keys(unapprovedMsgs).length;\n    this.memStore.updateState({ unapprovedMsgs, unapprovedMsgCount });\n    this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);\n  }\n}\n\n/**\n * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.\n *\n * @param {any} data - The buffer data to convert to a hex\n * @returns {string} A hex string conversion of the buffer data\n */\nexport function normalizeMsgData(data) {\n  if (data.slice(0, 2) === '0x') {\n    // data is already hex\n    return data;\n  }\n  // data is unicode, convert to hex\n  return bufferToHex(Buffer.from(data, 'utf8'));\n}\n","import { ObservableStore } from '@metamask/obs-store';\nimport log from 'loglevel';\n\n/**\n * @typedef {Object} InitState\n * @property {boolean} seedPhraseBackedUp Indicates whether the user has completed the seed phrase backup challenge\n * @property {boolean} completedOnboarding Indicates whether the user has completed the onboarding flow\n */\n\n/**\n * @typedef {Object} OnboardingOptions\n * @property {InitState} initState The initial controller state\n */\n\n/**\n * Controller responsible for maintaining\n * state related to onboarding\n */\nexport default class OnboardingController {\n  /**\n   * Creates a new controller instance\n   *\n   * @param {OnboardingOptions} [opts] - Controller configuration parameters\n   */\n  constructor(opts = {}) {\n    const initialTransientState = {\n      onboardingTabs: {},\n    };\n    const initState = {\n      seedPhraseBackedUp: null,\n      firstTimeFlowType: null,\n      completedOnboarding: false,\n      ...opts.initState,\n      ...initialTransientState,\n    };\n    this.store = new ObservableStore(initState);\n  }\n\n  setSeedPhraseBackedUp(newSeedPhraseBackUpState) {\n    this.store.updateState({\n      seedPhraseBackedUp: newSeedPhraseBackUpState,\n    });\n  }\n\n  // /**\n  //  * Sets the completedOnboarding state to true, indicating that the user has completed the\n  //  * onboarding process.\n  //  */\n  completeOnboarding() {\n    this.store.updateState({\n      completedOnboarding: true,\n    });\n    return Promise.resolve(true);\n  }\n\n  /**\n   * Setter for the `firstTimeFlowType` property\n   *\n   * @param {string} type - Indicates the type of first time flow - create or import - the user wishes to follow\n   */\n  setFirstTimeFlowType(type) {\n    this.store.updateState({ firstTimeFlowType: type });\n  }\n\n  /**\n   * Registering a site as having initiated onboarding\n   *\n   * @param {string} location - The location of the site registering\n   * @param {string} tabId - The id of the tab registering\n   */\n  registerOnboarding = async (location, tabId) => {\n    if (this.completedOnboarding) {\n      log.debug('Ignoring registerOnboarding; user already onboarded');\n      return;\n    }\n    const onboardingTabs = { ...this.store.getState().onboardingTabs };\n    if (!onboardingTabs[location] || onboardingTabs[location] !== tabId) {\n      log.debug(\n        `Registering onboarding tab at location '${location}' with tabId '${tabId}'`,\n      );\n      onboardingTabs[location] = tabId;\n      this.store.updateState({ onboardingTabs });\n    }\n  };\n}\n","import EventEmitter from 'events';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { bufferToHex, stripHexPrefix } from 'ethereumjs-util';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport { MESSAGE_TYPE } from '../../../shared/constants/app';\nimport { METAMASK_CONTROLLER_EVENTS } from '../metamask-controller';\nimport createId from '../../../shared/modules/random-id';\nimport { addHexPrefix } from './util';\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\n\n/**\n * Represents, and contains data about, an 'personal_sign' type signature request. These are created when a\n * signature for an personal_sign call is requested.\n *\n * @see {@link https://web3js.readthedocs.io/en/1.0/web3-eth-personal.html#sign}\n * @typedef {Object} PersonalMessage\n * @property {number} id An id to track and identify the message object\n * @property {Object} msgParams The parameters to pass to the personal_sign method once the signature request is\n * approved.\n * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.\n * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request\n * @property {number} time The epoch time at which the this message was created\n * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'\n * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will\n * always have a 'personal_sign' type.\n */\n\nexport default class PersonalMessageManager extends EventEmitter {\n  /**\n   * Controller in charge of managing - storing, adding, removing, updating - PersonalMessage.\n   *\n   * @param options\n   * @param options.metricsEvent\n   */\n  constructor({ metricsEvent }) {\n    super();\n    this.memStore = new ObservableStore({\n      unapprovedPersonalMsgs: {},\n      unapprovedPersonalMsgCount: 0,\n    });\n    this.messages = [];\n    this.metricsEvent = metricsEvent;\n  }\n\n  /**\n   * A getter for the number of 'unapproved' PersonalMessages in this.messages\n   *\n   * @returns {number} The number of 'unapproved' PersonalMessages in this.messages\n   */\n  get unapprovedPersonalMsgCount() {\n    return Object.keys(this.getUnapprovedMsgs()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' PersonalMessages in this.messages\n   *\n   * @returns {Object} An index of PersonalMessage ids to PersonalMessages, for all 'unapproved' PersonalMessages in\n   * this.messages\n   */\n  getUnapprovedMsgs() {\n    return this.messages\n      .filter((msg) => msg.status === 'unapproved')\n      .reduce((result, msg) => {\n        result[msg.id] = msg;\n        return result;\n      }, {});\n  }\n\n  /**\n   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to\n   * this.memStore.\n   *\n   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @returns {promise} When the message has been signed or rejected\n   */\n  addUnapprovedMessageAsync(msgParams, req) {\n    return new Promise((resolve, reject) => {\n      if (!msgParams.from) {\n        reject(\n          new Error('MetaMask Message Signature: from field is required.'),\n        );\n        return;\n      }\n      const msgId = this.addUnapprovedMessage(msgParams, req);\n      this.once(`${msgId}:finished`, (data) => {\n        switch (data.status) {\n          case 'signed':\n            resolve(data.rawSig);\n            return;\n          case 'rejected':\n            reject(\n              ethErrors.provider.userRejectedRequest(\n                'MetaMask Message Signature: User denied message signature.',\n              ),\n            );\n            return;\n          case 'errored':\n            reject(new Error(`MetaMask Message Signature: ${data.error}`));\n            return;\n          default:\n            reject(\n              new Error(\n                `MetaMask Message Signature: Unknown problem: ${JSON.stringify(\n                  msgParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to\n   * this.memStore.\n   *\n   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @returns {number} The id of the newly created PersonalMessage.\n   */\n  addUnapprovedMessage(msgParams, req) {\n    log.debug(\n      `PersonalMessageManager addUnapprovedMessage: ${JSON.stringify(\n        msgParams,\n      )}`,\n    );\n    // add origin from request\n    if (req) {\n      msgParams.origin = req.origin;\n    }\n    msgParams.data = this.normalizeMsgData(msgParams.data);\n    // create txData obj with parameters and meta data\n    const time = new Date().getTime();\n    const msgId = createId();\n    const msgData = {\n      id: msgId,\n      msgParams,\n      time,\n      status: 'unapproved',\n      type: MESSAGE_TYPE.PERSONAL_SIGN,\n    };\n    this.addMsg(msgData);\n\n    // signal update\n    this.emit('update');\n    return msgId;\n  }\n\n  /**\n   * Adds a passed PersonalMessage to this.messages, and calls this._saveMsgList() to save the unapproved PersonalMessages from that\n   * list to this.memStore.\n   *\n   * @param {Message} msg - The PersonalMessage to add to this.messages\n   */\n  addMsg(msg) {\n    this.messages.push(msg);\n    this._saveMsgList();\n  }\n\n  /**\n   * Returns a specified PersonalMessage.\n   *\n   * @param {number} msgId - The id of the PersonalMessage to get\n   * @returns {PersonalMessage|undefined} The PersonalMessage with the id that matches the passed msgId, or undefined\n   * if no PersonalMessage has that id.\n   */\n  getMsg(msgId) {\n    return this.messages.find((msg) => msg.id === msgId);\n  }\n\n  /**\n   * Approves a PersonalMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise\n   * with any the message params modified for proper signing.\n   *\n   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.\n   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.\n   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.\n   */\n  approveMessage(msgParams) {\n    this.setMsgStatusApproved(msgParams.metamaskId);\n    return this.prepMsgForSigning(msgParams);\n  }\n\n  /**\n   * Sets a PersonalMessage status to 'approved' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the PersonalMessage to approve.\n   */\n  setMsgStatusApproved(msgId) {\n    this._setMsgStatus(msgId, 'approved');\n  }\n\n  /**\n   * Sets a PersonalMessage status to 'signed' via a call to this._setMsgStatus and updates that PersonalMessage in\n   * this.messages by adding the raw signature data of the signature request to the PersonalMessage\n   *\n   * @param {number} msgId - The id of the PersonalMessage to sign.\n   * @param {buffer} rawSig - The raw data of the signature request\n   */\n  setMsgStatusSigned(msgId, rawSig) {\n    const msg = this.getMsg(msgId);\n    msg.rawSig = rawSig;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'signed');\n  }\n\n  /**\n   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams\n   *\n   * @param {Object} msgParams - The msgParams to modify\n   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed\n   */\n  prepMsgForSigning(msgParams) {\n    delete msgParams.metamaskId;\n    return Promise.resolve(msgParams);\n  }\n\n  /**\n   * Sets a PersonalMessage status to 'rejected' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the PersonalMessage to reject.\n   * @param reason\n   */\n  rejectMsg(msgId, reason = undefined) {\n    if (reason) {\n      const msg = this.getMsg(msgId);\n      this.metricsEvent({\n        event: reason,\n        category: 'Transactions',\n        properties: {\n          action: 'Sign Request',\n          type: msg.type,\n        },\n      });\n    }\n    this._setMsgStatus(msgId, 'rejected');\n  }\n\n  /**\n   * Sets a Message status to 'errored' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the Message to error\n   * @param error\n   */\n  errorMessage(msgId, error) {\n    const msg = this.getMsg(msgId);\n    msg.error = error;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'errored');\n  }\n\n  /**\n   * Clears all unapproved messages from memory.\n   */\n  clearUnapproved() {\n    this.messages = this.messages.filter((msg) => msg.status !== 'unapproved');\n    this._saveMsgList();\n  }\n\n  /**\n   * Updates the status of a PersonalMessage in this.messages via a call to this._updateMsg\n   *\n   * @private\n   * @param {number} msgId - The id of the PersonalMessage to update.\n   * @param {string} status - The new status of the PersonalMessage.\n   * @throws A 'PersonalMessageManager - PersonalMessage not found for id: \"${msgId}\".' if there is no PersonalMessage\n   * in this.messages with an id equal to the passed msgId\n   * @fires An event with a name equal to `${msgId}:${status}`. The PersonalMessage is also fired.\n   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along\n   * with the PersonalMessage\n   */\n  _setMsgStatus(msgId, status) {\n    const msg = this.getMsg(msgId);\n    if (!msg) {\n      throw new Error(\n        `PersonalMessageManager - Message not found for id: \"${msgId}\".`,\n      );\n    }\n    msg.status = status;\n    this._updateMsg(msg);\n    this.emit(`${msgId}:${status}`, msg);\n    if (status === 'rejected' || status === 'signed') {\n      this.emit(`${msgId}:finished`, msg);\n    }\n  }\n\n  /**\n   * Sets a PersonalMessage in this.messages to the passed PersonalMessage if the ids are equal. Then saves the\n   * unapprovedPersonalMsgs index to storage via this._saveMsgList\n   *\n   * @private\n   * @param {PersonalMessage} msg - A PersonalMessage that will replace an existing PersonalMessage (with the same\n   * id) in this.messages\n   */\n  _updateMsg(msg) {\n    const index = this.messages.findIndex((message) => message.id === msg.id);\n    if (index !== -1) {\n      this.messages[index] = msg;\n    }\n    this._saveMsgList();\n  }\n\n  /**\n   * Saves the unapproved PersonalMessages, and their count, to this.memStore\n   *\n   * @private\n   * @fires 'updateBadge'\n   */\n  _saveMsgList() {\n    const unapprovedPersonalMsgs = this.getUnapprovedMsgs();\n    const unapprovedPersonalMsgCount = Object.keys(unapprovedPersonalMsgs)\n      .length;\n    this.memStore.updateState({\n      unapprovedPersonalMsgs,\n      unapprovedPersonalMsgCount,\n    });\n    this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);\n  }\n\n  /**\n   * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.\n   *\n   * @param {any} data - The buffer data to convert to a hex\n   * @returns {string} A hex string conversion of the buffer data\n   */\n  normalizeMsgData(data) {\n    try {\n      const stripped = stripHexPrefix(data);\n      if (stripped.match(hexRe)) {\n        return addHexPrefix(stripped);\n      }\n    } catch (e) {\n      log.debug(`Message was not hex encoded, interpreting as utf8.`);\n    }\n\n    return bufferToHex(Buffer.from(data, 'utf8'));\n  }\n}\n","import KeyringController from 'eth-keyring-controller';\nimport log from 'loglevel';\n\nconst seedPhraseVerifier = {\n  /**\n   * Verifies if the seed words can restore the accounts.\n   *\n   * Key notes:\n   * - The seed words can recreate the primary keyring and the accounts belonging to it.\n   * - The created accounts in the primary keyring are always the same.\n   * - The keyring always creates the accounts in the same sequence.\n   *\n   * @param {Array} createdAccounts - The accounts to restore\n   * @param {Buffer} seedPhrase - The seed words to verify, encoded as a Buffer\n   * @returns {Promise<void>}\n   */\n  async verifyAccounts(createdAccounts, seedPhrase) {\n    if (!createdAccounts || createdAccounts.length < 1) {\n      throw new Error('No created accounts defined.');\n    }\n\n    const keyringController = new KeyringController({});\n    const Keyring = keyringController.getKeyringClassForType('HD Key Tree');\n    const opts = {\n      mnemonic: seedPhrase,\n      numberOfAccounts: createdAccounts.length,\n    };\n\n    const keyring = new Keyring(opts);\n    const restoredAccounts = await keyring.getAccounts();\n    log.debug(`Created accounts: ${JSON.stringify(createdAccounts)}`);\n    log.debug(`Restored accounts: ${JSON.stringify(restoredAccounts)}`);\n\n    if (restoredAccounts.length !== createdAccounts.length) {\n      // this should not happen...\n      throw new Error('Wrong number of accounts');\n    }\n\n    for (let i = 0; i < restoredAccounts.length; i++) {\n      if (\n        restoredAccounts[i].toLowerCase() !== createdAccounts[i].toLowerCase()\n      ) {\n        throw new Error(\n          `Not identical accounts! Original: ${createdAccounts[i]}, Restored: ${restoredAccounts[i]}`,\n        );\n      }\n    }\n  },\n};\n\nexport default seedPhraseVerifier;\n","import Web3 from 'web3';\nimport { warn } from 'loglevel';\nimport SINGLE_CALL_BALANCES_ABI from 'single-call-balance-checker-abi';\nimport { SINGLE_CALL_BALANCES_ADDRESS } from '../constants/contracts';\nimport { MINUTE } from '../../../shared/constants/time';\nimport { isEqualCaseInsensitive } from '../../../ui/helpers/utils/util';\nimport { MAINNET_CHAIN_ID } from '../../../shared/constants/network';\n\n// By default, poll every 3 minutes\nconst DEFAULT_INTERVAL = MINUTE * 3;\n\n/**\n * A controller that polls for token exchange\n * rates based on a user's current token list\n */\nexport default class DetectTokensController {\n  /**\n   * Creates a DetectTokensController\n   *\n   * @param {Object} [config] - Options to configure controller\n   * @param config.interval\n   * @param config.preferences\n   * @param config.network\n   * @param config.keyringMemStore\n   * @param config.tokenList\n   * @param config.tokensController\n   */\n  constructor({\n    interval = DEFAULT_INTERVAL,\n    preferences,\n    network,\n    keyringMemStore,\n    tokenList,\n    tokensController,\n  } = {}) {\n    this.tokensController = tokensController;\n    this.preferences = preferences;\n    this.interval = interval;\n    this.network = network;\n    this.keyringMemStore = keyringMemStore;\n    this.tokenList = tokenList;\n    this.selectedAddress = this.preferences?.store.getState().selectedAddress;\n    this.tokenAddresses = this.tokensController?.state.tokens.map((token) => {\n      return token.address;\n    });\n    this.hiddenTokens = this.tokensController?.state.ignoredTokens;\n\n    preferences?.store.subscribe(({ selectedAddress, useTokenDetection }) => {\n      if (\n        this.selectedAddress !== selectedAddress ||\n        this.useTokenDetection !== useTokenDetection\n      ) {\n        this.selectedAddress = selectedAddress;\n        this.useTokenDetection = useTokenDetection;\n        this.restartTokenDetection();\n      }\n    });\n    tokensController?.subscribe(({ tokens = [], ignoredTokens = [] }) => {\n      this.tokenAddresses = tokens.map((token) => {\n        return token.address;\n      });\n      this.hiddenTokens = ignoredTokens;\n    });\n  }\n\n  async _getTokenBalances(tokens) {\n    const ethContract = this.web3.eth\n      .contract(SINGLE_CALL_BALANCES_ABI)\n      .at(SINGLE_CALL_BALANCES_ADDRESS);\n    return new Promise((resolve, reject) => {\n      ethContract.balances([this.selectedAddress], tokens, (error, result) => {\n        if (error) {\n          return reject(error);\n        }\n        return resolve(result);\n      });\n    });\n  }\n\n  /**\n   * For each token in the tokenlist provided by the TokenListController, check selectedAddress balance.\n   */\n  async detectNewTokens() {\n    if (!this.isActive) {\n      return;\n    }\n\n    const { tokenList } = this._tokenList.state;\n    // since the token detection is currently enabled only on Mainnet\n    // we can use the chainId check to ensure token detection is not triggered for any other network\n    // but once the balance check contract for other networks are deploayed and ready to use, we need to update this check.\n    if (\n      this._network.store.getState().provider.chainId !== MAINNET_CHAIN_ID ||\n      Object.keys(tokenList).length === 0\n    ) {\n      return;\n    }\n\n    const tokensToDetect = [];\n    this.web3.setProvider(this._network._provider);\n    for (const tokenAddress in tokenList) {\n      if (\n        !this.tokenAddresses.find((address) =>\n          isEqualCaseInsensitive(address, tokenAddress),\n        ) &&\n        !this.hiddenTokens.find((address) =>\n          isEqualCaseInsensitive(address, tokenAddress),\n        )\n      ) {\n        tokensToDetect.push(tokenAddress);\n      }\n    }\n    const sliceOfTokensToDetect = [\n      tokensToDetect.slice(0, 1000),\n      tokensToDetect.slice(1000, tokensToDetect.length - 1),\n    ];\n    for (const tokensSlice of sliceOfTokensToDetect) {\n      let result;\n      try {\n        result = await this._getTokenBalances(tokensSlice);\n      } catch (error) {\n        warn(\n          `MetaMask - DetectTokensController single call balance fetch failed`,\n          error,\n        );\n        return;\n      }\n\n      const tokensWithBalance = tokensSlice.filter((_, index) => {\n        const balance = result[index];\n        return balance && !balance.isZero();\n      });\n\n      await Promise.all(\n        tokensWithBalance.map((tokenAddress) => {\n          return this.tokensController.addToken(\n            tokenAddress,\n            tokenList[tokenAddress].symbol,\n            tokenList[tokenAddress].decimals,\n          );\n        }),\n      );\n    }\n  }\n\n  /**\n   * Restart token detection polling period and call detectNewTokens\n   * in case of address change or user session initialization.\n   *\n   */\n  restartTokenDetection() {\n    if (!(this.isActive && this.selectedAddress)) {\n      return;\n    }\n    this.detectNewTokens();\n    this.interval = DEFAULT_INTERVAL;\n  }\n\n  /* eslint-disable accessor-pairs */\n  /**\n   * @type {number}\n   */\n  set interval(interval) {\n    this._handle && clearInterval(this._handle);\n    if (!interval) {\n      return;\n    }\n    this._handle = setInterval(() => {\n      this.detectNewTokens();\n    }, interval);\n  }\n\n  /**\n   * @type {Object}\n   */\n  set network(network) {\n    if (!network) {\n      return;\n    }\n    this._network = network;\n    this.web3 = new Web3(network._provider);\n  }\n\n  /**\n   * In setter when isUnlocked is updated to true, detectNewTokens and restart polling\n   *\n   * @type {Object}\n   */\n  set keyringMemStore(keyringMemStore) {\n    if (!keyringMemStore) {\n      return;\n    }\n    this._keyringMemStore = keyringMemStore;\n    this._keyringMemStore.subscribe(({ isUnlocked }) => {\n      if (this.isUnlocked !== isUnlocked) {\n        this.isUnlocked = isUnlocked;\n        if (isUnlocked) {\n          this.restartTokenDetection();\n        }\n      }\n    });\n  }\n\n  /**\n   * @type {Object}\n   */\n  set tokenList(tokenList) {\n    if (!tokenList) {\n      return;\n    }\n    this._tokenList = tokenList;\n  }\n\n  /**\n   * Internal isActive state\n   *\n   * @type {Object}\n   */\n  get isActive() {\n    return this.isOpen && this.isUnlocked;\n  }\n  /* eslint-enable accessor-pairs */\n}\n","import { ObservableStore } from '@metamask/obs-store';\n\n/**\n * @typedef {Object} CachedBalancesOptions\n * @property {Object} accountTracker An {@code AccountTracker} reference\n * @property {Function} getCurrentChainId A function to get the current chain id\n * @property {Object} initState The initial controller state\n */\n\n/**\n * Background controller responsible for maintaining\n * a cache of account balances in local storage\n */\nexport default class CachedBalancesController {\n  /**\n   * Creates a new controller instance\n   *\n   * @param {CachedBalancesOptions} [opts] - Controller configuration parameters\n   */\n  constructor(opts = {}) {\n    const { accountTracker, getCurrentChainId } = opts;\n\n    this.accountTracker = accountTracker;\n    this.getCurrentChainId = getCurrentChainId;\n\n    const initState = { cachedBalances: {}, ...opts.initState };\n    this.store = new ObservableStore(initState);\n\n    this._registerUpdates();\n  }\n\n  /**\n   * Updates the cachedBalances property for the current chain. Cached balances will be updated to those in the passed accounts\n   * if balances in the passed accounts are truthy.\n   *\n   * @param {Object} obj - The the recently updated accounts object for the current chain\n   * @param obj.accounts\n   * @returns {Promise<void>}\n   */\n  async updateCachedBalances({ accounts }) {\n    const chainId = this.getCurrentChainId();\n    const balancesToCache = await this._generateBalancesToCache(\n      accounts,\n      chainId,\n    );\n    this.store.updateState({\n      cachedBalances: balancesToCache,\n    });\n  }\n\n  _generateBalancesToCache(newAccounts, chainId) {\n    const { cachedBalances } = this.store.getState();\n    const currentChainBalancesToCache = { ...cachedBalances[chainId] };\n\n    Object.keys(newAccounts).forEach((accountID) => {\n      const account = newAccounts[accountID];\n\n      if (account.balance) {\n        currentChainBalancesToCache[accountID] = account.balance;\n      }\n    });\n    const balancesToCache = {\n      ...cachedBalances,\n      [chainId]: currentChainBalancesToCache,\n    };\n\n    return balancesToCache;\n  }\n\n  /**\n   * Removes cachedBalances\n   */\n\n  clearCachedBalances() {\n    this.store.updateState({ cachedBalances: {} });\n  }\n\n  /**\n   * Sets up listeners and subscriptions which should trigger an update of cached balances. These updates will\n   * happen when the current account changes. Which happens on block updates, as well as on network and account\n   * selections.\n   *\n   * @private\n   */\n  _registerUpdates() {\n    const update = this.updateCachedBalances.bind(this);\n    this.accountTracker.store.subscribe(update);\n  }\n}\n","import log from 'loglevel';\n\n/**\n * Returns a middleware that logs RPC activity\n *\n * @param {{ origin: string }} opts - The middleware options\n * @returns {Function}\n */\nexport default function createLoggerMiddleware(opts) {\n  return function loggerMiddleware(\n    /** @type {any} */ req,\n    /** @type {any} */ res,\n    /** @type {Function} */ next,\n  ) {\n    next((/** @type {Function} */ cb) => {\n      if (res.error) {\n        log.error('Error in RPC response:\\n', res);\n      }\n      if (req.isMetamaskInternal) {\n        return;\n      }\n      log.info(`RPC (${opts.origin}):`, req, '->', res);\n      cb();\n    });\n  };\n}\n","import { merge, omit, omitBy } from 'lodash';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { bufferToHex, keccak } from 'ethereumjs-util';\nimport { generateUUID } from 'pubnub';\nimport { ENVIRONMENT_TYPE_BACKGROUND } from '../../../shared/constants/app';\nimport {\n  METAMETRICS_ANONYMOUS_ID,\n  METAMETRICS_BACKGROUND_PAGE_OBJECT,\n} from '../../../shared/constants/metametrics';\nimport { SECOND } from '../../../shared/constants/time';\n\nconst defaultCaptureException = (err) => {\n  // throw error on clean stack so its captured by platform integrations (eg sentry)\n  // but does not interrupt the call stack\n  setTimeout(() => {\n    throw err;\n  });\n};\n\nconst exceptionsToFilter = {\n  [`You must pass either an \"anonymousId\" or a \"userId\".`]: true,\n};\n\n/**\n * @typedef {import('../../../shared/constants/metametrics').MetaMetricsContext} MetaMetricsContext\n * @typedef {import('../../../shared/constants/metametrics').MetaMetricsEventPayload} MetaMetricsEventPayload\n * @typedef {import('../../../shared/constants/metametrics').MetaMetricsEventOptions} MetaMetricsEventOptions\n * @typedef {import('../../../shared/constants/metametrics').SegmentEventPayload} SegmentEventPayload\n * @typedef {import('../../../shared/constants/metametrics').SegmentInterface} SegmentInterface\n * @typedef {import('../../../shared/constants/metametrics').MetaMetricsPagePayload} MetaMetricsPagePayload\n * @typedef {import('../../../shared/constants/metametrics').MetaMetricsPageOptions} MetaMetricsPageOptions\n * @typedef {import('../../../shared/constants/metametrics').MetaMetricsEventFragment} MetaMetricsEventFragment\n */\n\n/**\n * @typedef {Object} MetaMetricsControllerState\n * @property {string} [metaMetricsId] - The user's metaMetricsId that will be\n *  attached to all non-anonymized event payloads\n * @property {boolean} [participateInMetaMetrics] - The user's preference for\n *  participating in the MetaMetrics analytics program. This setting controls\n *  whether or not events are tracked\n * @property {{[string]: MetaMetricsEventFragment}} [fragments] - Object keyed\n *  by UUID with stored fragments as values.\n */\n\nexport default class MetaMetricsController {\n  /**\n   * @param {object} options\n   * @param {Object} options.segment - an instance of analytics-node for tracking\n   *  events that conform to the new MetaMetrics tracking plan.\n   * @param {Object} options.preferencesStore - The preferences controller store, used\n   *  to access and subscribe to preferences that will be attached to events\n   * @param {Function} options.onNetworkDidChange - Used to attach a listener to the\n   *  networkDidChange event emitted by the networkController\n   * @param {Function} options.getCurrentChainId - Gets the current chain id from the\n   *  network controller\n   * @param {Function} options.getNetworkIdentifier - Gets the current network\n   *  identifier from the network controller\n   * @param {string} options.version - The version of the extension\n   * @param {string} options.environment - The environment the extension is running in\n   * @param {MetaMetricsControllerState} options.initState - State to initialized with\n   * @param options.captureException\n   */\n  constructor({\n    segment,\n    preferencesStore,\n    onNetworkDidChange,\n    getCurrentChainId,\n    getNetworkIdentifier,\n    version,\n    environment,\n    initState,\n    captureException = defaultCaptureException,\n  }) {\n    this._captureException = (err) => {\n      // This is a temporary measure. Currently there are errors flooding sentry due to a problem in how we are tracking anonymousId\n      // We intend on removing this as soon as we understand how to correctly solve that problem.\n      if (!exceptionsToFilter[err.message]) {\n        captureException(err);\n      }\n    };\n    const prefState = preferencesStore.getState();\n    this.chainId = getCurrentChainId();\n    this.network = getNetworkIdentifier();\n    this.locale = prefState.currentLocale.replace('_', '-');\n    this.version =\n      environment === 'production' ? version : `${version}-${environment}`;\n\n    const abandonedFragments = omitBy(initState?.fragments, 'persist');\n\n    this.store = new ObservableStore({\n      participateInMetaMetrics: null,\n      metaMetricsId: null,\n      ...initState,\n      fragments: {\n        ...initState?.fragments,\n      },\n    });\n\n    preferencesStore.subscribe(({ currentLocale }) => {\n      this.locale = currentLocale.replace('_', '-');\n    });\n\n    onNetworkDidChange(() => {\n      this.chainId = getCurrentChainId();\n      this.network = getNetworkIdentifier();\n    });\n    this.segment = segment;\n\n    // Track abandoned fragments that weren't properly cleaned up.\n    // Abandoned fragments are those that were stored in persistent memory\n    // and are available at controller instance creation, but do not have the\n    // 'persist' flag set. This means anytime the extension is unlocked, any\n    // fragments that are not marked as persistent will be purged and the\n    // failure event will be emitted.\n    Object.values(abandonedFragments).forEach((fragment) => {\n      this.finalizeEventFragment(fragment.id, { abandoned: true });\n    });\n\n    // Close out event fragments that were created but not progressed. An\n    // interval is used to routinely check if a fragment has not been updated\n    // within the fragment's timeout window. When creating a new event fragment\n    // a timeout can be specified that will cause an abandoned event to be\n    // tracked if the event isn't progressed within that amount of time.\n    setInterval(() => {\n      Object.values(this.store.getState().fragments).forEach((fragment) => {\n        if (\n          fragment.timeout &&\n          Date.now() - fragment.lastUpdated / 1000 > fragment.timeout\n        ) {\n          this.finalizeEventFragment(fragment.id, { abandoned: true });\n        }\n      });\n    }, SECOND * 30);\n  }\n\n  generateMetaMetricsId() {\n    return bufferToHex(\n      keccak(\n        Buffer.from(\n          String(Date.now()) +\n            String(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)),\n        ),\n      ),\n    );\n  }\n\n  /**\n   * Create an event fragment in state and returns the event fragment object.\n   *\n   * @param {MetaMetricsEventFragment} options - Fragment settings and properties\n   *  to initiate the fragment with.\n   * @returns {MetaMetricsEventFragment}\n   */\n  createEventFragment(options) {\n    if (!options.successEvent || !options.category) {\n      throw new Error(\n        `Must specify success event and category. Success event was: ${\n          options.event\n        }. Category was: ${options.category}. Payload keys were: ${Object.keys(\n          options,\n        )}. ${\n          typeof options.properties === 'object'\n            ? `Payload property keys were: ${Object.keys(options.properties)}`\n            : ''\n        }`,\n      );\n    }\n    const { fragments } = this.store.getState();\n\n    const id = options.uniqueIdentifier ?? generateUUID();\n    const fragment = {\n      id,\n      ...options,\n      lastUpdated: Date.now(),\n    };\n    this.store.updateState({\n      fragments: {\n        ...fragments,\n        [id]: fragment,\n      },\n    });\n\n    if (options.initialEvent) {\n      this.trackEvent({\n        event: fragment.initialEvent,\n        category: fragment.category,\n        properties: fragment.properties,\n        sensitiveProperties: fragment.sensitiveProperties,\n        page: fragment.page,\n        referrer: fragment.referrer,\n        revenue: fragment.revenue,\n        value: fragment.value,\n        currency: fragment.currency,\n        environmentType: fragment.environmentType,\n      });\n    }\n\n    return fragment;\n  }\n\n  /**\n   * Returns the fragment stored in memory with provided id or undefined if it\n   * does not exist.\n   *\n   * @param {string} id - id of fragment to retrieve\n   * @returns {[MetaMetricsEventFragment]}\n   */\n  getEventFragmentById(id) {\n    const { fragments } = this.store.getState();\n\n    const fragment = fragments[id];\n\n    return fragment;\n  }\n\n  /**\n   * Updates an event fragment in state\n   *\n   * @param {string} id - The fragment id to update\n   * @param {MetaMetricsEventFragment} payload - Fragment settings and\n   *  properties to initiate the fragment with.\n   */\n  updateEventFragment(id, payload) {\n    const { fragments } = this.store.getState();\n\n    const fragment = fragments[id];\n\n    if (!fragment) {\n      throw new Error(`Event fragment with id ${id} does not exist.`);\n    }\n\n    this.store.updateState({\n      fragments: {\n        ...fragments,\n        [id]: merge(fragments[id], {\n          ...payload,\n          lastUpdated: Date.now(),\n        }),\n      },\n    });\n  }\n\n  /**\n   * Finalizes a fragment, tracking either a success event or failure Event\n   * and then removes the fragment from state.\n   *\n   * @param {string} id - UUID of the event fragment to be closed\n   * @param {object} options\n   * @param {boolean} [options.abandoned] - if true track the failure\n   *  event instead of the success event\n   * @param {MetaMetricsContext.page} [options.page] - page the final event\n   *  occurred on. This will override whatever is set on the fragment\n   * @param {MetaMetricsContext.referrer} [options.referrer] - Dapp that\n   *  originated the fragment. This is for fallback only, the fragment referrer\n   *  property will take precedence.\n   */\n  finalizeEventFragment(id, { abandoned = false, page, referrer } = {}) {\n    const fragment = this.store.getState().fragments[id];\n    if (!fragment) {\n      throw new Error(`Funnel with id ${id} does not exist.`);\n    }\n\n    const eventName = abandoned ? fragment.failureEvent : fragment.successEvent;\n\n    this.trackEvent({\n      event: eventName,\n      category: fragment.category,\n      properties: fragment.properties,\n      sensitiveProperties: fragment.sensitiveProperties,\n      page: page ?? fragment.page,\n      referrer: fragment.referrer ?? referrer,\n      revenue: fragment.revenue,\n      value: fragment.value,\n      currency: fragment.currency,\n      environmentType: fragment.environmentType,\n    });\n    const { fragments } = this.store.getState();\n    delete fragments[id];\n    this.store.updateState({ fragments });\n  }\n\n  /**\n   * Setter for the `participateInMetaMetrics` property\n   *\n   * @param {boolean} participateInMetaMetrics - Whether or not the user wants\n   *  to participate in MetaMetrics\n   * @returns {string|null} the string of the new metametrics id, or null\n   *  if not set\n   */\n  setParticipateInMetaMetrics(participateInMetaMetrics) {\n    let { metaMetricsId } = this.state;\n    if (participateInMetaMetrics && !metaMetricsId) {\n      metaMetricsId = this.generateMetaMetricsId();\n    } else if (participateInMetaMetrics === false) {\n      metaMetricsId = null;\n    }\n    this.store.updateState({ participateInMetaMetrics, metaMetricsId });\n    return metaMetricsId;\n  }\n\n  get state() {\n    return this.store.getState();\n  }\n\n  /**\n   * Build the context object to attach to page and track events.\n   *\n   * @private\n   * @param {Pick<MetaMetricsContext, 'referrer'>} [referrer] - dapp origin that initialized\n   *  the notification window.\n   * @param {Pick<MetaMetricsContext, 'page'>} [page] - page object describing the current\n   *  view of the extension. Defaults to the background-process object.\n   * @returns {MetaMetricsContext}\n   */\n  _buildContext(referrer, page = METAMETRICS_BACKGROUND_PAGE_OBJECT) {\n    return {\n      app: {\n        name: 'MetaMask Extension',\n        version: this.version,\n      },\n      userAgent: window.navigator.userAgent,\n      page,\n      referrer,\n    };\n  }\n\n  /**\n   * Build's the event payload, processing all fields into a format that can be\n   * fed to Segment's track method\n   *\n   * @private\n   * @param {\n   *  Omit<MetaMetricsEventPayload, 'sensitiveProperties'>\n   * } rawPayload - raw payload provided to trackEvent\n   * @returns {SegmentEventPayload} formatted event payload for segment\n   */\n  _buildEventPayload(rawPayload) {\n    const {\n      event,\n      properties,\n      revenue,\n      value,\n      currency,\n      category,\n      page,\n      referrer,\n      environmentType = ENVIRONMENT_TYPE_BACKGROUND,\n    } = rawPayload;\n    return {\n      event,\n      properties: {\n        // These values are omitted from properties because they have special meaning\n        // in segment. https://segment.com/docs/connections/spec/track/#properties.\n        // to avoid accidentally using these inappropriately, you must add them as top\n        // level properties on the event payload. We also exclude locale to prevent consumers\n        // from overwriting this context level property. We track it as a property\n        // because not all destinations map locale from context.\n        ...omit(properties, ['revenue', 'locale', 'currency', 'value']),\n        revenue,\n        value,\n        currency,\n        category,\n        network: properties?.network ?? this.network,\n        locale: this.locale,\n        chain_id: properties?.chain_id ?? this.chainId,\n        environment_type: environmentType,\n      },\n      context: this._buildContext(referrer, page),\n    };\n  }\n\n  /**\n   * Perform validation on the payload and update the id type to use before\n   * sending to Segment. Also examines the options to route and handle the\n   * event appropriately.\n   *\n   * @private\n   * @param {SegmentEventPayload} payload - properties to attach to event\n   * @param {MetaMetricsEventOptions} [options] - options for routing and\n   *  handling the event\n   * @returns {Promise<void>}\n   */\n  _track(payload, options) {\n    const {\n      isOptIn,\n      metaMetricsId: metaMetricsIdOverride,\n      matomoEvent,\n      flushImmediately,\n    } = options || {};\n    let idType = 'userId';\n    let idValue = this.state.metaMetricsId;\n    let excludeMetaMetricsId = options?.excludeMetaMetricsId ?? false;\n    // This is carried over from the old implementation, and will likely need\n    // to be updated to work with the new tracking plan. I think we should use\n    // a config setting for this instead of trying to match the event name\n    const isSendFlow = Boolean(payload.event.match(/^send|^confirm/iu));\n    if (isSendFlow) {\n      excludeMetaMetricsId = true;\n    }\n    // If we are tracking sensitive data we will always use the anonymousId\n    // property as well as our METAMETRICS_ANONYMOUS_ID. This prevents us from\n    // associating potentially identifiable information with a specific id.\n    // During the opt in flow we will track all events, but do so with the\n    // anonymous id. The one exception to that rule is after the user opts in\n    // to MetaMetrics. When that happens we receive back the user's new\n    // MetaMetrics id before it is fully persisted to state. To avoid a race\n    // condition we explicitly pass the new id to the track method. In that\n    // case we will track the opt in event to the user's id. In all other cases\n    // we use the metaMetricsId from state.\n    if (excludeMetaMetricsId || (isOptIn && !metaMetricsIdOverride)) {\n      idType = 'anonymousId';\n      idValue = METAMETRICS_ANONYMOUS_ID;\n    } else if (isOptIn && metaMetricsIdOverride) {\n      idValue = metaMetricsIdOverride;\n    }\n    payload[idType] = idValue;\n\n    // If this is an event on the old matomo schema, add a key to the payload\n    // to designate it as such\n    if (matomoEvent === true) {\n      payload.properties.legacy_event = true;\n    }\n\n    // Promises will only resolve when the event is sent to segment. For any\n    // event that relies on this promise being fulfilled before performing UI\n    // updates, or otherwise delaying user interaction, supply the\n    // 'flushImmediately' flag to the trackEvent method.\n    return new Promise((resolve, reject) => {\n      const callback = (err) => {\n        if (err) {\n          // The error that segment gives us has some manipulation done to it\n          // that seemingly breaks with lockdown enabled. Creating a new error\n          // here prevents the system from freezing when the network request to\n          // segment fails for any reason.\n          const safeError = new Error(err.message);\n          safeError.stack = err.stack;\n          return reject(safeError);\n        }\n        return resolve();\n      };\n\n      this.segment.track(payload, callback);\n      if (flushImmediately) {\n        this.segment.flush();\n      }\n    });\n  }\n\n  /**\n   * track a page view with Segment\n   *\n   * @param {MetaMetricsPagePayload} payload - details of the page viewed\n   * @param {MetaMetricsPageOptions} [options] - options for handling the page\n   *  view\n   */\n  trackPage({ name, params, environmentType, page, referrer }, options) {\n    try {\n      if (this.state.participateInMetaMetrics === false) {\n        return;\n      }\n\n      if (\n        this.state.participateInMetaMetrics === null &&\n        !options?.isOptInPath\n      ) {\n        return;\n      }\n      const { metaMetricsId } = this.state;\n      const idTrait = metaMetricsId ? 'userId' : 'anonymousId';\n      const idValue = metaMetricsId ?? METAMETRICS_ANONYMOUS_ID;\n      this.segment.page({\n        [idTrait]: idValue,\n        name,\n        properties: {\n          params,\n          locale: this.locale,\n          network: this.network,\n          chain_id: this.chainId,\n          environment_type: environmentType,\n        },\n        context: this._buildContext(referrer, page),\n      });\n    } catch (err) {\n      this._captureException(err);\n    }\n  }\n\n  /**\n   * submits a metametrics event, not waiting for it to complete or allowing its error to bubble up\n   *\n   * @param {MetaMetricsEventPayload} payload - details of the event\n   * @param {MetaMetricsEventOptions} [options] - options for handling/routing the event\n   */\n  trackEvent(payload, options) {\n    // validation is not caught and handled\n    this.validatePayload(payload);\n    this.submitEvent(payload, options).catch((err) =>\n      this._captureException(err),\n    );\n  }\n\n  /**\n   * submits (or queues for submission) a metametrics event, performing necessary payload manipulation and\n   * routing the event to the appropriate segment source. Will split events\n   * with sensitiveProperties into two events, tracking the sensitiveProperties\n   * with the anonymousId only.\n   *\n   * @param {MetaMetricsEventPayload} payload - details of the event\n   * @param {MetaMetricsEventOptions} [options] - options for handling/routing the event\n   * @returns {Promise<void>}\n   */\n  async submitEvent(payload, options) {\n    this.validatePayload(payload);\n\n    if (!this.state.participateInMetaMetrics && !options?.isOptIn) {\n      return;\n    }\n\n    // We might track multiple events if sensitiveProperties is included, this array will hold\n    // the promises returned from this._track.\n    const events = [];\n\n    if (payload.sensitiveProperties) {\n      // sensitiveProperties will only be tracked using the anonymousId property and generic id\n      // If the event options already specify to exclude the metaMetricsId we throw an error as\n      // a signal to the developer that the event was implemented incorrectly\n      if (options?.excludeMetaMetricsId === true) {\n        throw new Error(\n          'sensitiveProperties was specified in an event payload that also set the excludeMetaMetricsId flag',\n        );\n      }\n\n      const combinedProperties = merge(\n        payload.sensitiveProperties,\n        payload.properties,\n      );\n\n      events.push(\n        this._track(\n          this._buildEventPayload({\n            ...payload,\n            properties: combinedProperties,\n          }),\n          { ...options, excludeMetaMetricsId: true },\n        ),\n      );\n    }\n\n    events.push(this._track(this._buildEventPayload(payload), options));\n\n    await Promise.all(events);\n  }\n\n  /**\n   * validates a metametrics event\n   *\n   * @param {MetaMetricsEventPayload} payload - details of the event\n   */\n  validatePayload(payload) {\n    // event and category are required fields for all payloads\n    if (!payload.event || !payload.category) {\n      throw new Error(\n        `Must specify event and category. Event was: ${\n          payload.event\n        }. Category was: ${payload.category}. Payload keys were: ${Object.keys(\n          payload,\n        )}. ${\n          typeof payload.properties === 'object'\n            ? `Payload property keys were: ${Object.keys(payload.properties)}`\n            : ''\n        }`,\n      );\n    }\n  }\n}\n","import EventEmitter from 'events';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { bufferToHex, stripHexPrefix } from 'ethereumjs-util';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport { MESSAGE_TYPE } from '../../../shared/constants/app';\nimport { METAMASK_CONTROLLER_EVENTS } from '../metamask-controller';\nimport createId from '../../../shared/modules/random-id';\nimport { addHexPrefix } from './util';\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\n\n/**\n * Represents, and contains data about, an 'eth_decrypt' type decryption request. These are created when a\n * decryption for an eth_decrypt call is requested.\n *\n * @typedef {Object} DecryptMessage\n * @property {number} id An id to track and identify the message object\n * @property {Object} msgParams The parameters to pass to the decryptMessage method once the decryption request is\n * approved.\n * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.\n * @property {string} msgParams.data A hex string conversion of the raw buffer data of the decryption request\n * @property {number} time The epoch time at which the this message was created\n * @property {string} status Indicates whether the decryption request is 'unapproved', 'approved', 'decrypted' or 'rejected'\n * @property {string} type The json-prc decryption method for which a decryption request has been made. A 'Message' will\n * always have a 'eth_decrypt' type.\n */\n\nexport default class DecryptMessageManager extends EventEmitter {\n  /**\n   * Controller in charge of managing - storing, adding, removing, updating - DecryptMessage.\n   *\n   * @param {object} opts - Controller options\n   * @param {Function} opts.metricEvent - A function for emitting a metric event.\n   */\n  constructor(opts) {\n    super();\n    this.memStore = new ObservableStore({\n      unapprovedDecryptMsgs: {},\n      unapprovedDecryptMsgCount: 0,\n    });\n    this.messages = [];\n    this.metricsEvent = opts.metricsEvent;\n  }\n\n  /**\n   * A getter for the number of 'unapproved' DecryptMessages in this.messages\n   *\n   * @returns {number} The number of 'unapproved' DecryptMessages in this.messages\n   */\n  get unapprovedDecryptMsgCount() {\n    return Object.keys(this.getUnapprovedMsgs()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' DecryptMessages in this.messages\n   *\n   * @returns {Object} An index of DecryptMessage ids to DecryptMessages, for all 'unapproved' DecryptMessages in\n   * this.messages\n   */\n  getUnapprovedMsgs() {\n    return this.messages\n      .filter((msg) => msg.status === 'unapproved')\n      .reduce((result, msg) => {\n        result[msg.id] = msg;\n        return result;\n      }, {});\n  }\n\n  /**\n   * Creates a new DecryptMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new DecryptMessage to this.messages, and to save the unapproved DecryptMessages from that list to\n   * this.memStore.\n   *\n   * @param {Object} msgParams - The params for the eth_decrypt call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @returns {Promise<Buffer>} The raw decrypted message contents\n   */\n  addUnapprovedMessageAsync(msgParams, req) {\n    return new Promise((resolve, reject) => {\n      if (!msgParams.from) {\n        reject(new Error('MetaMask Decryption: from field is required.'));\n        return;\n      }\n      const msgId = this.addUnapprovedMessage(msgParams, req);\n      this.once(`${msgId}:finished`, (data) => {\n        switch (data.status) {\n          case 'decrypted':\n            resolve(data.rawData);\n            return;\n          case 'rejected':\n            reject(\n              ethErrors.provider.userRejectedRequest(\n                'MetaMask Decryption: User denied message decryption.',\n              ),\n            );\n            return;\n          case 'errored':\n            reject(new Error('This message cannot be decrypted'));\n            return;\n          default:\n            reject(\n              new Error(\n                `MetaMask Decryption: Unknown problem: ${JSON.stringify(\n                  msgParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new DecryptMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new DecryptMessage to this.messages, and to save the unapproved DecryptMessages from that list to\n   * this.memStore.\n   *\n   * @param {Object} msgParams - The params for the eth_decryptMsg call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @returns {number} The id of the newly created DecryptMessage.\n   */\n  addUnapprovedMessage(msgParams, req) {\n    log.debug(\n      `DecryptMessageManager addUnapprovedMessage: ${JSON.stringify(\n        msgParams,\n      )}`,\n    );\n    // add origin from request\n    if (req) {\n      msgParams.origin = req.origin;\n    }\n    msgParams.data = this.normalizeMsgData(msgParams.data);\n    // create txData obj with parameters and meta data\n    const time = new Date().getTime();\n    const msgId = createId();\n    const msgData = {\n      id: msgId,\n      msgParams,\n      time,\n      status: 'unapproved',\n      type: MESSAGE_TYPE.ETH_DECRYPT,\n    };\n    this.addMsg(msgData);\n\n    // signal update\n    this.emit('update');\n    return msgId;\n  }\n\n  /**\n   * Adds a passed DecryptMessage to this.messages, and calls this._saveMsgList() to save the unapproved DecryptMessages from that\n   * list to this.memStore.\n   *\n   * @param {Message} msg - The DecryptMessage to add to this.messages\n   */\n  addMsg(msg) {\n    this.messages.push(msg);\n    this._saveMsgList();\n  }\n\n  /**\n   * Returns a specified DecryptMessage.\n   *\n   * @param {number} msgId - The id of the DecryptMessage to get\n   * @returns {DecryptMessage|undefined} The DecryptMessage with the id that matches the passed msgId, or undefined\n   * if no DecryptMessage has that id.\n   */\n  getMsg(msgId) {\n    return this.messages.find((msg) => msg.id === msgId);\n  }\n\n  /**\n   * Approves a DecryptMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise\n   * with the message params modified for proper decryption.\n   *\n   * @param {Object} msgParams - The msgParams to be used when eth_decryptMsg is called, plus data added by MetaMask.\n   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.\n   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.\n   */\n  approveMessage(msgParams) {\n    this.setMsgStatusApproved(msgParams.metamaskId);\n    return this.prepMsgForDecryption(msgParams);\n  }\n\n  /**\n   * Sets a DecryptMessage status to 'approved' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the DecryptMessage to approve.\n   */\n  setMsgStatusApproved(msgId) {\n    this._setMsgStatus(msgId, 'approved');\n  }\n\n  /**\n   * Sets a DecryptMessage status to 'decrypted' via a call to this._setMsgStatus and updates that DecryptMessage in\n   * this.messages by adding the raw decryption data of the decryption request to the DecryptMessage\n   *\n   * @param {number} msgId - The id of the DecryptMessage to decrypt.\n   * @param {buffer} rawData - The raw data of the message request\n   */\n  setMsgStatusDecrypted(msgId, rawData) {\n    const msg = this.getMsg(msgId);\n    msg.rawData = rawData;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'decrypted');\n  }\n\n  /**\n   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams\n   *\n   * @param {Object} msgParams - The msgParams to modify\n   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed\n   */\n  prepMsgForDecryption(msgParams) {\n    delete msgParams.metamaskId;\n    return Promise.resolve(msgParams);\n  }\n\n  /**\n   * Sets a DecryptMessage status to 'rejected' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the DecryptMessage to reject.\n   * @param reason\n   */\n  rejectMsg(msgId, reason = undefined) {\n    if (reason) {\n      this.metricsEvent({\n        event: reason,\n        category: 'Messages',\n        properties: {\n          action: 'Decrypt Message Request',\n        },\n      });\n    }\n    this._setMsgStatus(msgId, 'rejected');\n  }\n\n  /**\n   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the TypedMessage to error\n   * @param error\n   */\n  errorMessage(msgId, error) {\n    const msg = this.getMsg(msgId);\n    msg.error = error;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'errored');\n  }\n\n  /**\n   * Clears all unapproved messages from memory.\n   */\n  clearUnapproved() {\n    this.messages = this.messages.filter((msg) => msg.status !== 'unapproved');\n    this._saveMsgList();\n  }\n\n  /**\n   * Updates the status of a DecryptMessage in this.messages via a call to this._updateMsg\n   *\n   * @private\n   * @param {number} msgId - The id of the DecryptMessage to update.\n   * @param {string} status - The new status of the DecryptMessage.\n   * @throws A 'DecryptMessageManager - DecryptMessage not found for id: \"${msgId}\".' if there is no DecryptMessage\n   * in this.messages with an id equal to the passed msgId\n   * @fires An event with a name equal to `${msgId}:${status}`. The DecryptMessage is also fired.\n   * @fires If status is 'rejected' or 'decrypted', an event with a name equal to `${msgId}:finished` is fired along\n   * with the DecryptMessage\n   */\n  _setMsgStatus(msgId, status) {\n    const msg = this.getMsg(msgId);\n    if (!msg) {\n      throw new Error(\n        `DecryptMessageManager - Message not found for id: \"${msgId}\".`,\n      );\n    }\n    msg.status = status;\n    this._updateMsg(msg);\n    this.emit(`${msgId}:${status}`, msg);\n    if (\n      status === 'rejected' ||\n      status === 'decrypted' ||\n      status === 'errored'\n    ) {\n      this.emit(`${msgId}:finished`, msg);\n    }\n  }\n\n  /**\n   * Sets a DecryptMessage in this.messages to the passed DecryptMessage if the ids are equal. Then saves the\n   * unapprovedDecryptMsgs index to storage via this._saveMsgList\n   *\n   * @private\n   * @param {DecryptMessage} msg - A DecryptMessage that will replace an existing DecryptMessage (with the same\n   * id) in this.messages\n   */\n  _updateMsg(msg) {\n    const index = this.messages.findIndex((message) => message.id === msg.id);\n    if (index !== -1) {\n      this.messages[index] = msg;\n    }\n    this._saveMsgList();\n  }\n\n  /**\n   * Saves the unapproved DecryptMessages, and their count, to this.memStore\n   *\n   * @private\n   * @fires 'updateBadge'\n   */\n  _saveMsgList() {\n    const unapprovedDecryptMsgs = this.getUnapprovedMsgs();\n    const unapprovedDecryptMsgCount = Object.keys(unapprovedDecryptMsgs).length;\n    this.memStore.updateState({\n      unapprovedDecryptMsgs,\n      unapprovedDecryptMsgCount,\n    });\n    this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);\n  }\n\n  /**\n   * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.\n   *\n   * @param {any} data - The buffer data to convert to a hex\n   * @returns {string} A hex string conversion of the buffer data\n   */\n  normalizeMsgData(data) {\n    try {\n      const stripped = stripHexPrefix(data);\n      if (stripped.match(hexRe)) {\n        return addHexPrefix(stripped);\n      }\n    } catch (e) {\n      log.debug(`Message was not hex encoded, interpreting as utf8.`);\n    }\n\n    return bufferToHex(Buffer.from(data, 'utf8'));\n  }\n}\n","import { ObservableStore } from '@metamask/obs-store';\nimport {\n  TOGGLEABLE_ALERT_TYPES,\n  WEB3_SHIM_USAGE_ALERT_STATES,\n} from '../../../shared/constants/alerts';\n\n/**\n * @typedef {Object} AlertControllerInitState\n * @property {Object} alertEnabledness - A map of alerts IDs to booleans, where\n * `true` indicates that the alert is enabled and shown, and `false` the opposite.\n * @property {Object} unconnectedAccountAlertShownOrigins - A map of origin\n * strings to booleans indicating whether the \"switch to connected\" alert has\n * been shown (`true`) or otherwise (`false`).\n */\n\n/**\n * @typedef {Object} AlertControllerOptions\n * @property {AlertControllerInitState} initState - The initial controller state\n */\n\nconst defaultState = {\n  alertEnabledness: TOGGLEABLE_ALERT_TYPES.reduce(\n    (alertEnabledness, alertType) => {\n      alertEnabledness[alertType] = true;\n      return alertEnabledness;\n    },\n    {},\n  ),\n  unconnectedAccountAlertShownOrigins: {},\n  web3ShimUsageOrigins: {},\n};\n\n/**\n * Controller responsible for maintaining alert-related state.\n */\nexport default class AlertController {\n  /**\n   * @param {AlertControllerOptions} [opts] - Controller configuration parameters\n   */\n  constructor(opts = {}) {\n    const { initState = {}, preferencesStore } = opts;\n    const state = {\n      ...defaultState,\n      alertEnabledness: {\n        ...defaultState.alertEnabledness,\n        ...initState.alertEnabledness,\n      },\n    };\n\n    this.store = new ObservableStore(state);\n\n    this.selectedAddress = preferencesStore.getState().selectedAddress;\n\n    preferencesStore.subscribe(({ selectedAddress }) => {\n      const currentState = this.store.getState();\n      if (\n        currentState.unconnectedAccountAlertShownOrigins &&\n        this.selectedAddress !== selectedAddress\n      ) {\n        this.selectedAddress = selectedAddress;\n        this.store.updateState({ unconnectedAccountAlertShownOrigins: {} });\n      }\n    });\n  }\n\n  setAlertEnabledness(alertId, enabledness) {\n    let { alertEnabledness } = this.store.getState();\n    alertEnabledness = { ...alertEnabledness };\n    alertEnabledness[alertId] = enabledness;\n    this.store.updateState({ alertEnabledness });\n  }\n\n  /**\n   * Sets the \"switch to connected\" alert as shown for the given origin\n   *\n   * @param {string} origin - The origin the alert has been shown for\n   */\n  setUnconnectedAccountAlertShown(origin) {\n    let { unconnectedAccountAlertShownOrigins } = this.store.getState();\n    unconnectedAccountAlertShownOrigins = {\n      ...unconnectedAccountAlertShownOrigins,\n    };\n    unconnectedAccountAlertShownOrigins[origin] = true;\n    this.store.updateState({ unconnectedAccountAlertShownOrigins });\n  }\n\n  /**\n   * Gets the web3 shim usage state for the given origin.\n   *\n   * @param {string} origin - The origin to get the web3 shim usage state for.\n   * @returns {undefined | 1 | 2} The web3 shim usage state for the given\n   * origin, or undefined.\n   */\n  getWeb3ShimUsageState(origin) {\n    return this.store.getState().web3ShimUsageOrigins[origin];\n  }\n\n  /**\n   * Sets the web3 shim usage state for the given origin to RECORDED.\n   *\n   * @param {string} origin - The origin the that used the web3 shim.\n   */\n  setWeb3ShimUsageRecorded(origin) {\n    this._setWeb3ShimUsageState(origin, WEB3_SHIM_USAGE_ALERT_STATES.RECORDED);\n  }\n\n  /**\n   * Sets the web3 shim usage state for the given origin to DISMISSED.\n   *\n   * @param {string} origin - The origin that the web3 shim notification was\n   * dismissed for.\n   */\n  setWeb3ShimUsageAlertDismissed(origin) {\n    this._setWeb3ShimUsageState(origin, WEB3_SHIM_USAGE_ALERT_STATES.DISMISSED);\n  }\n\n  /**\n   * @private\n   * @param {string} origin - The origin to set the state for.\n   * @param {number} value - The state value to set.\n   */\n  _setWeb3ShimUsageState(origin, value) {\n    let { web3ShimUsageOrigins } = this.store.getState();\n    web3ShimUsageOrigins = {\n      ...web3ShimUsageOrigins,\n    };\n    web3ShimUsageOrigins[origin] = value;\n    this.store.updateState({ web3ShimUsageOrigins });\n  }\n}\n","import { ObservableStore } from '@metamask/obs-store';\nimport log from 'loglevel';\nimport BN from 'bn.js';\nimport createId from '../../../shared/modules/random-id';\nimport { bnToHex } from '../lib/util';\nimport getFetchWithTimeout from '../../../shared/modules/fetch-with-timeout';\n\nimport {\n  TRANSACTION_TYPES,\n  TRANSACTION_STATUSES,\n} from '../../../shared/constants/transaction';\nimport {\n  CHAIN_ID_TO_NETWORK_ID_MAP,\n  CHAIN_ID_TO_TYPE_MAP,\n  GOERLI_CHAIN_ID,\n  KOVAN_CHAIN_ID,\n  MAINNET_CHAIN_ID,\n  RINKEBY_CHAIN_ID,\n  ROPSTEN_CHAIN_ID,\n} from '../../../shared/constants/network';\nimport { SECOND } from '../../../shared/constants/time';\n\nconst fetchWithTimeout = getFetchWithTimeout(SECOND * 30);\n\n/**\n * @typedef {import('../../../shared/constants/transaction').TransactionMeta} TransactionMeta\n */\n\n/**\n * A transaction object in the format returned by the Etherscan API.\n *\n * Note that this is not an exhaustive type definiton; only the properties we use are defined\n *\n * @typedef {Object} EtherscanTransaction\n * @property {string} blockNumber - The number of the block this transaction was found in, in decimal\n * @property {string} from - The hex-prefixed address of the sender\n * @property {string} gas - The gas limit, in decimal GWEI\n * @property {string} [gasPrice] - The gas price, in decimal WEI\n * @property {string} [maxFeePerGas] - The maximum fee per gas, inclusive of tip, in decimal WEI\n * @property {string} [maxPriorityFeePerGas] - The maximum tip per gas in decimal WEI\n * @property {string} hash - The hex-prefixed transaction hash\n * @property {string} isError - Whether the transaction was confirmed or failed (0 for confirmed, 1 for failed)\n * @property {string} nonce - The transaction nonce, in decimal\n * @property {string} timeStamp - The timestamp for the transaction, in seconds\n * @property {string} to - The hex-prefixed address of the recipient\n * @property {string} value - The amount of ETH sent in this transaction, in decimal WEI\n */\n\n/**\n * This controller is responsible for retrieving incoming transactions. Etherscan is polled once every block to check\n * for new incoming transactions for the current selected account on the current network\n *\n * Note that only the built-in Infura networks are supported (i.e. anything in `INFURA_PROVIDER_TYPES`). We will not\n * attempt to retrieve incoming transactions on any custom RPC endpoints.\n */\nconst etherscanSupportedNetworks = [\n  GOERLI_CHAIN_ID,\n  KOVAN_CHAIN_ID,\n  MAINNET_CHAIN_ID,\n  RINKEBY_CHAIN_ID,\n  ROPSTEN_CHAIN_ID,\n];\n\nexport default class IncomingTransactionsController {\n  constructor(opts = {}) {\n    const {\n      blockTracker,\n      onNetworkDidChange,\n      getCurrentChainId,\n      preferencesController,\n    } = opts;\n    this.blockTracker = blockTracker;\n    this.getCurrentChainId = getCurrentChainId;\n    this.preferencesController = preferencesController;\n\n    this._onLatestBlock = async (newBlockNumberHex) => {\n      const selectedAddress = this.preferencesController.getSelectedAddress();\n      const newBlockNumberDec = parseInt(newBlockNumberHex, 16);\n      await this._update(selectedAddress, newBlockNumberDec);\n    };\n\n    const initState = {\n      incomingTransactions: {},\n      incomingTxLastFetchedBlockByChainId: {\n        [GOERLI_CHAIN_ID]: null,\n        [KOVAN_CHAIN_ID]: null,\n        [MAINNET_CHAIN_ID]: null,\n        [RINKEBY_CHAIN_ID]: null,\n        [ROPSTEN_CHAIN_ID]: null,\n      },\n      ...opts.initState,\n    };\n    this.store = new ObservableStore(initState);\n\n    this.preferencesController.store.subscribe(\n      previousValueComparator((prevState, currState) => {\n        const {\n          featureFlags: {\n            showIncomingTransactions: prevShowIncomingTransactions,\n          } = {},\n        } = prevState;\n        const {\n          featureFlags: {\n            showIncomingTransactions: currShowIncomingTransactions,\n          } = {},\n        } = currState;\n\n        if (currShowIncomingTransactions === prevShowIncomingTransactions) {\n          return;\n        }\n\n        if (prevShowIncomingTransactions && !currShowIncomingTransactions) {\n          this.stop();\n          return;\n        }\n\n        this.start();\n      }, this.preferencesController.store.getState()),\n    );\n\n    this.preferencesController.store.subscribe(\n      previousValueComparator(async (prevState, currState) => {\n        const { selectedAddress: prevSelectedAddress } = prevState;\n        const { selectedAddress: currSelectedAddress } = currState;\n\n        if (currSelectedAddress === prevSelectedAddress) {\n          return;\n        }\n        await this._update(currSelectedAddress);\n      }, this.preferencesController.store.getState()),\n    );\n\n    onNetworkDidChange(async () => {\n      const address = this.preferencesController.getSelectedAddress();\n      await this._update(address);\n    });\n  }\n\n  start() {\n    const { featureFlags = {} } = this.preferencesController.store.getState();\n    const { showIncomingTransactions } = featureFlags;\n\n    if (!showIncomingTransactions) {\n      return;\n    }\n\n    this.blockTracker.removeListener('latest', this._onLatestBlock);\n    this.blockTracker.addListener('latest', this._onLatestBlock);\n  }\n\n  stop() {\n    this.blockTracker.removeListener('latest', this._onLatestBlock);\n  }\n\n  /**\n   * Determines the correct block number to begin looking for new transactions\n   * from, fetches the transactions and then saves them and the next block\n   * number to begin fetching from in state. Block numbers and transactions are\n   * stored per chainId.\n   *\n   * @private\n   * @param {string} address - address to lookup transactions for\n   * @param {number} [newBlockNumberDec] - block number to begin fetching from\n   */\n  async _update(address, newBlockNumberDec) {\n    const chainId = this.getCurrentChainId();\n    if (!etherscanSupportedNetworks.includes(chainId) || !address) {\n      return;\n    }\n    try {\n      const currentState = this.store.getState();\n      const currentBlock = parseInt(this.blockTracker.getCurrentBlock(), 16);\n\n      const mostRecentlyFetchedBlock =\n        currentState.incomingTxLastFetchedBlockByChainId[chainId];\n      const blockToFetchFrom =\n        mostRecentlyFetchedBlock ?? newBlockNumberDec ?? currentBlock;\n\n      const newIncomingTxs = await this._getNewIncomingTransactions(\n        address,\n        blockToFetchFrom,\n        chainId,\n      );\n\n      let newMostRecentlyFetchedBlock = blockToFetchFrom;\n\n      newIncomingTxs.forEach((tx) => {\n        if (\n          tx.blockNumber &&\n          parseInt(newMostRecentlyFetchedBlock, 10) <\n            parseInt(tx.blockNumber, 10)\n        ) {\n          newMostRecentlyFetchedBlock = parseInt(tx.blockNumber, 10);\n        }\n      });\n\n      this.store.updateState({\n        incomingTxLastFetchedBlockByChainId: {\n          ...currentState.incomingTxLastFetchedBlockByChainId,\n          [chainId]: newMostRecentlyFetchedBlock + 1,\n        },\n        incomingTransactions: newIncomingTxs.reduce(\n          (transactions, tx) => {\n            transactions[tx.hash] = tx;\n            return transactions;\n          },\n          {\n            ...currentState.incomingTransactions,\n          },\n        ),\n      });\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n  /**\n   * fetches transactions for the given address and chain, via etherscan, then\n   * processes the data into the necessary shape for usage in this controller.\n   *\n   * @private\n   * @param {string} [address] - Address to fetch transactions for\n   * @param {number} [fromBlock] - Block to look for transactions at\n   * @param {string} [chainId] - The chainId for the current network\n   * @returns {TransactionMeta[]}\n   */\n  async _getNewIncomingTransactions(address, fromBlock, chainId) {\n    const etherscanSubdomain =\n      chainId === MAINNET_CHAIN_ID\n        ? 'api'\n        : `api-${CHAIN_ID_TO_TYPE_MAP[chainId]}`;\n\n    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;\n    let url = `${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1`;\n\n    if (fromBlock) {\n      url += `&startBlock=${parseInt(fromBlock, 10)}`;\n    }\n    const response = await fetchWithTimeout(url);\n    const { status, result } = await response.json();\n    let newIncomingTxs = [];\n    if (status === '1' && Array.isArray(result) && result.length > 0) {\n      const remoteTxList = {};\n      const remoteTxs = [];\n      result.forEach((tx) => {\n        if (!remoteTxList[tx.hash]) {\n          remoteTxs.push(this._normalizeTxFromEtherscan(tx, chainId));\n          remoteTxList[tx.hash] = 1;\n        }\n      });\n\n      newIncomingTxs = remoteTxs.filter(\n        (tx) => tx.txParams?.to?.toLowerCase() === address.toLowerCase(),\n      );\n      newIncomingTxs.sort((a, b) => (a.time < b.time ? -1 : 1));\n    }\n    return newIncomingTxs;\n  }\n\n  /**\n   * Transmutes a EtherscanTransaction into a TransactionMeta\n   *\n   * @param {EtherscanTransaction} etherscanTransaction - the transaction to normalize\n   * @param {string} chainId - The chainId of the current network\n   * @returns {TransactionMeta}\n   */\n  _normalizeTxFromEtherscan(etherscanTransaction, chainId) {\n    const time = parseInt(etherscanTransaction.timeStamp, 10) * 1000;\n    const status =\n      etherscanTransaction.isError === '0'\n        ? TRANSACTION_STATUSES.CONFIRMED\n        : TRANSACTION_STATUSES.FAILED;\n    const txParams = {\n      from: etherscanTransaction.from,\n      gas: bnToHex(new BN(etherscanTransaction.gas)),\n      nonce: bnToHex(new BN(etherscanTransaction.nonce)),\n      to: etherscanTransaction.to,\n      value: bnToHex(new BN(etherscanTransaction.value)),\n    };\n\n    if (etherscanTransaction.gasPrice) {\n      txParams.gasPrice = bnToHex(new BN(etherscanTransaction.gasPrice));\n    } else if (etherscanTransaction.maxFeePerGas) {\n      txParams.maxFeePerGas = bnToHex(\n        new BN(etherscanTransaction.maxFeePerGas),\n      );\n      txParams.maxPriorityFeePerGas = bnToHex(\n        new BN(etherscanTransaction.maxPriorityFeePerGas),\n      );\n    }\n\n    return {\n      blockNumber: etherscanTransaction.blockNumber,\n      id: createId(),\n      chainId,\n      metamaskNetworkId: CHAIN_ID_TO_NETWORK_ID_MAP[chainId],\n      status,\n      time,\n      txParams,\n      hash: etherscanTransaction.hash,\n      type: TRANSACTION_TYPES.INCOMING,\n    };\n  }\n}\n\n/**\n * Returns a function with arity 1 that caches the argument that the function\n * is called with and invokes the comparator with both the cached, previous,\n * value and the current value. If specified, the initialValue will be passed\n * in as the previous value on the first invocation of the returned method.\n *\n * @template A - The type of the compared value.\n * @param {(prevValue: A, nextValue: A) => void} comparator - A method to compare\n * the previous and next values.\n * @param {A} [initialValue] - The initial value to supply to prevValue\n * on first call of the method.\n */\nfunction previousValueComparator(comparator, initialValue) {\n  let first = true;\n  let cache;\n  return (value) => {\n    try {\n      if (first) {\n        first = false;\n        return comparator(initialValue ?? value, value);\n      }\n      return comparator(cache, value);\n    } finally {\n      cache = value;\n    }\n  };\n}\n","import EventEmitter from 'events';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport { MESSAGE_TYPE } from '../../../shared/constants/app';\nimport { METAMASK_CONTROLLER_EVENTS } from '../metamask-controller';\nimport createId from '../../../shared/modules/random-id';\n\n/**\n * Represents, and contains data about, an 'eth_getEncryptionPublicKey' type request. These are created when\n * an eth_getEncryptionPublicKey call is requested.\n *\n * @typedef {Object} EncryptionPublicKey\n * @property {number} id An id to track and identify the message object\n * @property {Object} msgParams The parameters to pass to the encryptionPublicKey method once the request is\n * approved.\n * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.\n * @property {string} msgParams.data A hex string conversion of the raw buffer data of the request\n * @property {number} time The epoch time at which the this message was created\n * @property {string} status Indicates whether the request is 'unapproved', 'approved', 'received' or 'rejected'\n * @property {string} type The json-prc method for which a request has been made. A 'Message' will\n * always have a 'eth_getEncryptionPublicKey' type.\n */\n\nexport default class EncryptionPublicKeyManager extends EventEmitter {\n  /**\n   * Controller in charge of managing - storing, adding, removing, updating - EncryptionPublicKey.\n   *\n   * @param {object} opts - Controller options\n   * @param {Function} opts.metricEvent - A function for emitting a metric event.\n   */\n  constructor(opts) {\n    super();\n    this.memStore = new ObservableStore({\n      unapprovedEncryptionPublicKeyMsgs: {},\n      unapprovedEncryptionPublicKeyMsgCount: 0,\n    });\n    this.messages = [];\n    this.metricsEvent = opts.metricsEvent;\n  }\n\n  /**\n   * A getter for the number of 'unapproved' EncryptionPublicKeys in this.messages\n   *\n   * @returns {number} The number of 'unapproved' EncryptionPublicKeys in this.messages\n   */\n  get unapprovedEncryptionPublicKeyMsgCount() {\n    return Object.keys(this.getUnapprovedMsgs()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' EncryptionPublicKeys in this.messages\n   *\n   * @returns {Object} An index of EncryptionPublicKey ids to EncryptionPublicKeys, for all 'unapproved' EncryptionPublicKeys in\n   * this.messages\n   */\n  getUnapprovedMsgs() {\n    return this.messages\n      .filter((msg) => msg.status === 'unapproved')\n      .reduce((result, msg) => {\n        result[msg.id] = msg;\n        return result;\n      }, {});\n  }\n\n  /**\n   * Creates a new EncryptionPublicKey with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new EncryptionPublicKey to this.messages, and to save the unapproved EncryptionPublicKeys from that list to\n   * this.memStore.\n   *\n   * @param {Object} address - The param for the eth_getEncryptionPublicKey call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @returns {Promise<Buffer>} The raw public key contents\n   */\n  addUnapprovedMessageAsync(address, req) {\n    return new Promise((resolve, reject) => {\n      if (!address) {\n        reject(new Error('MetaMask Message: address field is required.'));\n        return;\n      }\n      const msgId = this.addUnapprovedMessage(address, req);\n      this.once(`${msgId}:finished`, (data) => {\n        switch (data.status) {\n          case 'received':\n            resolve(data.rawData);\n            return;\n          case 'rejected':\n            reject(\n              ethErrors.provider.userRejectedRequest(\n                'MetaMask EncryptionPublicKey: User denied message EncryptionPublicKey.',\n              ),\n            );\n            return;\n          default:\n            reject(\n              new Error(\n                `MetaMask EncryptionPublicKey: Unknown problem: ${JSON.stringify(\n                  address,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new EncryptionPublicKey with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new EncryptionPublicKey to this.messages, and to save the unapproved EncryptionPublicKeys from that list to\n   * this.memStore.\n   *\n   * @param {Object} address - The param for the eth_getEncryptionPublicKey call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @returns {number} The id of the newly created EncryptionPublicKey.\n   */\n  addUnapprovedMessage(address, req) {\n    log.debug(`EncryptionPublicKeyManager addUnapprovedMessage: address`);\n    // create txData obj with parameters and meta data\n    const time = new Date().getTime();\n    const msgId = createId();\n    const msgData = {\n      id: msgId,\n      msgParams: address,\n      time,\n      status: 'unapproved',\n      type: MESSAGE_TYPE.ETH_GET_ENCRYPTION_PUBLIC_KEY,\n    };\n\n    if (req) {\n      msgData.origin = req.origin;\n    }\n\n    this.addMsg(msgData);\n\n    // signal update\n    this.emit('update');\n    return msgId;\n  }\n\n  /**\n   * Adds a passed EncryptionPublicKey to this.messages, and calls this._saveMsgList() to save the unapproved EncryptionPublicKeys from that\n   * list to this.memStore.\n   *\n   * @param {Message} msg - The EncryptionPublicKey to add to this.messages\n   */\n  addMsg(msg) {\n    this.messages.push(msg);\n    this._saveMsgList();\n  }\n\n  /**\n   * Returns a specified EncryptionPublicKey.\n   *\n   * @param {number} msgId - The id of the EncryptionPublicKey to get\n   * @returns {EncryptionPublicKey|undefined} The EncryptionPublicKey with the id that matches the passed msgId, or undefined\n   * if no EncryptionPublicKey has that id.\n   */\n  getMsg(msgId) {\n    return this.messages.find((msg) => msg.id === msgId);\n  }\n\n  /**\n   * Approves a EncryptionPublicKey. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise\n   * with any the message params modified for proper providing.\n   *\n   * @param {Object} msgParams - The msgParams to be used when eth_getEncryptionPublicKey is called, plus data added by MetaMask.\n   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.\n   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.\n   */\n  approveMessage(msgParams) {\n    this.setMsgStatusApproved(msgParams.metamaskId);\n    return this.prepMsgForEncryptionPublicKey(msgParams);\n  }\n\n  /**\n   * Sets a EncryptionPublicKey status to 'approved' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the EncryptionPublicKey to approve.\n   */\n  setMsgStatusApproved(msgId) {\n    this._setMsgStatus(msgId, 'approved');\n  }\n\n  /**\n   * Sets a EncryptionPublicKey status to 'received' via a call to this._setMsgStatus and updates that EncryptionPublicKey in\n   * this.messages by adding the raw data of request to the EncryptionPublicKey\n   *\n   * @param {number} msgId - The id of the EncryptionPublicKey.\n   * @param {buffer} rawData - The raw data of the message request\n   */\n  setMsgStatusReceived(msgId, rawData) {\n    const msg = this.getMsg(msgId);\n    msg.rawData = rawData;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'received');\n  }\n\n  /**\n   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams\n   *\n   * @param {Object} msgParams - The msgParams to modify\n   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed\n   */\n  prepMsgForEncryptionPublicKey(msgParams) {\n    delete msgParams.metamaskId;\n    return Promise.resolve(msgParams);\n  }\n\n  /**\n   * Sets a EncryptionPublicKey status to 'rejected' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the EncryptionPublicKey to reject.\n   * @param reason\n   */\n  rejectMsg(msgId, reason = undefined) {\n    if (reason) {\n      this.metricsEvent({\n        event: reason,\n        category: 'Messages',\n        properties: {\n          action: 'Encryption public key Request',\n        },\n      });\n    }\n    this._setMsgStatus(msgId, 'rejected');\n  }\n\n  /**\n   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the TypedMessage to error\n   * @param error\n   */\n  errorMessage(msgId, error) {\n    const msg = this.getMsg(msgId);\n    msg.error = error;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'errored');\n  }\n\n  /**\n   * Clears all unapproved messages from memory.\n   */\n  clearUnapproved() {\n    this.messages = this.messages.filter((msg) => msg.status !== 'unapproved');\n    this._saveMsgList();\n  }\n\n  /**\n   * Updates the status of a EncryptionPublicKey in this.messages via a call to this._updateMsg\n   *\n   * @private\n   * @param {number} msgId - The id of the EncryptionPublicKey to update.\n   * @param {string} status - The new status of the EncryptionPublicKey.\n   * @throws A 'EncryptionPublicKeyManager - EncryptionPublicKey not found for id: \"${msgId}\".' if there is no EncryptionPublicKey\n   * in this.messages with an id equal to the passed msgId\n   * @fires An event with a name equal to `${msgId}:${status}`. The EncryptionPublicKey is also fired.\n   * @fires If status is 'rejected' or 'received', an event with a name equal to `${msgId}:finished` is fired along\n   * with the EncryptionPublicKey\n   */\n  _setMsgStatus(msgId, status) {\n    const msg = this.getMsg(msgId);\n    if (!msg) {\n      throw new Error(\n        `EncryptionPublicKeyManager - Message not found for id: \"${msgId}\".`,\n      );\n    }\n    msg.status = status;\n    this._updateMsg(msg);\n    this.emit(`${msgId}:${status}`, msg);\n    if (status === 'rejected' || status === 'received') {\n      this.emit(`${msgId}:finished`, msg);\n    }\n  }\n\n  /**\n   * Sets a EncryptionPublicKey in this.messages to the passed EncryptionPublicKey if the ids are equal. Then saves the\n   * unapprovedEncryptionPublicKeyMsgs index to storage via this._saveMsgList\n   *\n   * @private\n   * @param {EncryptionPublicKey} msg - A EncryptionPublicKey that will replace an existing EncryptionPublicKey (with the same\n   * id) in this.messages\n   */\n  _updateMsg(msg) {\n    const index = this.messages.findIndex((message) => message.id === msg.id);\n    if (index !== -1) {\n      this.messages[index] = msg;\n    }\n    this._saveMsgList();\n  }\n\n  /**\n   * Saves the unapproved EncryptionPublicKeys, and their count, to this.memStore\n   *\n   * @private\n   * @fires 'updateBadge'\n   */\n  _saveMsgList() {\n    const unapprovedEncryptionPublicKeyMsgs = this.getUnapprovedMsgs();\n    const unapprovedEncryptionPublicKeyMsgCount = Object.keys(\n      unapprovedEncryptionPublicKeyMsgs,\n    ).length;\n    this.memStore.updateState({\n      unapprovedEncryptionPublicKeyMsgs,\n      unapprovedEncryptionPublicKeyMsgCount,\n    });\n    this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);\n  }\n}\n","import EventEmitter from 'events';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { METAMASK_CONTROLLER_EVENTS } from '../metamask-controller';\nimport { MINUTE } from '../../../shared/constants/time';\n\nexport default class AppStateController extends EventEmitter {\n  /**\n   * @param {Object} opts\n   */\n  constructor(opts = {}) {\n    const {\n      addUnlockListener,\n      isUnlocked,\n      initState,\n      onInactiveTimeout,\n      showUnlockRequest,\n      preferencesStore,\n      qrHardwareStore,\n    } = opts;\n    super();\n\n    this.onInactiveTimeout = onInactiveTimeout || (() => undefined);\n    this.store = new ObservableStore({\n      timeoutMinutes: 0,\n      connectedStatusPopoverHasBeenShown: true,\n      defaultHomeActiveTabName: null,\n      browserEnvironment: {},\n      popupGasPollTokens: [],\n      notificationGasPollTokens: [],\n      fullScreenGasPollTokens: [],\n      recoveryPhraseReminderHasBeenShown: false,\n      recoveryPhraseReminderLastShown: new Date().getTime(),\n      collectiblesDetectionNoticeDismissed: false,\n      enableEIP1559V2NoticeDismissed: false,\n      showTestnetMessageInDropdown: true,\n      trezorModel: null,\n      ...initState,\n      qrHardware: {},\n      collectiblesDropdownState: {},\n    });\n    this.timer = null;\n\n    this.isUnlocked = isUnlocked;\n    this.waitingForUnlock = [];\n    addUnlockListener(this.handleUnlock.bind(this));\n\n    this._showUnlockRequest = showUnlockRequest;\n\n    preferencesStore.subscribe(({ preferences }) => {\n      const currentState = this.store.getState();\n      if (currentState.timeoutMinutes !== preferences.autoLockTimeLimit) {\n        this._setInactiveTimeout(preferences.autoLockTimeLimit);\n      }\n    });\n\n    qrHardwareStore.subscribe((state) => {\n      this.store.updateState({ qrHardware: state });\n    });\n\n    const { preferences } = preferencesStore.getState();\n    this._setInactiveTimeout(preferences.autoLockTimeLimit);\n  }\n\n  /**\n   * Get a Promise that resolves when the extension is unlocked.\n   * This Promise will never reject.\n   *\n   * @param {boolean} shouldShowUnlockRequest - Whether the extension notification\n   * popup should be opened.\n   * @returns {Promise<void>} A promise that resolves when the extension is\n   * unlocked, or immediately if the extension is already unlocked.\n   */\n  getUnlockPromise(shouldShowUnlockRequest) {\n    return new Promise((resolve) => {\n      if (this.isUnlocked()) {\n        resolve();\n      } else {\n        this.waitForUnlock(resolve, shouldShowUnlockRequest);\n      }\n    });\n  }\n\n  /**\n   * Adds a Promise's resolve function to the waitingForUnlock queue.\n   * Also opens the extension popup if specified.\n   *\n   * @param {Promise.resolve} resolve - A Promise's resolve function that will\n   * be called when the extension is unlocked.\n   * @param {boolean} shouldShowUnlockRequest - Whether the extension notification\n   * popup should be opened.\n   */\n  waitForUnlock(resolve, shouldShowUnlockRequest) {\n    this.waitingForUnlock.push({ resolve });\n    this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);\n    if (shouldShowUnlockRequest) {\n      this._showUnlockRequest();\n    }\n  }\n\n  /**\n   * Drains the waitingForUnlock queue, resolving all the related Promises.\n   */\n  handleUnlock() {\n    if (this.waitingForUnlock.length > 0) {\n      while (this.waitingForUnlock.length > 0) {\n        this.waitingForUnlock.shift().resolve();\n      }\n      this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);\n    }\n  }\n\n  /**\n   * Sets the default home tab\n   *\n   * @param {string} [defaultHomeActiveTabName] - the tab name\n   */\n  setDefaultHomeActiveTabName(defaultHomeActiveTabName) {\n    this.store.updateState({\n      defaultHomeActiveTabName,\n    });\n  }\n\n  /**\n   * Record that the user has seen the connected status info popover\n   */\n  setConnectedStatusPopoverHasBeenShown() {\n    this.store.updateState({\n      connectedStatusPopoverHasBeenShown: true,\n    });\n  }\n\n  /**\n   * Record that the user has been shown the recovery phrase reminder.\n   */\n  setRecoveryPhraseReminderHasBeenShown() {\n    this.store.updateState({\n      recoveryPhraseReminderHasBeenShown: true,\n    });\n  }\n\n  /**\n   * Record the timestamp of the last time the user has seen the recovery phrase reminder\n   *\n   * @param {number} lastShown - timestamp when user was last shown the reminder.\n   */\n  setRecoveryPhraseReminderLastShown(lastShown) {\n    this.store.updateState({\n      recoveryPhraseReminderLastShown: lastShown,\n    });\n  }\n\n  /**\n   * Sets the last active time to the current time.\n   */\n  setLastActiveTime() {\n    this._resetTimer();\n  }\n\n  /**\n   * Sets the inactive timeout for the app\n   *\n   * @private\n   * @param {number} timeoutMinutes - The inactive timeout in minutes.\n   */\n  _setInactiveTimeout(timeoutMinutes) {\n    this.store.updateState({\n      timeoutMinutes,\n    });\n\n    this._resetTimer();\n  }\n\n  /**\n   * Resets the internal inactive timer\n   *\n   * If the {@code timeoutMinutes} state is falsy (i.e., zero) then a new\n   * timer will not be created.\n   *\n   * @private\n   */\n  _resetTimer() {\n    const { timeoutMinutes } = this.store.getState();\n\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n\n    if (!timeoutMinutes) {\n      return;\n    }\n\n    this.timer = setTimeout(\n      () => this.onInactiveTimeout(),\n      timeoutMinutes * MINUTE,\n    );\n  }\n\n  /**\n   * Sets the current browser and OS environment\n   *\n   * @param os\n   * @param browser\n   */\n  setBrowserEnvironment(os, browser) {\n    this.store.updateState({ browserEnvironment: { os, browser } });\n  }\n\n  /**\n   * Adds a pollingToken for a given environmentType\n   *\n   * @param pollingToken\n   * @param pollingTokenType\n   */\n  addPollingToken(pollingToken, pollingTokenType) {\n    const prevState = this.store.getState()[pollingTokenType];\n    this.store.updateState({\n      [pollingTokenType]: [...prevState, pollingToken],\n    });\n  }\n\n  /**\n   * removes a pollingToken for a given environmentType\n   *\n   * @param pollingToken\n   * @param pollingTokenType\n   */\n  removePollingToken(pollingToken, pollingTokenType) {\n    const prevState = this.store.getState()[pollingTokenType];\n    this.store.updateState({\n      [pollingTokenType]: prevState.filter((token) => token !== pollingToken),\n    });\n  }\n\n  /**\n   * clears all pollingTokens\n   */\n  clearPollingTokens() {\n    this.store.updateState({\n      popupGasPollTokens: [],\n      notificationGasPollTokens: [],\n      fullScreenGasPollTokens: [],\n    });\n  }\n\n  /**\n   * Sets whether the testnet dismissal link should be shown in the network dropdown\n   *\n   * @param showTestnetMessageInDropdown\n   */\n  setShowTestnetMessageInDropdown(showTestnetMessageInDropdown) {\n    this.store.updateState({ showTestnetMessageInDropdown });\n  }\n\n  /**\n   * Sets a property indicating the model of the user's Trezor hardware wallet\n   *\n   * @param trezorModel - The Trezor model.\n   */\n  setTrezorModel(trezorModel) {\n    this.store.updateState({ trezorModel });\n  }\n\n  /**\n   * A setter for the `collectiblesDetectionNoticeDismissed` property\n   *\n   * @param collectiblesDetectionNoticeDismissed\n   */\n  setCollectiblesDetectionNoticeDismissed(\n    collectiblesDetectionNoticeDismissed,\n  ) {\n    this.store.updateState({\n      collectiblesDetectionNoticeDismissed,\n    });\n  }\n\n  /**\n   * A setter for the `enableEIP1559V2NoticeDismissed` property\n   *\n   * @param enableEIP1559V2NoticeDismissed\n   */\n  setEnableEIP1559V2NoticeDismissed(enableEIP1559V2NoticeDismissed) {\n    this.store.updateState({\n      enableEIP1559V2NoticeDismissed,\n    });\n  }\n\n  /**\n   * A setter for the `collectiblesDropdownState` property\n   *\n   * @param collectiblesDropdownState\n   */\n  updateCollectibleDropDownState(collectiblesDropdownState) {\n    this.store.updateState({\n      collectiblesDropdownState,\n    });\n  }\n}\n","import EventEmitter from 'events';\nimport { strict as assert } from 'assert';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { typedSignatureHash, TYPED_MESSAGE_SCHEMA } from 'eth-sig-util';\nimport log from 'loglevel';\nimport jsonschema from 'jsonschema';\nimport { MESSAGE_TYPE } from '../../../shared/constants/app';\nimport { METAMASK_CONTROLLER_EVENTS } from '../metamask-controller';\nimport createId from '../../../shared/modules/random-id';\nimport { isValidHexAddress } from '../../../shared/modules/hexstring-utils';\n\n/**\n * Represents, and contains data about, an 'eth_signTypedData' type signature request. These are created when a\n * signature for an eth_signTypedData call is requested.\n *\n * @typedef {Object} TypedMessage\n * @property {number} id An id to track and identify the message object\n * @property {Object} msgParams The parameters to pass to the eth_signTypedData method once the signature request is\n * approved.\n * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.\n * @property {Object} msgParams.from The address that is making the signature request.\n * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request\n * @property {number} time The epoch time at which the this message was created\n * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed', 'rejected', or 'errored'\n * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will\n * always have a 'eth_signTypedData' type.\n */\n\nexport default class TypedMessageManager extends EventEmitter {\n  /**\n   * Controller in charge of managing - storing, adding, removing, updating - TypedMessage.\n   *\n   * @param options\n   * @param options.getCurrentChainId\n   * @param options.metricsEvent\n   */\n  constructor({ getCurrentChainId, metricsEvent }) {\n    super();\n    this._getCurrentChainId = getCurrentChainId;\n    this.memStore = new ObservableStore({\n      unapprovedTypedMessages: {},\n      unapprovedTypedMessagesCount: 0,\n    });\n    this.messages = [];\n    this.metricsEvent = metricsEvent;\n  }\n\n  /**\n   * A getter for the number of 'unapproved' TypedMessages in this.messages\n   *\n   * @returns {number} The number of 'unapproved' TypedMessages in this.messages\n   */\n  get unapprovedTypedMessagesCount() {\n    return Object.keys(this.getUnapprovedMsgs()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' TypedMessages in this.messages\n   *\n   * @returns {Object} An index of TypedMessage ids to TypedMessages, for all 'unapproved' TypedMessages in\n   * this.messages\n   */\n  getUnapprovedMsgs() {\n    return this.messages\n      .filter((msg) => msg.status === 'unapproved')\n      .reduce((result, msg) => {\n        result[msg.id] = msg;\n        return result;\n      }, {});\n  }\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to\n   * this.memStore. Before any of this is done, msgParams are validated\n   *\n   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @param version\n   * @returns {promise} When the message has been signed or rejected\n   */\n  addUnapprovedMessageAsync(msgParams, req, version) {\n    return new Promise((resolve, reject) => {\n      const msgId = this.addUnapprovedMessage(msgParams, req, version);\n      this.once(`${msgId}:finished`, (data) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig);\n          case 'rejected':\n            return reject(\n              ethErrors.provider.userRejectedRequest(\n                'MetaMask Message Signature: User denied message signature.',\n              ),\n            );\n          case 'errored':\n            return reject(\n              new Error(`MetaMask Message Signature: ${data.error}`),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Message Signature: Unknown problem: ${JSON.stringify(\n                  msgParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add\n   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to\n   * this.memStore. Before any of this is done, msgParams are validated\n   *\n   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.\n   * @param {Object} [req] - The original request object possibly containing the origin\n   * @param version\n   * @returns {number} The id of the newly created TypedMessage.\n   */\n  addUnapprovedMessage(msgParams, req, version) {\n    msgParams.version = version;\n    if (req) {\n      msgParams.origin = req.origin;\n    }\n    this.validateParams(msgParams);\n\n    log.debug(\n      `TypedMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`,\n    );\n\n    // create txData obj with parameters and meta data\n    const time = new Date().getTime();\n    const msgId = createId();\n    const msgData = {\n      id: msgId,\n      msgParams,\n      time,\n      status: 'unapproved',\n      type: MESSAGE_TYPE.ETH_SIGN_TYPED_DATA,\n    };\n    this.addMsg(msgData);\n\n    // signal update\n    this.emit('update');\n    return msgId;\n  }\n\n  /**\n   * Helper method for this.addUnapprovedMessage. Validates that the passed params have the required properties.\n   *\n   * @param {Object} params - The params to validate\n   */\n  validateParams(params) {\n    assert.ok(\n      params && typeof params === 'object',\n      'Params must be an object.',\n    );\n    assert.ok('data' in params, 'Params must include a \"data\" field.');\n    assert.ok('from' in params, 'Params must include a \"from\" field.');\n    assert.ok(\n      typeof params.from === 'string' &&\n        isValidHexAddress(params.from, { allowNonPrefixed: false }),\n      '\"from\" field must be a valid, lowercase, hexadecimal Ethereum address string.',\n    );\n\n    switch (params.version) {\n      case 'V1':\n        assert.ok(\n          Array.isArray(params.data),\n          '\"params.data\" must be an array.',\n        );\n        assert.doesNotThrow(() => {\n          typedSignatureHash(params.data);\n        }, 'Signing data must be valid EIP-712 typed data.');\n        break;\n      case 'V3':\n      case 'V4': {\n        assert.equal(\n          typeof params.data,\n          'string',\n          '\"params.data\" must be a string.',\n        );\n        let data;\n        assert.doesNotThrow(() => {\n          data = JSON.parse(params.data);\n        }, '\"data\" must be a valid JSON string.');\n        const validation = jsonschema.validate(data, TYPED_MESSAGE_SCHEMA);\n        assert.ok(\n          data.primaryType in data.types,\n          `Primary type of \"${data.primaryType}\" has no type definition.`,\n        );\n        assert.equal(\n          validation.errors.length,\n          0,\n          'Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.',\n        );\n        let { chainId } = data.domain;\n        if (chainId) {\n          const activeChainId = parseInt(this._getCurrentChainId(), 16);\n          assert.ok(\n            !Number.isNaN(activeChainId),\n            `Cannot sign messages for chainId \"${chainId}\", because MetaMask is switching networks.`,\n          );\n          if (typeof chainId === 'string') {\n            chainId = parseInt(chainId, chainId.startsWith('0x') ? 16 : 10);\n          }\n          assert.equal(\n            chainId,\n            activeChainId,\n            `Provided chainId \"${chainId}\" must match the active chainId \"${activeChainId}\"`,\n          );\n        }\n        break;\n      }\n      default:\n        assert.fail(`Unknown typed data version \"${params.version}\"`);\n    }\n  }\n\n  /**\n   * Adds a passed TypedMessage to this.messages, and calls this._saveMsgList() to save the unapproved TypedMessages from that\n   * list to this.memStore.\n   *\n   * @param {Message} msg - The TypedMessage to add to this.messages\n   */\n  addMsg(msg) {\n    this.messages.push(msg);\n    this._saveMsgList();\n  }\n\n  /**\n   * Returns a specified TypedMessage.\n   *\n   * @param {number} msgId - The id of the TypedMessage to get\n   * @returns {TypedMessage|undefined} The TypedMessage with the id that matches the passed msgId, or undefined\n   * if no TypedMessage has that id.\n   */\n  getMsg(msgId) {\n    return this.messages.find((msg) => msg.id === msgId);\n  }\n\n  /**\n   * Approves a TypedMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise\n   * with any the message params modified for proper signing.\n   *\n   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.\n   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.\n   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.\n   */\n  approveMessage(msgParams) {\n    this.setMsgStatusApproved(msgParams.metamaskId);\n    return this.prepMsgForSigning(msgParams);\n  }\n\n  /**\n   * Sets a TypedMessage status to 'approved' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the TypedMessage to approve.\n   */\n  setMsgStatusApproved(msgId) {\n    this._setMsgStatus(msgId, 'approved');\n  }\n\n  /**\n   * Sets a TypedMessage status to 'signed' via a call to this._setMsgStatus and updates that TypedMessage in\n   * this.messages by adding the raw signature data of the signature request to the TypedMessage\n   *\n   * @param {number} msgId - The id of the TypedMessage to sign.\n   * @param {buffer} rawSig - The raw data of the signature request\n   */\n  setMsgStatusSigned(msgId, rawSig) {\n    const msg = this.getMsg(msgId);\n    msg.rawSig = rawSig;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'signed');\n  }\n\n  /**\n   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams\n   *\n   * @param {Object} msgParams - The msgParams to modify\n   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed\n   */\n  prepMsgForSigning(msgParams) {\n    delete msgParams.metamaskId;\n    delete msgParams.version;\n    return Promise.resolve(msgParams);\n  }\n\n  /**\n   * Sets a TypedMessage status to 'rejected' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the TypedMessage to reject.\n   * @param reason\n   */\n  rejectMsg(msgId, reason = undefined) {\n    if (reason) {\n      const msg = this.getMsg(msgId);\n      this.metricsEvent({\n        event: reason,\n        category: 'Transactions',\n        properties: {\n          action: 'Sign Request',\n          version: msg.msgParams.version,\n          type: msg.type,\n        },\n      });\n    }\n    this._setMsgStatus(msgId, 'rejected');\n  }\n\n  /**\n   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.\n   *\n   * @param {number} msgId - The id of the TypedMessage to error\n   * @param error\n   */\n  errorMessage(msgId, error) {\n    const msg = this.getMsg(msgId);\n    msg.error = error;\n    this._updateMsg(msg);\n    this._setMsgStatus(msgId, 'errored');\n  }\n\n  /**\n   * Clears all unapproved messages from memory.\n   */\n  clearUnapproved() {\n    this.messages = this.messages.filter((msg) => msg.status !== 'unapproved');\n    this._saveMsgList();\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  /**\n   * Updates the status of a TypedMessage in this.messages via a call to this._updateMsg\n   *\n   * @private\n   * @param {number} msgId - The id of the TypedMessage to update.\n   * @param {string} status - The new status of the TypedMessage.\n   * @throws A 'TypedMessageManager - TypedMessage not found for id: \"${msgId}\".' if there is no TypedMessage\n   * in this.messages with an id equal to the passed msgId\n   * @fires An event with a name equal to `${msgId}:${status}`. The TypedMessage is also fired.\n   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along\n   * with the TypedMessage\n   */\n  _setMsgStatus(msgId, status) {\n    const msg = this.getMsg(msgId);\n    if (!msg) {\n      throw new Error(\n        `TypedMessageManager - Message not found for id: \"${msgId}\".`,\n      );\n    }\n    msg.status = status;\n    this._updateMsg(msg);\n    this.emit(`${msgId}:${status}`, msg);\n    if (status === 'rejected' || status === 'signed' || status === 'errored') {\n      this.emit(`${msgId}:finished`, msg);\n    }\n  }\n\n  /**\n   * Sets a TypedMessage in this.messages to the passed TypedMessage if the ids are equal. Then saves the\n   * unapprovedTypedMsgs index to storage via this._saveMsgList\n   *\n   * @private\n   * @param {TypedMessage} msg - A TypedMessage that will replace an existing TypedMessage (with the same\n   * id) in this.messages\n   */\n  _updateMsg(msg) {\n    const index = this.messages.findIndex((message) => message.id === msg.id);\n    if (index !== -1) {\n      this.messages[index] = msg;\n    }\n    this._saveMsgList();\n  }\n\n  /**\n   * Saves the unapproved TypedMessages, and their count, to this.memStore\n   *\n   * @private\n   * @fires 'updateBadge'\n   */\n  _saveMsgList() {\n    const unapprovedTypedMessages = this.getUnapprovedMsgs();\n    const unapprovedTypedMessagesCount = Object.keys(unapprovedTypedMessages)\n      .length;\n    this.memStore.updateState({\n      unapprovedTypedMessages,\n      unapprovedTypedMessagesCount,\n    });\n    this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);\n  }\n}\n","import punycode from 'punycode/punycode';\nimport { ObservableStore } from '@metamask/obs-store';\nimport log from 'loglevel';\nimport { CHAIN_ID_TO_NETWORK_ID_MAP } from '../../../../shared/constants/network';\nimport { toChecksumHexAddress } from '../../../../shared/modules/hexstring-utils';\nimport Ens from './ens';\n\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nconst ZERO_X_ERROR_ADDRESS = '0x';\n\nexport default class EnsController {\n  constructor({ ens, provider, onNetworkDidChange, getCurrentChainId } = {}) {\n    const initState = {\n      ensResolutionsByAddress: {},\n    };\n\n    this._ens = ens;\n    if (!this._ens) {\n      const chainId = getCurrentChainId();\n      const network = CHAIN_ID_TO_NETWORK_ID_MAP[chainId];\n      if (Ens.getNetworkEnsSupport(network)) {\n        this._ens = new Ens({\n          network,\n          provider,\n        });\n      }\n    }\n\n    this.store = new ObservableStore(initState);\n    onNetworkDidChange(() => {\n      this.store.putState(initState);\n      const chainId = getCurrentChainId();\n      const network = CHAIN_ID_TO_NETWORK_ID_MAP[chainId];\n      if (Ens.getNetworkEnsSupport(network)) {\n        this._ens = new Ens({\n          network,\n          provider,\n        });\n      } else {\n        delete this._ens;\n      }\n    });\n  }\n\n  reverseResolveAddress(address) {\n    return this._reverseResolveAddress(toChecksumHexAddress(address));\n  }\n\n  async _reverseResolveAddress(address) {\n    if (!this._ens) {\n      return undefined;\n    }\n\n    const state = this.store.getState();\n    if (state.ensResolutionsByAddress[address]) {\n      return state.ensResolutionsByAddress[address];\n    }\n\n    let domain;\n    try {\n      domain = await this._ens.reverse(address);\n    } catch (error) {\n      log.debug(error);\n      return undefined;\n    }\n\n    let registeredAddress;\n    try {\n      registeredAddress = await this._ens.lookup(domain);\n    } catch (error) {\n      log.debug(error);\n      return undefined;\n    }\n\n    if (\n      registeredAddress === ZERO_ADDRESS ||\n      registeredAddress === ZERO_X_ERROR_ADDRESS\n    ) {\n      return undefined;\n    }\n\n    if (toChecksumHexAddress(registeredAddress) !== address) {\n      return undefined;\n    }\n\n    this._updateResolutionsByAddress(address, punycode.toASCII(domain));\n    return domain;\n  }\n\n  _updateResolutionsByAddress(address, domain) {\n    const oldState = this.store.getState();\n    this.store.putState({\n      ensResolutionsByAddress: {\n        ...oldState.ensResolutionsByAddress,\n        [address]: domain,\n      },\n    });\n  }\n}\n","export * from './caveat-mutators';\nexport * from './background-api';\nexport * from './enums';\nexport * from './permission-log';\nexport * from './specifications';\nexport * from './selectors';\n","import EventEmitter from 'safe-event-emitter';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { bufferToHex, keccak, toBuffer, isHexString } from 'ethereumjs-util';\nimport EthQuery from 'ethjs-query';\nimport { ethErrors } from 'eth-rpc-errors';\nimport abi from 'human-standard-token-abi';\nimport Common from '@ethereumjs/common';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { ethers } from 'ethers';\nimport NonceTracker from 'nonce-tracker';\nimport log from 'loglevel';\nimport BigNumber from 'bignumber.js';\nimport cleanErrorStack from '../../lib/cleanErrorStack';\nimport {\n  hexToBn,\n  bnToHex,\n  BnMultiplyByFraction,\n  addHexPrefix,\n  getChainType,\n} from '../../lib/util';\nimport { TRANSACTION_NO_CONTRACT_ERROR_KEY } from '../../../../ui/helpers/constants/error-keys';\nimport { getSwapsTokensReceivedFromTxMeta } from '../../../../ui/pages/swaps/swaps.util';\nimport {\n  hexWEIToDecGWEI,\n  decimalToHex,\n} from '../../../../ui/helpers/utils/conversions.util';\nimport {\n  TRANSACTION_STATUSES,\n  TRANSACTION_TYPES,\n  TRANSACTION_ENVELOPE_TYPES,\n  TRANSACTION_EVENTS,\n} from '../../../../shared/constants/transaction';\nimport { TRANSACTION_ENVELOPE_TYPE_NAMES } from '../../../../ui/helpers/constants/transactions';\nimport { METAMASK_CONTROLLER_EVENTS } from '../../metamask-controller';\nimport {\n  GAS_LIMITS,\n  GAS_ESTIMATE_TYPES,\n  GAS_RECOMMENDATIONS,\n  CUSTOM_GAS_ESTIMATE,\n  PRIORITY_LEVELS,\n} from '../../../../shared/constants/gas';\nimport { decGWEIToHexWEI } from '../../../../shared/modules/conversion.utils';\nimport {\n  HARDFORKS,\n  MAINNET,\n  NETWORK_TYPE_RPC,\n  CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP,\n} from '../../../../shared/constants/network';\nimport { isEIP1559Transaction } from '../../../../shared/modules/transaction.utils';\nimport { readAddressAsContract } from '../../../../shared/modules/contract-utils';\nimport { isEqualCaseInsensitive } from '../../../../ui/helpers/utils/util';\nimport TransactionStateManager from './tx-state-manager';\nimport TxGasUtil from './tx-gas-utils';\nimport PendingTransactionTracker from './pending-tx-tracker';\nimport * as txUtils from './lib/util';\n\nconst hstInterface = new ethers.utils.Interface(abi);\n\nconst MAX_MEMSTORE_TX_LIST_SIZE = 100; // Number of transactions (by unique nonces) to keep in memory\n\nconst SWAP_TRANSACTION_TYPES = [\n  TRANSACTION_TYPES.SWAP,\n  TRANSACTION_TYPES.SWAP_APPROVAL,\n];\n\n/**\n * @typedef {import('../../../../shared/constants/transaction').TransactionMeta} TransactionMeta\n * @typedef {import('../../../../shared/constants/transaction').TransactionMetaMetricsEventString} TransactionMetaMetricsEventString\n */\n\nconst METRICS_STATUS_FAILED = 'failed on-chain';\n\n/**\n * @typedef {Object} CustomGasSettings\n * @property {string} [gas] - The gas limit to use for the transaction\n * @property {string} [gasPrice] - The gasPrice to use for a legacy transaction\n * @property {string} [maxFeePerGas] - The maximum amount to pay per gas on a\n *  EIP-1559 transaction\n * @property {string} [maxPriorityFeePerGas] - The maximum amount of paid fee\n *  to be distributed to miner in an EIP-1559 transaction\n */\n\n/**\n * Transaction Controller is an aggregate of sub-controllers and trackers\n * composing them in a way to be exposed to the metamask controller\n *\n * - `txStateManager\n * responsible for the state of a transaction and\n * storing the transaction\n * - pendingTxTracker\n * watching blocks for transactions to be include\n * and emitting confirmed events\n * - txGasUtil\n * gas calculations and safety buffering\n * - nonceTracker\n * calculating nonces\n *\n * @param {Object} opts\n * @param {Object} opts.initState - initial transaction list default is an empty array\n * @param {Object} opts.networkStore - an observable store for network number\n * @param {Object} opts.blockTracker - An instance of eth-blocktracker\n * @param {Object} opts.provider - A network provider.\n * @param {Function} opts.signTransaction - function the signs an @ethereumjs/tx\n * @param {Object} opts.getPermittedAccounts - get accounts that an origin has permissions for\n * @param {Function} opts.signTransaction - ethTx signer that returns a rawTx\n * @param {number} [opts.txHistoryLimit] - number *optional* for limiting how many transactions are in state\n * @param {Object} opts.preferencesStore\n */\n\nexport default class TransactionController extends EventEmitter {\n  constructor(opts) {\n    super();\n    this.networkStore = opts.networkStore || new ObservableStore({});\n    this._getCurrentChainId = opts.getCurrentChainId;\n    this.getProviderConfig = opts.getProviderConfig;\n    this._getCurrentNetworkEIP1559Compatibility =\n      opts.getCurrentNetworkEIP1559Compatibility;\n    this._getCurrentAccountEIP1559Compatibility =\n      opts.getCurrentAccountEIP1559Compatibility;\n    this.preferencesStore = opts.preferencesStore || new ObservableStore({});\n    this.provider = opts.provider;\n    this.getPermittedAccounts = opts.getPermittedAccounts;\n    this.blockTracker = opts.blockTracker;\n    this.signEthTx = opts.signTransaction;\n    this.inProcessOfSigning = new Set();\n    this._trackMetaMetricsEvent = opts.trackMetaMetricsEvent;\n    this._getParticipateInMetrics = opts.getParticipateInMetrics;\n    this._getEIP1559GasFeeEstimates = opts.getEIP1559GasFeeEstimates;\n    this.createEventFragment = opts.createEventFragment;\n    this.updateEventFragment = opts.updateEventFragment;\n    this.finalizeEventFragment = opts.finalizeEventFragment;\n    this.getEventFragmentById = opts.getEventFragmentById;\n\n    this.memStore = new ObservableStore({});\n    this.query = new EthQuery(this.provider);\n\n    this.txGasUtil = new TxGasUtil(this.provider);\n    this._mapMethods();\n    this.txStateManager = new TransactionStateManager({\n      initState: opts.initState,\n      txHistoryLimit: opts.txHistoryLimit,\n      getNetwork: this.getNetwork.bind(this),\n      getCurrentChainId: opts.getCurrentChainId,\n    });\n    this._onBootCleanUp();\n\n    this.store = this.txStateManager.store;\n    this.nonceTracker = new NonceTracker({\n      provider: this.provider,\n      blockTracker: this.blockTracker,\n      getPendingTransactions: (...args) => {\n        const pendingTransactions = this.txStateManager.getPendingTransactions(\n          ...args,\n        );\n        const externalPendingTransactions = opts.getExternalPendingTransactions(\n          ...args,\n        );\n        return [...pendingTransactions, ...externalPendingTransactions];\n      },\n      getConfirmedTransactions: this.txStateManager.getConfirmedTransactions.bind(\n        this.txStateManager,\n      ),\n    });\n\n    this.pendingTxTracker = new PendingTransactionTracker({\n      provider: this.provider,\n      nonceTracker: this.nonceTracker,\n      publishTransaction: (rawTx) => this.query.sendRawTransaction(rawTx),\n      getPendingTransactions: () => {\n        const pending = this.txStateManager.getPendingTransactions();\n        const approved = this.txStateManager.getApprovedTransactions();\n        return [...pending, ...approved];\n      },\n      approveTransaction: this.approveTransaction.bind(this),\n      getCompletedTransactions: this.txStateManager.getConfirmedTransactions.bind(\n        this.txStateManager,\n      ),\n    });\n\n    this.txStateManager.store.subscribe(() =>\n      this.emit(METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE),\n    );\n    this._setupListeners();\n    // memstore is computed from a few different stores\n    this._updateMemstore();\n    this.txStateManager.store.subscribe(() => this._updateMemstore());\n    this.networkStore.subscribe(() => {\n      this._onBootCleanUp();\n      this._updateMemstore();\n    });\n\n    // request state update to finalize initialization\n    this._updatePendingTxsAfterFirstBlock();\n  }\n\n  /**\n   * Gets the current chainId in the network store as a number, returning 0 if\n   * the chainId parses to NaN.\n   *\n   * @returns {number} The numerical chainId.\n   */\n  getChainId() {\n    const networkState = this.networkStore.getState();\n    const chainId = this._getCurrentChainId();\n    const integerChainId = parseInt(chainId, 16);\n    if (networkState === 'loading' || Number.isNaN(integerChainId)) {\n      return 0;\n    }\n    return integerChainId;\n  }\n\n  async getEIP1559Compatibility(fromAddress) {\n    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();\n    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(\n      fromAddress,\n    );\n    return currentNetworkIsCompatible && fromAccountIsCompatible;\n  }\n\n  /**\n   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for\n   * specifying which chain, network, hardfork and EIPs to support for\n   * a transaction. By referencing this configuration, and analyzing the fields\n   * specified in txParams, `@ethereumjs/tx` is able to determine which EIP-2718\n   * transaction type to use.\n   *\n   * @param fromAddress\n   * @returns {Common} common configuration object\n   */\n  async getCommonConfiguration(fromAddress) {\n    const { type, nickname: name } = this.getProviderConfig();\n    const supportsEIP1559 = await this.getEIP1559Compatibility(fromAddress);\n\n    // This logic below will have to be updated each time a hardfork happens\n    // that carries with it a new Transaction type. It is inconsequential for\n    // hardforks that do not include new types.\n    const hardfork = supportsEIP1559 ? HARDFORKS.LONDON : HARDFORKS.BERLIN;\n\n    // type will be one of our default network names or 'rpc'. the default\n    // network names are sufficient configuration, simply pass the name as the\n    // chain argument in the constructor.\n    if (type !== NETWORK_TYPE_RPC) {\n      return new Common({\n        chain: type,\n        hardfork,\n      });\n    }\n\n    // For 'rpc' we need to use the same basic configuration as mainnet,\n    // since we only support EVM compatible chains, and then override the\n    // name, chainId and networkId properties. This is done using the\n    // `forCustomChain` static method on the Common class.\n    const chainId = parseInt(this._getCurrentChainId(), 16);\n    const networkId = this.networkStore.getState();\n\n    const customChainParams = {\n      name,\n      chainId,\n      // It is improbable for a transaction to be signed while the network\n      // is loading for two reasons.\n      // 1. Pending, unconfirmed transactions are wiped on network change\n      // 2. The UI is unusable (loading indicator) when network is loading.\n      // setting the networkId to 0 is for type safety and to explicity lead\n      // the transaction to failing if a user is able to get to this branch\n      // on a custom network that requires valid network id. I have not ran\n      // into this limitation on any network I have attempted, even when\n      // hardcoding networkId to 'loading'.\n      networkId: networkId === 'loading' ? 0 : parseInt(networkId, 10),\n    };\n\n    return Common.forCustomChain(MAINNET, customChainParams, hardfork);\n  }\n\n  /**\n   * Adds a tx to the txlist\n   *\n   * @param txMeta\n   * @fires ${txMeta.id}:unapproved\n   */\n  addTransaction(txMeta) {\n    this.txStateManager.addTransaction(txMeta);\n    this.emit(`${txMeta.id}:unapproved`, txMeta);\n    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.ADDED);\n  }\n\n  /**\n   * Wipes the transactions for a given account\n   *\n   * @param {string} address - hex string of the from address for txs being removed\n   */\n  wipeTransactions(address) {\n    this.txStateManager.wipeTransactions(address);\n  }\n\n  /**\n   * Add a new unapproved transaction to the pipeline\n   *\n   * @returns {Promise<string>} the hash of the transaction after being submitted to the network\n   * @param {Object} txParams - txParams for the transaction\n   * @param {Object} opts - with the key origin to put the origin on the txMeta\n   */\n  async newUnapprovedTransaction(txParams, opts = {}) {\n    log.debug(\n      `MetaMaskController newUnapprovedTransaction ${JSON.stringify(txParams)}`,\n    );\n\n    const initialTxMeta = await this.addUnapprovedTransaction(\n      txParams,\n      opts.origin,\n    );\n\n    // listen for tx completion (success, fail)\n    return new Promise((resolve, reject) => {\n      this.txStateManager.once(\n        `${initialTxMeta.id}:finished`,\n        (finishedTxMeta) => {\n          switch (finishedTxMeta.status) {\n            case TRANSACTION_STATUSES.SUBMITTED:\n              return resolve(finishedTxMeta.hash);\n            case TRANSACTION_STATUSES.REJECTED:\n              return reject(\n                cleanErrorStack(\n                  ethErrors.provider.userRejectedRequest(\n                    'MetaMask Tx Signature: User denied transaction signature.',\n                  ),\n                ),\n              );\n            case TRANSACTION_STATUSES.FAILED:\n              return reject(\n                cleanErrorStack(\n                  ethErrors.rpc.internal(finishedTxMeta.err.message),\n                ),\n              );\n            default:\n              return reject(\n                cleanErrorStack(\n                  ethErrors.rpc.internal(\n                    `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(\n                      finishedTxMeta.txParams,\n                    )}`,\n                  ),\n                ),\n              );\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Validates and generates a txMeta with defaults and puts it in txStateManager\n   * store.\n   *\n   * @param txParams\n   * @param origin\n   * @param transactionType\n   * @returns {txMeta}\n   */\n  async addUnapprovedTransaction(txParams, origin, transactionType) {\n    if (\n      transactionType !== undefined &&\n      !SWAP_TRANSACTION_TYPES.includes(transactionType)\n    ) {\n      throw new Error(\n        `TransactionController - invalid transactionType value: ${transactionType}`,\n      );\n    }\n\n    // validate\n    const normalizedTxParams = txUtils.normalizeTxParams(txParams);\n    const eip1559Compatibility = await this.getEIP1559Compatibility();\n\n    txUtils.validateTxParams(normalizedTxParams, eip1559Compatibility);\n\n    /**\n     * `generateTxMeta` adds the default txMeta properties to the passed object.\n     * These include the tx's `id`. As we use the id for determining order of\n     * txes in the tx-state-manager, it is necessary to call the asynchronous\n     * method `this._determineTransactionType` after `generateTxMeta`.\n     */\n    let txMeta = this.txStateManager.generateTxMeta({\n      txParams: normalizedTxParams,\n      origin,\n    });\n\n    if (origin === 'metamask') {\n      // Assert the from address is the selected address\n      if (normalizedTxParams.from !== this.getSelectedAddress()) {\n        throw ethErrors.rpc.internal({\n          message: `Internally initiated transaction is using invalid account.`,\n          data: {\n            origin,\n            fromAddress: normalizedTxParams.from,\n            selectedAddress: this.getSelectedAddress(),\n          },\n        });\n      }\n    } else {\n      // Assert that the origin has permissions to initiate transactions from\n      // the specified address\n      const permittedAddresses = await this.getPermittedAccounts(origin);\n      if (!permittedAddresses.includes(normalizedTxParams.from)) {\n        throw ethErrors.provider.unauthorized({ data: { origin } });\n      }\n    }\n\n    const { type, getCodeResponse } = await this._determineTransactionType(\n      txParams,\n    );\n    txMeta.type = transactionType || type;\n\n    // ensure value\n    txMeta.txParams.value = txMeta.txParams.value\n      ? addHexPrefix(txMeta.txParams.value)\n      : '0x0';\n\n    this.addTransaction(txMeta);\n    this.emit('newUnapprovedTx', txMeta);\n\n    try {\n      txMeta = await this.addTxGasDefaults(txMeta, getCodeResponse);\n    } catch (error) {\n      log.warn(error);\n      txMeta = this.txStateManager.getTransaction(txMeta.id);\n      txMeta.loadingDefaults = false;\n      this.txStateManager.updateTransaction(\n        txMeta,\n        'Failed to calculate gas defaults.',\n      );\n      throw error;\n    }\n\n    txMeta.loadingDefaults = false;\n    // save txMeta\n    this.txStateManager.updateTransaction(\n      txMeta,\n      'Added new unapproved transaction.',\n    );\n\n    return txMeta;\n  }\n\n  /**\n   * Adds the tx gas defaults: gas && gasPrice\n   *\n   * @param {Object} txMeta - the txMeta object\n   * @param getCodeResponse\n   * @returns {Promise<object>} resolves with txMeta\n   */\n  async addTxGasDefaults(txMeta, getCodeResponse) {\n    const eip1559Compatibility =\n      txMeta.txParams.type !== TRANSACTION_ENVELOPE_TYPES.LEGACY &&\n      (await this.getEIP1559Compatibility());\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas,\n    } = await this._getDefaultGasFees(txMeta, eip1559Compatibility);\n    const {\n      gasLimit: defaultGasLimit,\n      simulationFails,\n    } = await this._getDefaultGasLimit(txMeta, getCodeResponse);\n\n    // eslint-disable-next-line no-param-reassign\n    txMeta = this.txStateManager.getTransaction(txMeta.id);\n    if (simulationFails) {\n      txMeta.simulationFails = simulationFails;\n    }\n\n    if (eip1559Compatibility) {\n      const { eip1559V2Enabled } = this.preferencesStore.getState();\n      const advancedGasFeeDefaultValues = this.getAdvancedGasFee();\n      if (\n        eip1559V2Enabled &&\n        Boolean(advancedGasFeeDefaultValues) &&\n        !SWAP_TRANSACTION_TYPES.includes(txMeta.type)\n      ) {\n        txMeta.userFeeLevel = CUSTOM_GAS_ESTIMATE;\n        txMeta.txParams.maxFeePerGas = decGWEIToHexWEI(\n          advancedGasFeeDefaultValues.maxBaseFee,\n        );\n        txMeta.txParams.maxPriorityFeePerGas = decGWEIToHexWEI(\n          advancedGasFeeDefaultValues.priorityFee,\n        );\n      } else if (\n        txMeta.txParams.gasPrice &&\n        !txMeta.txParams.maxFeePerGas &&\n        !txMeta.txParams.maxPriorityFeePerGas\n      ) {\n        // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n        //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n        txMeta.txParams.maxFeePerGas = txMeta.txParams.gasPrice;\n        txMeta.txParams.maxPriorityFeePerGas = txMeta.txParams.gasPrice;\n        if (eip1559V2Enabled && txMeta.origin !== 'metamask') {\n          txMeta.userFeeLevel = PRIORITY_LEVELS.DAPP_SUGGESTED;\n        } else {\n          txMeta.userFeeLevel = CUSTOM_GAS_ESTIMATE;\n        }\n      } else {\n        if (\n          (defaultMaxFeePerGas &&\n            defaultMaxPriorityFeePerGas &&\n            !txMeta.txParams.maxFeePerGas &&\n            !txMeta.txParams.maxPriorityFeePerGas) ||\n          txMeta.origin === 'metamask'\n        ) {\n          txMeta.userFeeLevel = GAS_RECOMMENDATIONS.MEDIUM;\n        } else if (eip1559V2Enabled) {\n          txMeta.userFeeLevel = PRIORITY_LEVELS.DAPP_SUGGESTED;\n        } else {\n          txMeta.userFeeLevel = CUSTOM_GAS_ESTIMATE;\n        }\n\n        if (defaultMaxFeePerGas && !txMeta.txParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          txMeta.txParams.maxFeePerGas = defaultMaxFeePerGas;\n        }\n\n        if (\n          defaultMaxPriorityFeePerGas &&\n          !txMeta.txParams.maxPriorityFeePerGas\n        ) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          txMeta.txParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n\n        if (defaultGasPrice && !txMeta.txParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          txMeta.txParams.maxFeePerGas = defaultGasPrice;\n        }\n\n        if (\n          txMeta.txParams.maxFeePerGas &&\n          !txMeta.txParams.maxPriorityFeePerGas\n        ) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available from the gasFeeController, then we set maxPriorityFeePerGas to\n          // txMeta.txParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          txMeta.txParams.maxPriorityFeePerGas = txMeta.txParams.maxFeePerGas;\n        }\n      }\n\n      // We remove the gasPrice param entirely when on an eip1559 compatible network\n\n      delete txMeta.txParams.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n\n      delete txMeta.txParams.maxPriorityFeePerGas;\n      delete txMeta.txParams.maxFeePerGas;\n    }\n\n    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n    if (\n      defaultGasPrice &&\n      !txMeta.txParams.gasPrice &&\n      !txMeta.txParams.maxPriorityFeePerGas &&\n      !txMeta.txParams.maxFeePerGas\n    ) {\n      txMeta.txParams.gasPrice = defaultGasPrice;\n    }\n\n    if (defaultGasLimit && !txMeta.txParams.gas) {\n      txMeta.txParams.gas = defaultGasLimit;\n      txMeta.originalGasEstimate = defaultGasLimit;\n    }\n    txMeta.defaultGasEstimates = {\n      estimateType: txMeta.userFeeLevel,\n      gas: txMeta.txParams.gas,\n      gasPrice: txMeta.txParams.gasPrice,\n      maxFeePerGas: txMeta.txParams.maxFeePerGas,\n      maxPriorityFeePerGas: txMeta.txParams.maxPriorityFeePerGas,\n    };\n    return txMeta;\n  }\n\n  /**\n   * Gets default gas fees, or returns `undefined` if gas fees are already set\n   *\n   * @param {Object} txMeta - The txMeta object\n   * @param eip1559Compatibility\n   * @returns {Promise<string|undefined>} The default gas price\n   */\n  async _getDefaultGasFees(txMeta, eip1559Compatibility) {\n    if (\n      (!eip1559Compatibility && txMeta.txParams.gasPrice) ||\n      (eip1559Compatibility &&\n        txMeta.txParams.maxFeePerGas &&\n        txMeta.txParams.maxPriorityFeePerGas)\n    ) {\n      return {};\n    }\n\n    try {\n      const {\n        gasFeeEstimates,\n        gasEstimateType,\n      } = await this._getEIP1559GasFeeEstimates();\n      if (\n        eip1559Compatibility &&\n        gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET\n      ) {\n        const {\n          medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {},\n        } = gasFeeEstimates;\n\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            maxFeePerGas: decGWEIToHexWEI(suggestedMaxFeePerGas),\n            maxPriorityFeePerGas: decGWEIToHexWEI(\n              suggestedMaxPriorityFeePerGas,\n            ),\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: decGWEIToHexWEI(gasFeeEstimates.medium),\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: decGWEIToHexWEI(gasFeeEstimates.gasPrice),\n        };\n      }\n    } catch (e) {\n      console.error(e);\n    }\n\n    const gasPrice = await this.query.gasPrice();\n\n    return { gasPrice: gasPrice && addHexPrefix(gasPrice.toString(16)) };\n  }\n\n  /**\n   * Gets default gas limit, or debug information about why gas estimate failed.\n   *\n   * @param {Object} txMeta - The txMeta object\n   * @param {string} getCodeResponse - The transaction category code response, used for debugging purposes\n   * @returns {Promise<Object>} Object containing the default gas limit, or the simulation failure object\n   */\n  async _getDefaultGasLimit(txMeta, getCodeResponse) {\n    const chainId = this._getCurrentChainId();\n    const customNetworkGasBuffer = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];\n    const chainType = getChainType(chainId);\n\n    if (txMeta.txParams.gas) {\n      return {};\n    } else if (\n      txMeta.txParams.to &&\n      txMeta.type === TRANSACTION_TYPES.SIMPLE_SEND &&\n      chainType !== 'custom'\n    ) {\n      // if there's data in the params, but there's no contract code, it's not a valid transaction\n      if (txMeta.txParams.data) {\n        const err = new Error(\n          'TxGasUtil - Trying to call a function on a non-contract address',\n        );\n        // set error key so ui can display localized error message\n        err.errorKey = TRANSACTION_NO_CONTRACT_ERROR_KEY;\n\n        // set the response on the error so that we can see in logs what the actual response was\n        err.getCodeResponse = getCodeResponse;\n        throw err;\n      }\n\n      // This is a standard ether simple send, gas requirement is exactly 21k\n      return { gasLimit: GAS_LIMITS.SIMPLE };\n    }\n\n    const {\n      blockGasLimit,\n      estimatedGasHex,\n      simulationFails,\n    } = await this.txGasUtil.analyzeGasUsage(txMeta);\n\n    // add additional gas buffer to our estimation for safety\n    const gasLimit = this.txGasUtil.addGasBuffer(\n      addHexPrefix(estimatedGasHex),\n      blockGasLimit,\n      customNetworkGasBuffer,\n    );\n    return { gasLimit, simulationFails };\n  }\n\n  /**\n   * Given a TransactionMeta object, generate new gas params such that if the\n   * transaction was an EIP1559 transaction, it only has EIP1559 gas fields,\n   * otherwise it only has gasPrice. Will use whatever custom values are\n   * specified in customGasSettings, or falls back to incrementing by a percent\n   * which is defined by specifying a numerator. 11 is a 10% bump, 12 would be\n   * a 20% bump, and so on.\n   *\n   * @param {TransactionMeta} originalTxMeta - Original transaction to use as\n   *  base\n   * @param {CustomGasSettings} [customGasSettings] - overrides for the gas\n   *  fields to use instead of the multiplier\n   * @param {number} [incrementNumerator] - Numerator from which to generate a\n   *  percentage bump of gas price. E.g 11 would be a 10% bump over base.\n   * @returns {{ newGasParams: CustomGasSettings, previousGasParams: CustomGasSettings }}\n   */\n  generateNewGasParams(\n    originalTxMeta,\n    customGasSettings = {},\n    incrementNumerator = 11,\n  ) {\n    const { txParams } = originalTxMeta;\n    const previousGasParams = {};\n    const newGasParams = {};\n    if (customGasSettings.gasLimit) {\n      newGasParams.gas = customGasSettings?.gas ?? GAS_LIMITS.SIMPLE;\n    }\n\n    if (customGasSettings.estimateSuggested) {\n      newGasParams.estimateSuggested = customGasSettings.estimateSuggested;\n    }\n\n    if (customGasSettings.estimateUsed) {\n      newGasParams.estimateUsed = customGasSettings.estimateUsed;\n    }\n\n    if (isEIP1559Transaction(originalTxMeta)) {\n      previousGasParams.maxFeePerGas = txParams.maxFeePerGas;\n      previousGasParams.maxPriorityFeePerGas = txParams.maxPriorityFeePerGas;\n      newGasParams.maxFeePerGas =\n        customGasSettings?.maxFeePerGas ||\n        bnToHex(\n          BnMultiplyByFraction(\n            hexToBn(txParams.maxFeePerGas),\n            incrementNumerator,\n            10,\n          ),\n        );\n      newGasParams.maxPriorityFeePerGas =\n        customGasSettings?.maxPriorityFeePerGas ||\n        bnToHex(\n          BnMultiplyByFraction(\n            hexToBn(txParams.maxPriorityFeePerGas),\n            incrementNumerator,\n            10,\n          ),\n        );\n    } else {\n      previousGasParams.gasPrice = txParams.gasPrice;\n      newGasParams.gasPrice =\n        customGasSettings?.gasPrice ||\n        bnToHex(\n          BnMultiplyByFraction(\n            hexToBn(txParams.gasPrice),\n            incrementNumerator,\n            10,\n          ),\n        );\n    }\n\n    return { previousGasParams, newGasParams };\n  }\n\n  /**\n   * Creates a new approved transaction to attempt to cancel a previously submitted transaction. The\n   * new transaction contains the same nonce as the previous, is a basic ETH transfer of 0x value to\n   * the sender's address, and has a higher gasPrice than that of the previous transaction.\n   *\n   * @param {number} originalTxId - the id of the txMeta that you want to attempt to cancel\n   * @param {CustomGasSettings} [customGasSettings] - overrides to use for gas\n   *  params instead of allowing this method to generate them\n   * @param options\n   * @param options.estimatedBaseFee\n   * @returns {txMeta}\n   */\n  async createCancelTransaction(\n    originalTxId,\n    customGasSettings,\n    { estimatedBaseFee } = {},\n  ) {\n    const originalTxMeta = this.txStateManager.getTransaction(originalTxId);\n    const { txParams } = originalTxMeta;\n    const { from, nonce } = txParams;\n\n    const { previousGasParams, newGasParams } = this.generateNewGasParams(\n      originalTxMeta,\n      {\n        ...customGasSettings,\n        // We want to override the previous transactions gasLimit because it\n        // will now be a simple send instead of whatever it was before such\n        // as a token transfer or contract call.\n        gasLimit: customGasSettings.gasLimit || GAS_LIMITS.SIMPLE,\n      },\n    );\n\n    const newTxMeta = this.txStateManager.generateTxMeta({\n      txParams: {\n        from,\n        to: from,\n        nonce,\n        value: '0x0',\n        ...newGasParams,\n      },\n      previousGasParams,\n      loadingDefaults: false,\n      status: TRANSACTION_STATUSES.APPROVED,\n      type: TRANSACTION_TYPES.CANCEL,\n    });\n\n    if (estimatedBaseFee) {\n      newTxMeta.estimatedBaseFee = estimatedBaseFee;\n    }\n\n    this.addTransaction(newTxMeta);\n    await this.approveTransaction(newTxMeta.id);\n    return newTxMeta;\n  }\n\n  /**\n   * Creates a new approved transaction to attempt to speed up a previously submitted transaction. The\n   * new transaction contains the same nonce as the previous. By default, the new transaction will use\n   * the same gas limit and a 10% higher gas price, though it is possible to set a custom value for\n   * each instead.\n   *\n   * @param {number} originalTxId - the id of the txMeta that you want to speed up\n   * @param {CustomGasSettings} [customGasSettings] - overrides to use for gas\n   *  params instead of allowing this method to generate them\n   * @param options\n   * @param options.estimatedBaseFee\n   * @returns {txMeta}\n   */\n  async createSpeedUpTransaction(\n    originalTxId,\n    customGasSettings,\n    { estimatedBaseFee } = {},\n  ) {\n    const originalTxMeta = this.txStateManager.getTransaction(originalTxId);\n    const { txParams } = originalTxMeta;\n\n    const { previousGasParams, newGasParams } = this.generateNewGasParams(\n      originalTxMeta,\n      customGasSettings,\n    );\n\n    const newTxMeta = this.txStateManager.generateTxMeta({\n      txParams: {\n        ...txParams,\n        ...newGasParams,\n      },\n      previousGasParams,\n      loadingDefaults: false,\n      status: TRANSACTION_STATUSES.APPROVED,\n      type: TRANSACTION_TYPES.RETRY,\n    });\n\n    if (estimatedBaseFee) {\n      newTxMeta.estimatedBaseFee = estimatedBaseFee;\n    }\n\n    this.addTransaction(newTxMeta);\n    await this.approveTransaction(newTxMeta.id);\n    return newTxMeta;\n  }\n\n  /**\n   * updates the txMeta in the txStateManager\n   *\n   * @param {Object} txMeta - the updated txMeta\n   */\n  async updateTransaction(txMeta) {\n    this.txStateManager.updateTransaction(\n      txMeta,\n      'confTx: user updated transaction',\n    );\n  }\n\n  /**\n   * updates and approves the transaction\n   *\n   * @param {Object} txMeta\n   */\n  async updateAndApproveTransaction(txMeta) {\n    this.txStateManager.updateTransaction(\n      txMeta,\n      'confTx: user approved transaction',\n    );\n    await this.approveTransaction(txMeta.id);\n  }\n\n  /**\n   * sets the tx status to approved\n   * auto fills the nonce\n   * signs the transaction\n   * publishes the transaction\n   * if any of these steps fails the tx status will be set to failed\n   *\n   * @param {number} txId - the tx's Id\n   */\n  async approveTransaction(txId) {\n    // TODO: Move this safety out of this function.\n    // Since this transaction is async,\n    // we need to keep track of what is currently being signed,\n    // So that we do not increment nonce + resubmit something\n    // that is already being incremented & signed.\n    if (this.inProcessOfSigning.has(txId)) {\n      return;\n    }\n    this.inProcessOfSigning.add(txId);\n    let nonceLock;\n    try {\n      // approve\n      this.txStateManager.setTxStatusApproved(txId);\n      // get next nonce\n      const txMeta = this.txStateManager.getTransaction(txId);\n\n      const fromAddress = txMeta.txParams.from;\n      // wait for a nonce\n      let { customNonceValue } = txMeta;\n      customNonceValue = Number(customNonceValue);\n      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);\n      // add nonce to txParams\n      // if txMeta has previousGasParams then it is a retry at same nonce with\n      // higher gas settings and therefor the nonce should not be recalculated\n      const nonce = txMeta.previousGasParams\n        ? txMeta.txParams.nonce\n        : nonceLock.nextNonce;\n      const customOrNonce =\n        customNonceValue === 0 ? customNonceValue : customNonceValue || nonce;\n\n      txMeta.txParams.nonce = addHexPrefix(customOrNonce.toString(16));\n      // add nonce debugging information to txMeta\n      txMeta.nonceDetails = nonceLock.nonceDetails;\n      if (customNonceValue) {\n        txMeta.nonceDetails.customNonceValue = customNonceValue;\n      }\n      this.txStateManager.updateTransaction(\n        txMeta,\n        'transactions#approveTransaction',\n      );\n      // sign transaction\n      const rawTx = await this.signTransaction(txId);\n      await this.publishTransaction(txId, rawTx);\n      this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.APPROVED);\n      // must set transaction to submitted/failed before releasing lock\n      nonceLock.releaseLock();\n    } catch (err) {\n      // this is try-catch wrapped so that we can guarantee that the nonceLock is released\n      try {\n        this._failTransaction(txId, err);\n      } catch (err2) {\n        log.error(err2);\n      }\n      // must set transaction to submitted/failed before releasing lock\n      if (nonceLock) {\n        nonceLock.releaseLock();\n      }\n      // continue with error chain\n      throw err;\n    } finally {\n      this.inProcessOfSigning.delete(txId);\n    }\n  }\n\n  async approveTransactionsWithSameNonce(listOfTxParams = []) {\n    if (listOfTxParams.length === 0) {\n      return '';\n    }\n\n    const initialTx = listOfTxParams[0];\n    const common = await this.getCommonConfiguration(initialTx.from);\n    const initialTxAsEthTx = TransactionFactory.fromTxData(initialTx, {\n      common,\n    });\n    const initialTxAsSerializedHex = bufferToHex(initialTxAsEthTx.serialize());\n\n    if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {\n      return '';\n    }\n    this.inProcessOfSigning.add(initialTxAsSerializedHex);\n    let rawTxes, nonceLock;\n    try {\n      // TODO: we should add a check to verify that all transactions have the same from address\n      const fromAddress = initialTx.from;\n      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);\n      const nonce = nonceLock.nextNonce;\n\n      rawTxes = await Promise.all(\n        listOfTxParams.map((txParams) => {\n          txParams.nonce = addHexPrefix(nonce.toString(16));\n          return this.signExternalTransaction(txParams);\n        }),\n      );\n    } catch (err) {\n      log.error(err);\n      // must set transaction to submitted/failed before releasing lock\n      // continue with error chain\n      throw err;\n    } finally {\n      if (nonceLock) {\n        nonceLock.releaseLock();\n      }\n      this.inProcessOfSigning.delete(initialTxAsSerializedHex);\n    }\n    return rawTxes;\n  }\n\n  async signExternalTransaction(_txParams) {\n    const normalizedTxParams = txUtils.normalizeTxParams(_txParams);\n    // add network/chain id\n    const chainId = this.getChainId();\n    const type = isEIP1559Transaction({ txParams: normalizedTxParams })\n      ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET\n      : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    const txParams = {\n      ...normalizedTxParams,\n      type,\n      gasLimit: normalizedTxParams.gas,\n      chainId: addHexPrefix(decimalToHex(chainId)),\n    };\n    // sign tx\n    const fromAddress = txParams.from;\n    const common = await this.getCommonConfiguration(fromAddress);\n    const unsignedEthTx = TransactionFactory.fromTxData(txParams, { common });\n    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress);\n\n    const rawTx = bufferToHex(signedEthTx.serialize());\n    return rawTx;\n  }\n\n  /**\n   * adds the chain id and signs the transaction and set the status to signed\n   *\n   * @param {number} txId - the tx's Id\n   * @returns {string} rawTx\n   */\n  async signTransaction(txId) {\n    const txMeta = this.txStateManager.getTransaction(txId);\n    // add network/chain id\n    const chainId = this.getChainId();\n    const type = isEIP1559Transaction(txMeta)\n      ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET\n      : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    const txParams = {\n      ...txMeta.txParams,\n      type,\n      chainId,\n      gasLimit: txMeta.txParams.gas,\n    };\n    // sign tx\n    const fromAddress = txParams.from;\n    const common = await this.getCommonConfiguration(txParams.from);\n    const unsignedEthTx = TransactionFactory.fromTxData(txParams, { common });\n    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress);\n\n    // add r,s,v values for provider request purposes see createMetamaskMiddleware\n    // and JSON rpc standard for further explanation\n    txMeta.r = bufferToHex(signedEthTx.r);\n    txMeta.s = bufferToHex(signedEthTx.s);\n    txMeta.v = bufferToHex(signedEthTx.v);\n\n    this.txStateManager.updateTransaction(\n      txMeta,\n      'transactions#signTransaction: add r, s, v values',\n    );\n\n    // set state to signed\n    this.txStateManager.setTxStatusSigned(txMeta.id);\n    const rawTx = bufferToHex(signedEthTx.serialize());\n    return rawTx;\n  }\n\n  /**\n   * publishes the raw tx and sets the txMeta to submitted\n   *\n   * @param {number} txId - the tx's Id\n   * @param {string} rawTx - the hex string of the serialized signed transaction\n   * @returns {Promise<void>}\n   */\n  async publishTransaction(txId, rawTx) {\n    const txMeta = this.txStateManager.getTransaction(txId);\n    txMeta.rawTx = rawTx;\n    if (txMeta.type === TRANSACTION_TYPES.SWAP) {\n      const preTxBalance = await this.query.getBalance(txMeta.txParams.from);\n      txMeta.preTxBalance = preTxBalance.toString(16);\n    }\n    this.txStateManager.updateTransaction(\n      txMeta,\n      'transactions#publishTransaction',\n    );\n    let txHash;\n    try {\n      txHash = await this.query.sendRawTransaction(rawTx);\n    } catch (error) {\n      if (error.message.toLowerCase().includes('known transaction')) {\n        txHash = keccak(toBuffer(addHexPrefix(rawTx), 'hex')).toString('hex');\n        txHash = addHexPrefix(txHash);\n      } else {\n        throw error;\n      }\n    }\n    this.setTxHash(txId, txHash);\n\n    this.txStateManager.setTxStatusSubmitted(txId);\n\n    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.SUBMITTED);\n  }\n\n  /**\n   * Sets the status of the transaction to confirmed and sets the status of nonce duplicates as\n   * dropped if the txParams have data it will fetch the txReceipt\n   *\n   * @param {number} txId - The tx's ID\n   * @param txReceipt\n   * @param baseFeePerGas\n   * @param blockTimestamp\n   * @returns {Promise<void>}\n   */\n  async confirmTransaction(txId, txReceipt, baseFeePerGas, blockTimestamp) {\n    // get the txReceipt before marking the transaction confirmed\n    // to ensure the receipt is gotten before the ui revives the tx\n    const txMeta = this.txStateManager.getTransaction(txId);\n\n    if (!txMeta) {\n      return;\n    }\n\n    try {\n      const gasUsed = txUtils.normalizeTxReceiptGasUsed(txReceipt.gasUsed);\n\n      txMeta.txReceipt = {\n        ...txReceipt,\n        gasUsed,\n      };\n\n      if (baseFeePerGas) {\n        txMeta.baseFeePerGas = baseFeePerGas;\n      }\n      if (blockTimestamp) {\n        txMeta.blockTimestamp = blockTimestamp;\n      }\n\n      this.txStateManager.setTxStatusConfirmed(txId);\n      this._markNonceDuplicatesDropped(txId);\n\n      const { submittedTime } = txMeta;\n      const metricsParams = { gas_used: gasUsed };\n\n      if (submittedTime) {\n        metricsParams.completion_time = this._getTransactionCompletionTime(\n          submittedTime,\n        );\n      }\n\n      if (txReceipt.status === '0x0') {\n        metricsParams.status = METRICS_STATUS_FAILED;\n        // metricsParams.error = TODO: figure out a way to get the on-chain failure reason\n      }\n\n      this._trackTransactionMetricsEvent(\n        txMeta,\n        TRANSACTION_EVENTS.FINALIZED,\n        metricsParams,\n      );\n\n      this.txStateManager.updateTransaction(\n        txMeta,\n        'transactions#confirmTransaction - add txReceipt',\n      );\n\n      if (txMeta.type === TRANSACTION_TYPES.SWAP) {\n        const postTxBalance = await this.query.getBalance(txMeta.txParams.from);\n        const latestTxMeta = this.txStateManager.getTransaction(txId);\n\n        const approvalTxMeta = latestTxMeta.approvalTxId\n          ? this.txStateManager.getTransaction(latestTxMeta.approvalTxId)\n          : null;\n\n        latestTxMeta.postTxBalance = postTxBalance.toString(16);\n\n        this.txStateManager.updateTransaction(\n          latestTxMeta,\n          'transactions#confirmTransaction - add postTxBalance',\n        );\n\n        this._trackSwapsMetrics(latestTxMeta, approvalTxMeta);\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n  async confirmExternalTransaction(txMeta, txReceipt, baseFeePerGas) {\n    // add external transaction\n    await this.txStateManager.addExternalTransaction(txMeta);\n\n    if (!txMeta) {\n      return;\n    }\n\n    const txId = txMeta.id;\n\n    try {\n      const gasUsed = txUtils.normalizeTxReceiptGasUsed(txReceipt.gasUsed);\n\n      txMeta.txReceipt = {\n        ...txReceipt,\n        gasUsed,\n      };\n\n      if (baseFeePerGas) {\n        txMeta.baseFeePerGas = baseFeePerGas;\n      }\n\n      this.txStateManager.setTxStatusConfirmed(txId);\n      this._markNonceDuplicatesDropped(txId);\n\n      const { submittedTime } = txMeta;\n      const metricsParams = { gas_used: gasUsed };\n\n      if (submittedTime) {\n        metricsParams.completion_time = this._getTransactionCompletionTime(\n          submittedTime,\n        );\n      }\n\n      if (txReceipt.status === '0x0') {\n        metricsParams.status = METRICS_STATUS_FAILED;\n        // metricsParams.error = TODO: figure out a way to get the on-chain failure reason\n      }\n\n      this._trackTransactionMetricsEvent(\n        txMeta,\n        TRANSACTION_EVENTS.FINALIZED,\n        metricsParams,\n      );\n\n      this.txStateManager.updateTransaction(\n        txMeta,\n        'transactions#confirmTransaction - add txReceipt',\n      );\n\n      if (txMeta.type === TRANSACTION_TYPES.SWAP) {\n        const postTxBalance = await this.query.getBalance(txMeta.txParams.from);\n        const latestTxMeta = this.txStateManager.getTransaction(txId);\n\n        const approvalTxMeta = latestTxMeta.approvalTxId\n          ? this.txStateManager.getTransaction(latestTxMeta.approvalTxId)\n          : null;\n\n        latestTxMeta.postTxBalance = postTxBalance.toString(16);\n\n        this.txStateManager.updateTransaction(\n          latestTxMeta,\n          'transactions#confirmTransaction - add postTxBalance',\n        );\n\n        this._trackSwapsMetrics(latestTxMeta, approvalTxMeta);\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n  /**\n   * Convenience method for the ui thats sets the transaction to rejected\n   *\n   * @param {number} txId - the tx's Id\n   * @returns {Promise<void>}\n   */\n  async cancelTransaction(txId) {\n    const txMeta = this.txStateManager.getTransaction(txId);\n    this.txStateManager.setTxStatusRejected(txId);\n    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.REJECTED);\n  }\n\n  /**\n   * Sets the txHas on the txMeta\n   *\n   * @param {number} txId - the tx's Id\n   * @param {string} txHash - the hash for the txMeta\n   */\n  setTxHash(txId, txHash) {\n    // Add the tx hash to the persisted meta-tx object\n    const txMeta = this.txStateManager.getTransaction(txId);\n    txMeta.hash = txHash;\n    this.txStateManager.updateTransaction(txMeta, 'transactions#setTxHash');\n  }\n\n  /**\n   * Convenience method for the UI to easily create event fragments when the\n   * fragment does not exist in state.\n   *\n   * @param {number} transactionId - The transaction id to create the event\n   *  fragment for\n   * @param {valueOf<TRANSACTION_EVENTS>} event - event type to create\n   */\n  async createTransactionEventFragment(transactionId, event) {\n    const txMeta = this.txStateManager.getTransaction(transactionId);\n    const {\n      properties,\n      sensitiveProperties,\n    } = await this._buildEventFragmentProperties(txMeta);\n    this._createTransactionEventFragment(\n      txMeta,\n      event,\n      properties,\n      sensitiveProperties,\n    );\n  }\n\n  //\n  //           PRIVATE METHODS\n  //\n  /** maps methods for convenience*/\n  _mapMethods() {\n    /** @returns {Object} the state in transaction controller */\n    this.getState = () => this.memStore.getState();\n\n    /** @returns {string|number} the network number stored in networkStore */\n    this.getNetwork = () => this.networkStore.getState();\n\n    /** @returns {string} the user selected address */\n    this.getSelectedAddress = () =>\n      this.preferencesStore.getState().selectedAddress;\n\n    /** @returns {Array} transactions whos status is unapproved */\n    this.getUnapprovedTxCount = () =>\n      Object.keys(this.txStateManager.getUnapprovedTxList()).length;\n\n    /**\n     * @returns {number} number of transactions that have the status submitted\n     * @param {string} account - hex prefixed account\n     */\n    this.getPendingTxCount = (account) =>\n      this.txStateManager.getPendingTransactions(account).length;\n\n    /**\n     * see txStateManager\n     *\n     * @param opts\n     */\n    this.getTransactions = (opts) => this.txStateManager.getTransactions(opts);\n\n    /** @returns {object} the saved default values for advancedGasFee */\n    this.getAdvancedGasFee = () =>\n      this.preferencesStore.getState().advancedGasFee;\n  }\n\n  // called once on startup\n  async _updatePendingTxsAfterFirstBlock() {\n    // wait for first block so we know we're ready\n    await this.blockTracker.getLatestBlock();\n    // get status update for all pending transactions (for the current network)\n    await this.pendingTxTracker.updatePendingTxs();\n  }\n\n  /**\n   * If transaction controller was rebooted with transactions that are uncompleted\n   * in steps of the transaction signing or user confirmation process it will either\n   * transition txMetas to a failed state or try to redo those tasks.\n   */\n\n  _onBootCleanUp() {\n    this.txStateManager\n      .getTransactions({\n        searchCriteria: {\n          status: TRANSACTION_STATUSES.UNAPPROVED,\n          loadingDefaults: true,\n        },\n      })\n      .forEach((tx) => {\n        this.addTxGasDefaults(tx)\n          .then((txMeta) => {\n            txMeta.loadingDefaults = false;\n            this.txStateManager.updateTransaction(\n              txMeta,\n              'transactions: gas estimation for tx on boot',\n            );\n          })\n          .catch((error) => {\n            const txMeta = this.txStateManager.getTransaction(tx.id);\n            txMeta.loadingDefaults = false;\n            this.txStateManager.updateTransaction(\n              txMeta,\n              'failed to estimate gas during boot cleanup.',\n            );\n            this._failTransaction(txMeta.id, error);\n          });\n      });\n\n    this.txStateManager\n      .getTransactions({\n        searchCriteria: {\n          status: TRANSACTION_STATUSES.APPROVED,\n        },\n      })\n      .forEach((txMeta) => {\n        const txSignError = new Error(\n          'Transaction found as \"approved\" during boot - possibly stuck during signing',\n        );\n        this._failTransaction(txMeta.id, txSignError);\n      });\n  }\n\n  /**\n   * is called in constructor applies the listeners for pendingTxTracker txStateManager\n   * and blockTracker\n   */\n  _setupListeners() {\n    this.txStateManager.on(\n      'tx:status-update',\n      this.emit.bind(this, 'tx:status-update'),\n    );\n    this._setupBlockTrackerListener();\n    this.pendingTxTracker.on('tx:warning', (txMeta) => {\n      this.txStateManager.updateTransaction(\n        txMeta,\n        'transactions/pending-tx-tracker#event: tx:warning',\n      );\n    });\n    this.pendingTxTracker.on('tx:failed', (txId, error) => {\n      this._failTransaction(txId, error);\n    });\n    this.pendingTxTracker.on(\n      'tx:confirmed',\n      (txId, transactionReceipt, baseFeePerGas, blockTimestamp) =>\n        this.confirmTransaction(\n          txId,\n          transactionReceipt,\n          baseFeePerGas,\n          blockTimestamp,\n        ),\n    );\n    this.pendingTxTracker.on('tx:dropped', (txId) => {\n      this._dropTransaction(txId);\n    });\n    this.pendingTxTracker.on('tx:block-update', (txMeta, latestBlockNumber) => {\n      if (!txMeta.firstRetryBlockNumber) {\n        txMeta.firstRetryBlockNumber = latestBlockNumber;\n        this.txStateManager.updateTransaction(\n          txMeta,\n          'transactions/pending-tx-tracker#event: tx:block-update',\n        );\n      }\n    });\n    this.pendingTxTracker.on('tx:retry', (txMeta) => {\n      if (!('retryCount' in txMeta)) {\n        txMeta.retryCount = 0;\n      }\n      txMeta.retryCount += 1;\n      this.txStateManager.updateTransaction(\n        txMeta,\n        'transactions/pending-tx-tracker#event: tx:retry',\n      );\n    });\n  }\n\n  /**\n   * @typedef { 'transfer' | 'approve' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes\n   */\n\n  /**\n   * @typedef {Object} InferTransactionTypeResult\n   * @property {InferrableTransactionTypes} type - The type of transaction\n   * @property {string} getCodeResponse - The contract code, in hex format if\n   *  it exists. '0x0' or '0x' are also indicators of non-existent contract\n   *  code\n   */\n\n  /**\n   * Determines the type of the transaction by analyzing the txParams.\n   * This method will return one of the types defined in shared/constants/transactions\n   * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these\n   * represent specific events that we control from the extension and are added manually\n   * at transaction creation.\n   *\n   * @param {Object} txParams - Parameters for the transaction\n   * @returns {InferTransactionTypeResult}\n   */\n  async _determineTransactionType(txParams) {\n    const { data, to } = txParams;\n    let name;\n    try {\n      name = data && hstInterface.parseTransaction({ data }).name;\n    } catch (error) {\n      log.debug('Failed to parse transaction data.', error, data);\n    }\n\n    const tokenMethodName = [\n      TRANSACTION_TYPES.TOKEN_METHOD_APPROVE,\n      TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER,\n      TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM,\n    ].find((methodName) => isEqualCaseInsensitive(methodName, name));\n\n    let result;\n    if (data && tokenMethodName) {\n      result = tokenMethodName;\n    } else if (data && !to) {\n      result = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n    }\n\n    let contractCode;\n\n    if (!result) {\n      const {\n        contractCode: resultCode,\n        isContractAddress,\n      } = await readAddressAsContract(this.query, to);\n\n      contractCode = resultCode;\n      result = isContractAddress\n        ? TRANSACTION_TYPES.CONTRACT_INTERACTION\n        : TRANSACTION_TYPES.SIMPLE_SEND;\n    }\n\n    return { type: result, getCodeResponse: contractCode };\n  }\n\n  /**\n   * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions\n   * in the list have the same nonce\n   *\n   * @param {number} txId - the txId of the transaction that has been confirmed in a block\n   */\n  _markNonceDuplicatesDropped(txId) {\n    // get the confirmed transactions nonce and from address\n    const txMeta = this.txStateManager.getTransaction(txId);\n    const { nonce, from } = txMeta.txParams;\n    const sameNonceTxs = this.txStateManager.getTransactions({\n      searchCriteria: { nonce, from },\n    });\n    if (!sameNonceTxs.length) {\n      return;\n    }\n    // mark all same nonce transactions as dropped and give i a replacedBy hash\n    sameNonceTxs.forEach((otherTxMeta) => {\n      if (otherTxMeta.id === txId) {\n        return;\n      }\n      otherTxMeta.replacedBy = txMeta.hash;\n      this.txStateManager.updateTransaction(\n        txMeta,\n        'transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce',\n      );\n      this._dropTransaction(otherTxMeta.id);\n    });\n  }\n\n  _setupBlockTrackerListener() {\n    let listenersAreActive = false;\n    const latestBlockHandler = this._onLatestBlock.bind(this);\n    const { blockTracker, txStateManager } = this;\n\n    txStateManager.on('tx:status-update', updateSubscription);\n    updateSubscription();\n\n    function updateSubscription() {\n      const pendingTxs = txStateManager.getPendingTransactions();\n      if (!listenersAreActive && pendingTxs.length > 0) {\n        blockTracker.on('latest', latestBlockHandler);\n        listenersAreActive = true;\n      } else if (listenersAreActive && !pendingTxs.length) {\n        blockTracker.removeListener('latest', latestBlockHandler);\n        listenersAreActive = false;\n      }\n    }\n  }\n\n  async _onLatestBlock(blockNumber) {\n    try {\n      await this.pendingTxTracker.updatePendingTxs();\n    } catch (err) {\n      log.error(err);\n    }\n    try {\n      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n  /**\n   * Updates the memStore in transaction controller\n   */\n  _updateMemstore() {\n    const unapprovedTxs = this.txStateManager.getUnapprovedTxList();\n    const currentNetworkTxList = this.txStateManager.getTransactions({\n      limit: MAX_MEMSTORE_TX_LIST_SIZE,\n    });\n    this.memStore.updateState({ unapprovedTxs, currentNetworkTxList });\n  }\n\n  _trackSwapsMetrics(txMeta, approvalTxMeta) {\n    if (this._getParticipateInMetrics() && txMeta.swapMetaData) {\n      if (txMeta.txReceipt.status === '0x0') {\n        this._trackMetaMetricsEvent({\n          event: 'Swap Failed',\n          sensitiveProperties: { ...txMeta.swapMetaData },\n          category: 'swaps',\n        });\n      } else {\n        const tokensReceived = getSwapsTokensReceivedFromTxMeta(\n          txMeta.destinationTokenSymbol,\n          txMeta,\n          txMeta.destinationTokenAddress,\n          txMeta.txParams.from,\n          txMeta.destinationTokenDecimals,\n          approvalTxMeta,\n          txMeta.chainId,\n        );\n\n        const quoteVsExecutionRatio = tokensReceived\n          ? `${new BigNumber(tokensReceived, 10)\n              .div(txMeta.swapMetaData.token_to_amount, 10)\n              .times(100)\n              .round(2)}%`\n          : null;\n\n        const estimatedVsUsedGasRatio =\n          txMeta.txReceipt.gasUsed && txMeta.swapMetaData.estimated_gas\n            ? `${new BigNumber(txMeta.txReceipt.gasUsed, 16)\n                .div(txMeta.swapMetaData.estimated_gas, 10)\n                .times(100)\n                .round(2)}%`\n            : null;\n\n        this._trackMetaMetricsEvent({\n          event: 'Swap Completed',\n          category: 'swaps',\n          sensitiveProperties: {\n            ...txMeta.swapMetaData,\n            token_to_amount_received: tokensReceived,\n            quote_vs_executionRatio: quoteVsExecutionRatio,\n            estimated_vs_used_gasRatio: estimatedVsUsedGasRatio,\n          },\n        });\n      }\n    }\n  }\n\n  async _buildEventFragmentProperties(txMeta, extraParams) {\n    const {\n      type,\n      time,\n      status,\n      chainId,\n      origin: referrer,\n      txParams: {\n        gasPrice,\n        gas: gasLimit,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        estimateSuggested,\n        estimateUsed,\n      },\n      defaultGasEstimates,\n      metamaskNetworkId: network,\n    } = txMeta;\n    const source = referrer === 'metamask' ? 'user' : 'dapp';\n\n    const gasParams = {};\n\n    if (isEIP1559Transaction(txMeta)) {\n      gasParams.max_fee_per_gas = maxFeePerGas;\n      gasParams.max_priority_fee_per_gas = maxPriorityFeePerGas;\n    } else {\n      gasParams.gas_price = gasPrice;\n    }\n\n    if (defaultGasEstimates) {\n      const { estimateType } = defaultGasEstimates;\n      if (estimateType) {\n        gasParams.default_estimate = estimateType;\n        let defaultMaxFeePerGas = txMeta.defaultGasEstimates.maxFeePerGas;\n        let defaultMaxPriorityFeePerGas =\n          txMeta.defaultGasEstimates.maxPriorityFeePerGas;\n\n        if (\n          [\n            GAS_RECOMMENDATIONS.LOW,\n            GAS_RECOMMENDATIONS.MEDIUM,\n            GAS_RECOMMENDATIONS.MEDIUM.HIGH,\n          ].includes(estimateType)\n        ) {\n          const { gasFeeEstimates } = await this._getEIP1559GasFeeEstimates();\n          if (gasFeeEstimates?.[estimateType]?.suggestedMaxFeePerGas) {\n            defaultMaxFeePerGas =\n              gasFeeEstimates[estimateType]?.suggestedMaxFeePerGas;\n            gasParams.default_max_fee_per_gas = defaultMaxFeePerGas;\n          }\n          if (gasFeeEstimates?.[estimateType]?.suggestedMaxPriorityFeePerGas) {\n            defaultMaxPriorityFeePerGas =\n              gasFeeEstimates[estimateType]?.suggestedMaxPriorityFeePerGas;\n            gasParams.default_max_priority_fee_per_gas = defaultMaxPriorityFeePerGas;\n          }\n        }\n      }\n\n      if (txMeta.defaultGasEstimates.gas) {\n        gasParams.default_gas = txMeta.defaultGasEstimates.gas;\n      }\n      if (txMeta.defaultGasEstimates.gasPrice) {\n        gasParams.default_gas_price = txMeta.defaultGasEstimates.gasPrice;\n      }\n    }\n\n    if (estimateSuggested) {\n      gasParams.estimate_suggested = estimateSuggested;\n    }\n\n    if (estimateUsed) {\n      gasParams.estimate_used = estimateUsed;\n    }\n\n    const gasParamsInGwei = this._getGasValuesInGWEI(gasParams);\n\n    let eip1559Version = '0';\n    if (txMeta.txParams.maxFeePerGas) {\n      const { eip1559V2Enabled } = this.preferencesStore.getState();\n      eip1559Version = eip1559V2Enabled ? '2' : '1';\n    }\n\n    const properties = {\n      chain_id: chainId,\n      referrer,\n      source,\n      network,\n      type,\n      eip_1559_version: eip1559Version,\n      gas_edit_type: 'none',\n      gas_edit_attempted: 'none',\n    };\n\n    const sensitiveProperties = {\n      status,\n      transaction_envelope_type: isEIP1559Transaction(txMeta)\n        ? TRANSACTION_ENVELOPE_TYPE_NAMES.FEE_MARKET\n        : TRANSACTION_ENVELOPE_TYPE_NAMES.LEGACY,\n      first_seen: time,\n      gas_limit: gasLimit,\n      ...gasParamsInGwei,\n      ...extraParams,\n    };\n\n    return { properties, sensitiveProperties };\n  }\n\n  /**\n   * Helper method that checks for the presence of an existing fragment by id\n   * appropriate for the type of event that triggered fragment creation. If the\n   * appropriate fragment exists, then nothing is done. If it does not exist a\n   * new event fragment is created with the appropriate payload.\n   *\n   * @param {TransactionMeta} txMeta - Transaction meta object\n   * @param {TransactionMetaMetricsEventString} event - The event type that\n   *  triggered fragment creation\n   * @param {Object} properties - properties to include in the fragment\n   * @param {Object} [sensitiveProperties] - sensitive properties to include in\n   *  the fragment\n   */\n  _createTransactionEventFragment(\n    txMeta,\n    event,\n    properties,\n    sensitiveProperties,\n  ) {\n    const isSubmitted = [\n      TRANSACTION_EVENTS.FINALIZED,\n      TRANSACTION_EVENTS.SUBMITTED,\n    ].includes(event);\n    const uniqueIdentifier = `transaction-${\n      isSubmitted ? 'submitted' : 'added'\n    }-${txMeta.id}`;\n\n    const fragment = this.getEventFragmentById(uniqueIdentifier);\n    if (typeof fragment !== 'undefined') {\n      return;\n    }\n\n    switch (event) {\n      // When a transaction is added to the controller, we know that the user\n      // will be presented with a confirmation screen. The user will then\n      // either confirm or reject that transaction. Each has an associated\n      // event we want to track. While we don't necessarily need an event\n      // fragment to model this, having one allows us to record additional\n      // properties onto the event from the UI. For example, when the user\n      // edits the transactions gas params we can record that property and\n      // then get analytics on the number of transactions in which gas edits\n      // occur.\n      case TRANSACTION_EVENTS.ADDED:\n        this.createEventFragment({\n          category: 'Transactions',\n          initialEvent: TRANSACTION_EVENTS.ADDED,\n          successEvent: TRANSACTION_EVENTS.APPROVED,\n          failureEvent: TRANSACTION_EVENTS.REJECTED,\n          properties,\n          sensitiveProperties,\n          persist: true,\n          uniqueIdentifier,\n        });\n        break;\n      // If for some reason an approval or rejection occurs without the added\n      // fragment existing in memory, we create the added fragment but without\n      // the initialEvent firing. This is to prevent possible duplication of\n      // events. A good example why this might occur is if the user had\n      // unapproved transactions in memory when updating to the version that\n      // includes this change. A migration would have also helped here but this\n      // implementation hardens against other possible bugs where a fragment\n      // does not exist.\n      case TRANSACTION_EVENTS.APPROVED:\n      case TRANSACTION_EVENTS.REJECTED:\n        this.createEventFragment({\n          category: 'Transactions',\n          successEvent: TRANSACTION_EVENTS.APPROVED,\n          failureEvent: TRANSACTION_EVENTS.REJECTED,\n          properties,\n          sensitiveProperties,\n          persist: true,\n          uniqueIdentifier,\n        });\n        break;\n      // When a transaction is submitted it will always result in updating\n      // to a finalized state (dropped, failed, confirmed) -- eventually.\n      // However having a fragment started at this stage allows augmenting\n      // analytics data with user interactions such as speeding up and\n      // canceling the transactions. From this controllers perspective a new\n      // transaction with a new id is generated for speed up and cancel\n      // transactions, but from the UI we could augment the previous ID with\n      // supplemental data to show user intent. Such as when they open the\n      // cancel UI but don't submit. We can record that this happened and add\n      // properties to the transaction event.\n      case TRANSACTION_EVENTS.SUBMITTED:\n        this.createEventFragment({\n          category: 'Transactions',\n          initialEvent: TRANSACTION_EVENTS.SUBMITTED,\n          successEvent: TRANSACTION_EVENTS.FINALIZED,\n          properties,\n          sensitiveProperties,\n          persist: true,\n          uniqueIdentifier,\n        });\n        break;\n      // If for some reason a transaction is finalized without the submitted\n      // fragment existing in memory, we create the submitted fragment but\n      // without the initialEvent firing. This is to prevent possible\n      // duplication of events. A good example why this might occur is if th\n      // user had pending transactions in memory when updating to the version\n      // that includes this change. A migration would have also helped here but\n      // this implementation hardens against other possible bugs where a\n      // fragment does not exist.\n      case TRANSACTION_EVENTS.FINALIZED:\n        this.createEventFragment({\n          category: 'Transactions',\n          successEvent: TRANSACTION_EVENTS.FINALIZED,\n          properties,\n          sensitiveProperties,\n          persist: true,\n          uniqueIdentifier,\n        });\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Extracts relevant properties from a transaction meta\n   * object and uses them to create and send metrics for various transaction\n   * events.\n   *\n   * @param {Object} txMeta - the txMeta object\n   * @param {TransactionMetaMetricsEventString} event - the name of the transaction event\n   * @param {Object} extraParams - optional props and values to include in sensitiveProperties\n   */\n  async _trackTransactionMetricsEvent(txMeta, event, extraParams = {}) {\n    if (!txMeta) {\n      return;\n    }\n    const {\n      properties,\n      sensitiveProperties,\n    } = await this._buildEventFragmentProperties(txMeta, extraParams);\n\n    // Create event fragments for event types that spawn fragments, and ensure\n    // existence of fragments for event types that act upon them.\n    this._createTransactionEventFragment(\n      txMeta,\n      event,\n      properties,\n      sensitiveProperties,\n    );\n\n    let id;\n\n    switch (event) {\n      // If the user approves a transaction, finalize the transaction added\n      // event fragment.\n      case TRANSACTION_EVENTS.APPROVED:\n        id = `transaction-added-${txMeta.id}`;\n        this.updateEventFragment(id, { properties, sensitiveProperties });\n        this.finalizeEventFragment(id);\n        break;\n      // If the user rejects a transaction, finalize the transaction added\n      // event fragment. with the abandoned flag set.\n      case TRANSACTION_EVENTS.REJECTED:\n        id = `transaction-added-${txMeta.id}`;\n        this.updateEventFragment(id, { properties, sensitiveProperties });\n        this.finalizeEventFragment(id, {\n          abandoned: true,\n        });\n        break;\n      // When a transaction is finalized, also finalize the transaction\n      // submitted event fragment.\n      case TRANSACTION_EVENTS.FINALIZED:\n        id = `transaction-submitted-${txMeta.id}`;\n        this.updateEventFragment(id, { properties, sensitiveProperties });\n        this.finalizeEventFragment(`transaction-submitted-${txMeta.id}`);\n        break;\n      default:\n        break;\n    }\n  }\n\n  _getTransactionCompletionTime(submittedTime) {\n    return Math.round((Date.now() - submittedTime) / 1000).toString();\n  }\n\n  _getGasValuesInGWEI(gasParams) {\n    const gasValuesInGwei = {};\n    for (const param in gasParams) {\n      if (isHexString(gasParams[param])) {\n        gasValuesInGwei[param] = hexWEIToDecGWEI(gasParams[param]);\n      } else {\n        gasValuesInGwei[param] = gasParams[param];\n      }\n    }\n    return gasValuesInGwei;\n  }\n\n  _failTransaction(txId, error) {\n    this.txStateManager.setTxStatusFailed(txId, error);\n    const txMeta = this.txStateManager.getTransaction(txId);\n    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.FINALIZED, {\n      error: error.message,\n    });\n  }\n\n  _dropTransaction(txId) {\n    this.txStateManager.setTxStatusDropped(txId);\n    const txMeta = this.txStateManager.getTransaction(txId);\n    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.FINALIZED);\n  }\n}\n","import Analytics from 'analytics-node';\nimport { SECOND } from '../../../shared/constants/time';\n\nconst isDevOrTestEnvironment = Boolean(\n  process.env.METAMASK_DEBUG || process.env.IN_TEST,\n);\nconst SEGMENT_WRITE_KEY = process.env.SEGMENT_WRITE_KEY ?? null;\nconst SEGMENT_HOST = process.env.SEGMENT_HOST ?? null;\n\n// flushAt controls how many events are sent to segment at once. Segment will\n// hold onto a queue of events until it hits this number, then it sends them as\n// a batch. This setting defaults to 20, but in development we likely want to\n// see events in real time for debugging, so this is set to 1 to disable the\n// queueing mechanism.\nconst SEGMENT_FLUSH_AT =\n  process.env.METAMASK_ENVIRONMENT === 'production' ? undefined : 1;\n\n// flushInterval controls how frequently the queue is flushed to segment.\n// This happens regardless of the size of the queue. The default setting is\n// 10,000ms (10 seconds). This default is rather high, though thankfully\n// using the background process as our event handler means we don't have to\n// deal with short lived sessions that happen faster than the interval\n// e.g confirmations. This is set to 5,000ms (5 seconds) arbitrarily with the\n// intent of having a value less than 10 seconds.\nconst SEGMENT_FLUSH_INTERVAL = SECOND * 5;\n\n/**\n * Creates a mock segment module for usage in test environments. This is used\n * when building the application in test mode to catch event calls and prevent\n * them from being sent to segment. It is also used in unit tests to mock and\n * spy on the methods to ensure proper behavior\n *\n * @param {number} flushAt - number of events to queue before sending to segment\n * @returns {SegmentInterface}\n */\nexport const createSegmentMock = (flushAt = SEGMENT_FLUSH_AT) => {\n  const segmentMock = {\n    // Internal queue to keep track of events and properly mimic segment's\n    // queueing behavior.\n    queue: [],\n\n    /**\n     * Used to immediately send all queued events and reset the queue to zero.\n     * For our purposes this simply triggers the callback method registered with\n     * the event.\n     */\n    flush() {\n      segmentMock.queue.forEach(([_, callback]) => {\n        callback();\n      });\n      segmentMock.queue = [];\n    },\n\n    /**\n     * Track an event and add it to the queue. If the queue size reaches the\n     * flushAt threshold, flush the queue.\n     *\n     * @param payload\n     * @param callback\n     */\n    track(payload, callback = () => undefined) {\n      segmentMock.queue.push([payload, callback]);\n\n      if (segmentMock.queue.length >= flushAt) {\n        segmentMock.flush();\n      }\n    },\n\n    /**\n     * A true NOOP, these methods are either not used or do not await callback\n     * and therefore require no functionality.\n     */\n    page() {\n      // noop\n    },\n    identify() {\n      // noop\n    },\n  };\n\n  return segmentMock;\n};\n\nexport const segment =\n  !SEGMENT_WRITE_KEY || (isDevOrTestEnvironment && !SEGMENT_HOST)\n    ? createSegmentMock(SEGMENT_FLUSH_AT, SEGMENT_FLUSH_INTERVAL)\n    : new Analytics(SEGMENT_WRITE_KEY, {\n        host: SEGMENT_HOST,\n        flushAt: SEGMENT_FLUSH_AT,\n        flushInterval: SEGMENT_FLUSH_INTERVAL,\n      });\n","import log from 'loglevel';\nimport Wallet from 'ethereumjs-wallet';\nimport importers from 'ethereumjs-wallet/thirdparty';\nimport {\n  toBuffer,\n  isValidPrivate,\n  bufferToHex,\n  stripHexPrefix,\n} from 'ethereumjs-util';\nimport { addHexPrefix } from '../lib/util';\n\nconst accountImporter = {\n  importAccount(strategy, args) {\n    try {\n      const importer = this.strategies[strategy];\n      const privateKeyHex = importer(...args);\n      return Promise.resolve(privateKeyHex);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n\n  strategies: {\n    'Private Key': (privateKey) => {\n      if (!privateKey) {\n        throw new Error('Cannot import an empty key.');\n      }\n\n      const prefixed = addHexPrefix(privateKey);\n      const buffer = toBuffer(prefixed);\n\n      if (!isValidPrivate(buffer)) {\n        throw new Error('Cannot import invalid private key.');\n      }\n\n      const stripped = stripHexPrefix(prefixed);\n      return stripped;\n    },\n    'JSON File': (input, password) => {\n      let wallet;\n      try {\n        wallet = importers.fromEtherWallet(input, password);\n      } catch (e) {\n        log.debug('Attempt to import as EtherWallet format failed, trying V3');\n        wallet = Wallet.fromV3(input, password, true);\n      }\n\n      return walletToPrivateKey(wallet);\n    },\n  },\n};\n\nfunction walletToPrivateKey(wallet) {\n  const privateKeyBuffer = wallet.getPrivateKey();\n  return bufferToHex(privateKeyBuffer);\n}\n\nexport default accountImporter;\n","export { default, NETWORK_EVENTS } from './network';\n","import { ethers } from 'ethers';\nimport log from 'loglevel';\nimport BigNumber from 'bignumber.js';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { mapValues, cloneDeep } from 'lodash';\nimport abi from 'human-standard-token-abi';\nimport { calcTokenAmount } from '../../../ui/helpers/utils/token-util';\nimport { calcGasTotal } from '../../../ui/pages/send/send.utils';\nimport {\n  conversionUtil,\n  decGWEIToHexWEI,\n  addCurrencies,\n} from '../../../shared/modules/conversion.utils';\nimport {\n  DEFAULT_ERC20_APPROVE_GAS,\n  QUOTES_EXPIRED_ERROR,\n  QUOTES_NOT_AVAILABLE_ERROR,\n  SWAPS_FETCH_ORDER_CONFLICT,\n  SWAPS_CHAINID_CONTRACT_ADDRESS_MAP,\n} from '../../../shared/constants/swaps';\nimport { GAS_ESTIMATE_TYPES } from '../../../shared/constants/gas';\n\nimport { isSwapsDefaultTokenAddress } from '../../../shared/modules/swaps.utils';\n\nimport {\n  fetchTradesInfo as defaultFetchTradesInfo,\n  getBaseApi,\n} from '../../../ui/pages/swaps/swaps.util';\nimport fetchWithCache from '../../../ui/helpers/utils/fetch-with-cache';\nimport { MINUTE, SECOND } from '../../../shared/constants/time';\nimport { isEqualCaseInsensitive } from '../../../ui/helpers/utils/util';\nimport { NETWORK_EVENTS } from './network';\n\n// The MAX_GAS_LIMIT is a number that is higher than the maximum gas costs we have observed on any aggregator\nconst MAX_GAS_LIMIT = 2500000;\n\n// To ensure that our serves are not spammed if MetaMask is left idle, we limit the number of fetches for quotes that are made on timed intervals.\n// 3 seems to be an appropriate balance of giving users the time they need when MetaMask is not left idle, and turning polling off when it is.\nconst POLL_COUNT_LIMIT = 3;\n\n// If for any reason the MetaSwap API fails to provide a refresh time,\n// provide a reasonable fallback to avoid further errors\nconst FALLBACK_QUOTE_REFRESH_TIME = MINUTE;\nconst FALLBACK_SMART_TRANSACTION_REFRESH_TIME = SECOND * 10;\nconst FALLBACK_SMART_TRANSACTIONS_DEADLINE = 180;\n\nfunction calculateGasEstimateWithRefund(\n  maxGas = MAX_GAS_LIMIT,\n  estimatedRefund = 0,\n  estimatedGas = 0,\n) {\n  const maxGasMinusRefund = new BigNumber(maxGas, 10).minus(\n    estimatedRefund,\n    10,\n  );\n  const isMaxGasMinusRefundNegative = maxGasMinusRefund.lt(0);\n\n  const gasEstimateWithRefund =\n    !isMaxGasMinusRefundNegative && maxGasMinusRefund.lt(estimatedGas, 16)\n      ? `0x${maxGasMinusRefund.toString(16)}`\n      : estimatedGas;\n\n  return gasEstimateWithRefund;\n}\n\nconst initialState = {\n  swapsState: {\n    quotes: {},\n    quotesPollingLimitEnabled: false,\n    fetchParams: null,\n    tokens: null,\n    tradeTxId: null,\n    approveTxId: null,\n    quotesLastFetched: null,\n    customMaxGas: '',\n    customGasPrice: null,\n    customMaxFeePerGas: null,\n    customMaxPriorityFeePerGas: null,\n    swapsUserFeeLevel: '',\n    selectedAggId: null,\n    customApproveTxData: '',\n    errorKey: '',\n    topAggId: null,\n    routeState: '',\n    swapsFeatureIsLive: true,\n    saveFetchedQuotes: false,\n    swapsQuoteRefreshTime: FALLBACK_QUOTE_REFRESH_TIME,\n    swapsQuotePrefetchingRefreshTime: FALLBACK_QUOTE_REFRESH_TIME,\n    swapsStxBatchStatusRefreshTime: FALLBACK_SMART_TRANSACTION_REFRESH_TIME,\n    swapsStxGetTransactionsRefreshTime: FALLBACK_SMART_TRANSACTION_REFRESH_TIME,\n    swapsFeatureFlags: {},\n  },\n};\n\nexport default class SwapsController {\n  constructor({\n    getBufferedGasLimit,\n    networkController,\n    provider,\n    getProviderConfig,\n    getTokenRatesState,\n    fetchTradesInfo = defaultFetchTradesInfo,\n    getCurrentChainId,\n    getEIP1559GasFeeEstimates,\n  }) {\n    this.store = new ObservableStore({\n      swapsState: { ...initialState.swapsState },\n    });\n\n    this._fetchTradesInfo = fetchTradesInfo;\n    this._getCurrentChainId = getCurrentChainId;\n    this._getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;\n\n    this.getBufferedGasLimit = getBufferedGasLimit;\n    this.getTokenRatesState = getTokenRatesState;\n\n    this.pollCount = 0;\n    this.getProviderConfig = getProviderConfig;\n\n    this.indexOfNewestCallInFlight = 0;\n\n    this.ethersProvider = new ethers.providers.Web3Provider(provider);\n    this._currentNetwork = networkController.store.getState().network;\n    networkController.on(NETWORK_EVENTS.NETWORK_DID_CHANGE, (network) => {\n      if (network !== 'loading' && network !== this._currentNetwork) {\n        this._currentNetwork = network;\n        this.ethersProvider = new ethers.providers.Web3Provider(provider);\n      }\n    });\n  }\n\n  async fetchSwapsRefreshRates(chainId) {\n    const response = await fetchWithCache(\n      getBaseApi('network', chainId),\n      { method: 'GET' },\n      { cacheRefreshTime: 600000 },\n    );\n    const { refreshRates } = response || {};\n    if (\n      !refreshRates ||\n      typeof refreshRates.quotes !== 'number' ||\n      typeof refreshRates.quotesPrefetching !== 'number' ||\n      typeof refreshRates.stxGetTransactions !== 'number' ||\n      typeof refreshRates.stxBatchStatus !== 'number'\n    ) {\n      throw new Error(\n        `MetaMask - invalid response for refreshRates: ${response}`,\n      );\n    }\n    // We presently use milliseconds in the UI.\n    return {\n      quotes: refreshRates.quotes * 1000,\n      quotesPrefetching: refreshRates.quotesPrefetching * 1000,\n      stxGetTransactions: refreshRates.stxGetTransactions * 1000,\n      stxBatchStatus: refreshRates.stxBatchStatus * 1000,\n      stxStatusDeadline: refreshRates.stxStatusDeadline,\n    };\n  }\n\n  // Sets the refresh rate for quote updates from the MetaSwap API\n  async _setSwapsRefreshRates() {\n    const chainId = this._getCurrentChainId();\n    let swapsRefreshRates;\n    try {\n      swapsRefreshRates = await this.fetchSwapsRefreshRates(chainId);\n    } catch (e) {\n      console.error('Request for swaps quote refresh time failed: ', e);\n    }\n    const { swapsState: latestSwapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: {\n        ...latestSwapsState,\n        swapsQuoteRefreshTime:\n          swapsRefreshRates?.quotes || FALLBACK_QUOTE_REFRESH_TIME,\n        swapsQuotePrefetchingRefreshTime:\n          swapsRefreshRates?.quotesPrefetching || FALLBACK_QUOTE_REFRESH_TIME,\n        swapsStxGetTransactionsRefreshTime:\n          swapsRefreshRates?.stxGetTransactions ||\n          FALLBACK_SMART_TRANSACTION_REFRESH_TIME,\n        swapsStxBatchStatusRefreshTime:\n          swapsRefreshRates?.stxBatchStatus ||\n          FALLBACK_SMART_TRANSACTION_REFRESH_TIME,\n        swapsStxStatusDeadline:\n          swapsRefreshRates?.stxStatusDeadline ||\n          FALLBACK_SMART_TRANSACTIONS_DEADLINE,\n      },\n    });\n  }\n\n  // Once quotes are fetched, we poll for new ones to keep the quotes up to date. Market and aggregator contract conditions can change fast enough\n  // that quotes will no longer be available after 1 or 2 minutes. When fetchAndSetQuotes is first called, it receives fetch parameters that are stored in\n  // state. These stored parameters are used on subsequent calls made during polling.\n  // Note: we stop polling after 3 requests, until new quotes are explicitly asked for. The logic that enforces that maximum is in the body of fetchAndSetQuotes\n  pollForNewQuotes() {\n    const {\n      swapsState: {\n        swapsQuoteRefreshTime,\n        swapsQuotePrefetchingRefreshTime,\n        quotesPollingLimitEnabled,\n      },\n    } = this.store.getState();\n    // swapsQuoteRefreshTime is used on the View Quote page, swapsQuotePrefetchingRefreshTime is used on the Build Quote page.\n    const quotesRefreshRateInMs = quotesPollingLimitEnabled\n      ? swapsQuoteRefreshTime\n      : swapsQuotePrefetchingRefreshTime;\n    this.pollingTimeout = setTimeout(() => {\n      const { swapsState } = this.store.getState();\n      this.fetchAndSetQuotes(\n        swapsState.fetchParams,\n        swapsState.fetchParams?.metaData,\n        true,\n      );\n    }, quotesRefreshRateInMs);\n  }\n\n  stopPollingForQuotes() {\n    if (this.pollingTimeout) {\n      clearTimeout(this.pollingTimeout);\n    }\n  }\n\n  async fetchAndSetQuotes(\n    fetchParams,\n    fetchParamsMetaData = {},\n    isPolledRequest,\n  ) {\n    const { chainId } = fetchParamsMetaData;\n    const {\n      swapsState: { quotesPollingLimitEnabled, saveFetchedQuotes },\n    } = this.store.getState();\n\n    if (!fetchParams) {\n      return null;\n    }\n    // Every time we get a new request that is not from the polling, we reset the poll count so we can poll for up to three more sets of quotes with these new params.\n    if (!isPolledRequest) {\n      this.pollCount = 0;\n    }\n\n    // If there are any pending poll requests, clear them so that they don't get call while this new fetch is in process\n    clearTimeout(this.pollingTimeout);\n\n    if (!isPolledRequest) {\n      this.setSwapsErrorKey('');\n    }\n\n    const indexOfCurrentCall = this.indexOfNewestCallInFlight + 1;\n    this.indexOfNewestCallInFlight = indexOfCurrentCall;\n\n    if (!saveFetchedQuotes) {\n      this.setSaveFetchedQuotes(true);\n    }\n\n    let [newQuotes] = await Promise.all([\n      this._fetchTradesInfo(fetchParams, {\n        ...fetchParamsMetaData,\n      }),\n      this._setSwapsRefreshRates(),\n    ]);\n\n    const {\n      swapsState: { saveFetchedQuotes: saveFetchedQuotesAfterResponse },\n    } = this.store.getState();\n\n    // If saveFetchedQuotesAfterResponse is false, it means a user left Swaps (we cleaned the state)\n    // and we don't want to set any API response with quotes into state.\n    if (!saveFetchedQuotesAfterResponse) {\n      return [\n        {}, // quotes\n        null, // selectedAggId\n      ];\n    }\n\n    newQuotes = mapValues(newQuotes, (quote) => ({\n      ...quote,\n      sourceTokenInfo: fetchParamsMetaData.sourceTokenInfo,\n      destinationTokenInfo: fetchParamsMetaData.destinationTokenInfo,\n    }));\n\n    const quotesLastFetched = Date.now();\n\n    let approvalRequired = false;\n    if (\n      !isSwapsDefaultTokenAddress(fetchParams.sourceToken, chainId) &&\n      Object.values(newQuotes).length\n    ) {\n      const allowance = await this._getERC20Allowance(\n        fetchParams.sourceToken,\n        fetchParams.fromAddress,\n        chainId,\n      );\n      const [firstQuote] = Object.values(newQuotes);\n\n      // For a user to be able to swap a token, they need to have approved the MetaSwap contract to withdraw that token.\n      // _getERC20Allowance() returns the amount of the token they have approved for withdrawal. If that amount is greater\n      // than 0, it means that approval has already occurred and is not needed. Otherwise, for tokens to be swapped, a new\n      // call of the ERC-20 approve method is required.\n      approvalRequired =\n        firstQuote.approvalNeeded &&\n        allowance.eq(0) &&\n        firstQuote.aggregator !== 'wrappedNative';\n      if (!approvalRequired) {\n        newQuotes = mapValues(newQuotes, (quote) => ({\n          ...quote,\n          approvalNeeded: null,\n        }));\n      } else if (!isPolledRequest) {\n        const { gasLimit: approvalGas } = await this.timedoutGasReturn(\n          firstQuote.approvalNeeded,\n        );\n\n        newQuotes = mapValues(newQuotes, (quote) => ({\n          ...quote,\n          approvalNeeded: {\n            ...quote.approvalNeeded,\n            gas: approvalGas || DEFAULT_ERC20_APPROVE_GAS,\n          },\n        }));\n      }\n    }\n\n    let topAggId = null;\n\n    // We can reduce time on the loading screen by only doing this after the\n    // loading screen and best quote have rendered.\n    if (!approvalRequired && !fetchParams?.balanceError) {\n      newQuotes = await this.getAllQuotesWithGasEstimates(newQuotes);\n    }\n\n    if (Object.values(newQuotes).length === 0) {\n      this.setSwapsErrorKey(QUOTES_NOT_AVAILABLE_ERROR);\n    } else {\n      const [\n        _topAggId,\n        quotesWithSavingsAndFeeData,\n      ] = await this._findTopQuoteAndCalculateSavings(newQuotes);\n      topAggId = _topAggId;\n      newQuotes = quotesWithSavingsAndFeeData;\n    }\n\n    // If a newer call has been made, don't update state with old information\n    // Prevents timing conflicts between fetches\n    if (this.indexOfNewestCallInFlight !== indexOfCurrentCall) {\n      throw new Error(SWAPS_FETCH_ORDER_CONFLICT);\n    }\n\n    const { swapsState } = this.store.getState();\n    let { selectedAggId } = swapsState;\n    if (!newQuotes[selectedAggId]) {\n      selectedAggId = null;\n    }\n\n    this.store.updateState({\n      swapsState: {\n        ...swapsState,\n        quotes: newQuotes,\n        fetchParams: { ...fetchParams, metaData: fetchParamsMetaData },\n        quotesLastFetched,\n        selectedAggId,\n        topAggId,\n      },\n    });\n\n    if (quotesPollingLimitEnabled) {\n      // We only want to do up to a maximum of three requests from polling if polling limit is enabled.\n      // Otherwise we won't increase pollCount, so polling will run without a limit.\n      this.pollCount += 1;\n    }\n\n    if (!quotesPollingLimitEnabled || this.pollCount < POLL_COUNT_LIMIT + 1) {\n      this.pollForNewQuotes();\n    } else {\n      this.resetPostFetchState();\n      this.setSwapsErrorKey(QUOTES_EXPIRED_ERROR);\n      return null;\n    }\n\n    return [newQuotes, topAggId];\n  }\n\n  safeRefetchQuotes() {\n    const { swapsState } = this.store.getState();\n    if (!this.pollingTimeout && swapsState.fetchParams) {\n      this.fetchAndSetQuotes(swapsState.fetchParams);\n    }\n  }\n\n  setSelectedQuoteAggId(selectedAggId) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({ swapsState: { ...swapsState, selectedAggId } });\n  }\n\n  setSwapsTokens(tokens) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({ swapsState: { ...swapsState, tokens } });\n  }\n\n  clearSwapsQuotes() {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({ swapsState: { ...swapsState, quotes: {} } });\n  }\n\n  setSwapsErrorKey(errorKey) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({ swapsState: { ...swapsState, errorKey } });\n  }\n\n  async getAllQuotesWithGasEstimates(quotes) {\n    const quoteGasData = await Promise.all(\n      Object.values(quotes).map(async (quote) => {\n        const { gasLimit, simulationFails } = await this.timedoutGasReturn(\n          quote.trade,\n        );\n        return [gasLimit, simulationFails, quote.aggregator];\n      }),\n    );\n\n    const newQuotes = {};\n    quoteGasData.forEach(([gasLimit, simulationFails, aggId]) => {\n      if (gasLimit && !simulationFails) {\n        const gasEstimateWithRefund = calculateGasEstimateWithRefund(\n          quotes[aggId].maxGas,\n          quotes[aggId].estimatedRefund,\n          gasLimit,\n        );\n\n        newQuotes[aggId] = {\n          ...quotes[aggId],\n          gasEstimate: gasLimit,\n          gasEstimateWithRefund,\n        };\n      } else if (quotes[aggId].approvalNeeded) {\n        // If gas estimation fails, but an ERC-20 approve is needed, then we do not add any estimate property to the quote object\n        // Such quotes will rely on the maxGas and averageGas properties from the api\n        newQuotes[aggId] = quotes[aggId];\n      }\n      // If gas estimation fails and no approval is needed, then we filter that quote out, so that it is not shown to the user\n    });\n    return newQuotes;\n  }\n\n  timedoutGasReturn(tradeTxParams) {\n    return new Promise((resolve) => {\n      let gasTimedOut = false;\n\n      const gasTimeout = setTimeout(() => {\n        gasTimedOut = true;\n        resolve({ gasLimit: null, simulationFails: true });\n      }, SECOND * 5);\n\n      // Remove gas from params that will be passed to the `estimateGas` call\n      // Including it can cause the estimate to fail if the actual gas needed\n      // exceeds the passed gas\n      const tradeTxParamsForGasEstimate = {\n        data: tradeTxParams.data,\n        from: tradeTxParams.from,\n        to: tradeTxParams.to,\n        value: tradeTxParams.value,\n      };\n\n      this.getBufferedGasLimit({ txParams: tradeTxParamsForGasEstimate }, 1)\n        .then(({ gasLimit, simulationFails }) => {\n          if (!gasTimedOut) {\n            clearTimeout(gasTimeout);\n            resolve({ gasLimit, simulationFails });\n          }\n        })\n        .catch((e) => {\n          log.error(e);\n          if (!gasTimedOut) {\n            clearTimeout(gasTimeout);\n            resolve({ gasLimit: null, simulationFails: true });\n          }\n        });\n    });\n  }\n\n  async setInitialGasEstimate(initialAggId) {\n    const { swapsState } = this.store.getState();\n\n    const quoteToUpdate = { ...swapsState.quotes[initialAggId] };\n\n    const {\n      gasLimit: newGasEstimate,\n      simulationFails,\n    } = await this.timedoutGasReturn(quoteToUpdate.trade);\n\n    if (newGasEstimate && !simulationFails) {\n      const gasEstimateWithRefund = calculateGasEstimateWithRefund(\n        quoteToUpdate.maxGas,\n        quoteToUpdate.estimatedRefund,\n        newGasEstimate,\n      );\n\n      quoteToUpdate.gasEstimate = newGasEstimate;\n      quoteToUpdate.gasEstimateWithRefund = gasEstimateWithRefund;\n    }\n\n    this.store.updateState({\n      swapsState: {\n        ...swapsState,\n        quotes: { ...swapsState.quotes, [initialAggId]: quoteToUpdate },\n      },\n    });\n  }\n\n  setApproveTxId(approveTxId) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({ swapsState: { ...swapsState, approveTxId } });\n  }\n\n  setTradeTxId(tradeTxId) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({ swapsState: { ...swapsState, tradeTxId } });\n  }\n\n  setQuotesLastFetched(quotesLastFetched) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, quotesLastFetched },\n    });\n  }\n\n  setSwapsTxGasPrice(gasPrice) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, customGasPrice: gasPrice },\n    });\n  }\n\n  setSwapsTxMaxFeePerGas(maxFeePerGas) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, customMaxFeePerGas: maxFeePerGas },\n    });\n  }\n\n  setSwapsUserFeeLevel(swapsUserFeeLevel) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, swapsUserFeeLevel },\n    });\n  }\n\n  setSwapsQuotesPollingLimitEnabled(quotesPollingLimitEnabled) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, quotesPollingLimitEnabled },\n    });\n  }\n\n  setSwapsTxMaxFeePriorityPerGas(maxPriorityFeePerGas) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: {\n        ...swapsState,\n        customMaxPriorityFeePerGas: maxPriorityFeePerGas,\n      },\n    });\n  }\n\n  setSwapsTxGasLimit(gasLimit) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, customMaxGas: gasLimit },\n    });\n  }\n\n  setCustomApproveTxData(data) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, customApproveTxData: data },\n    });\n  }\n\n  setBackgroundSwapRouteState(routeState) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({ swapsState: { ...swapsState, routeState } });\n  }\n\n  setSaveFetchedQuotes(status) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, saveFetchedQuotes: status },\n    });\n  }\n\n  setSwapsLiveness(swapsLiveness) {\n    const { swapsState } = this.store.getState();\n    const { swapsFeatureIsLive } = swapsLiveness;\n    this.store.updateState({\n      swapsState: { ...swapsState, swapsFeatureIsLive },\n    });\n  }\n\n  setSwapsFeatureFlags(swapsFeatureFlags) {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: { ...swapsState, swapsFeatureFlags },\n    });\n  }\n\n  resetPostFetchState() {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: {\n        ...initialState.swapsState,\n        tokens: swapsState.tokens,\n        fetchParams: swapsState.fetchParams,\n        swapsFeatureIsLive: swapsState.swapsFeatureIsLive,\n        swapsQuoteRefreshTime: swapsState.swapsQuoteRefreshTime,\n        swapsQuotePrefetchingRefreshTime:\n          swapsState.swapsQuotePrefetchingRefreshTime,\n        swapsFeatureFlags: swapsState.swapsFeatureFlags,\n      },\n    });\n    clearTimeout(this.pollingTimeout);\n  }\n\n  resetSwapsState() {\n    const { swapsState } = this.store.getState();\n    this.store.updateState({\n      swapsState: {\n        ...initialState.swapsState,\n        swapsQuoteRefreshTime: swapsState.swapsQuoteRefreshTime,\n        swapsQuotePrefetchingRefreshTime:\n          swapsState.swapsQuotePrefetchingRefreshTime,\n      },\n    });\n    clearTimeout(this.pollingTimeout);\n  }\n\n  async _findTopQuoteAndCalculateSavings(quotes = {}) {\n    const {\n      contractExchangeRates: tokenConversionRates,\n    } = this.getTokenRatesState();\n    const {\n      swapsState: { customGasPrice, customMaxPriorityFeePerGas },\n    } = this.store.getState();\n    const chainId = this._getCurrentChainId();\n\n    const numQuotes = Object.keys(quotes).length;\n    if (!numQuotes) {\n      return {};\n    }\n\n    const newQuotes = cloneDeep(quotes);\n\n    const {\n      gasFeeEstimates,\n      gasEstimateType,\n    } = await this._getEIP1559GasFeeEstimates();\n\n    let usedGasPrice = '0x0';\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      const {\n        high: { suggestedMaxPriorityFeePerGas },\n        estimatedBaseFee,\n      } = gasFeeEstimates;\n\n      usedGasPrice = addCurrencies(\n        customMaxPriorityFeePerGas || // Is already in hex WEI.\n          decGWEIToHexWEI(suggestedMaxPriorityFeePerGas),\n        decGWEIToHexWEI(estimatedBaseFee),\n        {\n          aBase: 16,\n          bBase: 16,\n          toNumericBase: 'hex',\n          numberOfDecimals: 6,\n        },\n      );\n    } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n      usedGasPrice = customGasPrice || decGWEIToHexWEI(gasFeeEstimates.high);\n    } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n      usedGasPrice =\n        customGasPrice || decGWEIToHexWEI(gasFeeEstimates.gasPrice);\n    }\n\n    let topAggId = null;\n    let overallValueOfBestQuoteForSorting = null;\n\n    Object.values(newQuotes).forEach((quote) => {\n      const {\n        aggregator,\n        approvalNeeded,\n        averageGas,\n        destinationAmount = 0,\n        destinationToken,\n        destinationTokenInfo,\n        gasEstimate,\n        sourceAmount,\n        sourceToken,\n        trade,\n        fee: metaMaskFee,\n      } = quote;\n\n      const tradeGasLimitForCalculation = gasEstimate\n        ? new BigNumber(gasEstimate, 16)\n        : new BigNumber(averageGas || MAX_GAS_LIMIT, 10);\n\n      const totalGasLimitForCalculation = tradeGasLimitForCalculation\n        .plus(approvalNeeded?.gas || '0x0', 16)\n        .toString(16);\n\n      const gasTotalInWeiHex = calcGasTotal(\n        totalGasLimitForCalculation,\n        usedGasPrice,\n      );\n\n      // trade.value is a sum of different values depending on the transaction.\n      // It always includes any external fees charged by the quote source. In\n      // addition, if the source asset is the selected chain's default token, trade.value\n      // includes the amount of that token.\n      const totalWeiCost = new BigNumber(gasTotalInWeiHex, 16).plus(\n        trade.value,\n        16,\n      );\n\n      const totalEthCost = conversionUtil(totalWeiCost, {\n        fromCurrency: 'ETH',\n        fromDenomination: 'WEI',\n        toDenomination: 'ETH',\n        fromNumericBase: 'BN',\n        numberOfDecimals: 6,\n      });\n\n      // The total fee is aggregator/exchange fees plus gas fees.\n      // If the swap is from the selected chain's default token, subtract\n      // the sourceAmount from the total cost. Otherwise, the total fee\n      // is simply trade.value plus gas fees.\n      const ethFee = isSwapsDefaultTokenAddress(sourceToken, chainId)\n        ? conversionUtil(\n            totalWeiCost.minus(sourceAmount, 10), // sourceAmount is in wei\n            {\n              fromCurrency: 'ETH',\n              fromDenomination: 'WEI',\n              toDenomination: 'ETH',\n              fromNumericBase: 'BN',\n              numberOfDecimals: 6,\n            },\n          )\n        : totalEthCost;\n\n      const decimalAdjustedDestinationAmount = calcTokenAmount(\n        destinationAmount,\n        destinationTokenInfo.decimals,\n      );\n\n      const tokenPercentageOfPreFeeDestAmount = new BigNumber(100, 10)\n        .minus(metaMaskFee, 10)\n        .div(100);\n      const destinationAmountBeforeMetaMaskFee = decimalAdjustedDestinationAmount.div(\n        tokenPercentageOfPreFeeDestAmount,\n      );\n      const metaMaskFeeInTokens = destinationAmountBeforeMetaMaskFee.minus(\n        decimalAdjustedDestinationAmount,\n      );\n\n      const tokenConversionRate =\n        tokenConversionRates[\n          Object.keys(tokenConversionRates).find((tokenAddress) =>\n            isEqualCaseInsensitive(tokenAddress, destinationToken),\n          )\n        ];\n      const conversionRateForSorting = tokenConversionRate || 1;\n\n      const ethValueOfTokens = decimalAdjustedDestinationAmount.times(\n        conversionRateForSorting.toString(10),\n        10,\n      );\n\n      const conversionRateForCalculations = isSwapsDefaultTokenAddress(\n        destinationToken,\n        chainId,\n      )\n        ? 1\n        : tokenConversionRate;\n\n      const overallValueOfQuoteForSorting =\n        conversionRateForCalculations === undefined\n          ? ethValueOfTokens\n          : ethValueOfTokens.minus(ethFee, 10);\n\n      quote.ethFee = ethFee.toString(10);\n\n      if (conversionRateForCalculations !== undefined) {\n        quote.ethValueOfTokens = ethValueOfTokens.toString(10);\n        quote.overallValueOfQuote = overallValueOfQuoteForSorting.toString(10);\n        quote.metaMaskFeeInEth = metaMaskFeeInTokens\n          .times(conversionRateForCalculations.toString(10))\n          .toString(10);\n      }\n\n      if (\n        overallValueOfBestQuoteForSorting === null ||\n        overallValueOfQuoteForSorting.gt(overallValueOfBestQuoteForSorting)\n      ) {\n        topAggId = aggregator;\n        overallValueOfBestQuoteForSorting = overallValueOfQuoteForSorting;\n      }\n    });\n\n    const isBest =\n      isSwapsDefaultTokenAddress(\n        newQuotes[topAggId].destinationToken,\n        chainId,\n      ) ||\n      Boolean(\n        tokenConversionRates[\n          Object.keys(tokenConversionRates).find((tokenAddress) =>\n            isEqualCaseInsensitive(\n              tokenAddress,\n              newQuotes[topAggId]?.destinationToken,\n            ),\n          )\n        ],\n      );\n\n    let savings = null;\n\n    if (isBest) {\n      const bestQuote = newQuotes[topAggId];\n\n      savings = {};\n\n      const {\n        ethFee: medianEthFee,\n        metaMaskFeeInEth: medianMetaMaskFee,\n        ethValueOfTokens: medianEthValueOfTokens,\n      } = getMedianEthValueQuote(Object.values(newQuotes));\n\n      // Performance savings are calculated as:\n      //   (ethValueOfTokens for the best trade) - (ethValueOfTokens for the media trade)\n      savings.performance = new BigNumber(bestQuote.ethValueOfTokens, 10).minus(\n        medianEthValueOfTokens,\n        10,\n      );\n\n      // Fee savings are calculated as:\n      //   (fee for the median trade) - (fee for the best trade)\n      savings.fee = new BigNumber(medianEthFee).minus(bestQuote.ethFee, 10);\n\n      savings.metaMaskFee = bestQuote.metaMaskFeeInEth;\n\n      // Total savings are calculated as:\n      //   performance savings + fee savings - metamask fee\n      savings.total = savings.performance\n        .plus(savings.fee)\n        .minus(savings.metaMaskFee)\n        .toString(10);\n      savings.performance = savings.performance.toString(10);\n      savings.fee = savings.fee.toString(10);\n      savings.medianMetaMaskFee = medianMetaMaskFee;\n\n      newQuotes[topAggId].isBestQuote = true;\n      newQuotes[topAggId].savings = savings;\n    }\n\n    return [topAggId, newQuotes];\n  }\n\n  async _getERC20Allowance(contractAddress, walletAddress, chainId) {\n    const contract = new ethers.Contract(\n      contractAddress,\n      abi,\n      this.ethersProvider,\n    );\n    return await contract.allowance(\n      walletAddress,\n      SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[chainId],\n    );\n  }\n}\n\n/**\n * Calculates the median overallValueOfQuote of a sample of quotes.\n *\n * @param {Array} _quotes - A sample of quote objects with overallValueOfQuote, ethFee, metaMaskFeeInEth, and ethValueOfTokens properties\n * @returns {Object} An object with the ethValueOfTokens, ethFee, and metaMaskFeeInEth of the quote with the median overallValueOfQuote\n */\nfunction getMedianEthValueQuote(_quotes) {\n  if (!Array.isArray(_quotes) || _quotes.length === 0) {\n    throw new Error('Expected non-empty array param.');\n  }\n\n  const quotes = [..._quotes];\n\n  quotes.sort((quoteA, quoteB) => {\n    const overallValueOfQuoteA = new BigNumber(quoteA.overallValueOfQuote, 10);\n    const overallValueOfQuoteB = new BigNumber(quoteB.overallValueOfQuote, 10);\n    if (overallValueOfQuoteA.equals(overallValueOfQuoteB)) {\n      return 0;\n    }\n    return overallValueOfQuoteA.lessThan(overallValueOfQuoteB) ? -1 : 1;\n  });\n\n  if (quotes.length % 2 === 1) {\n    // return middle values\n    const medianOverallValue =\n      quotes[(quotes.length - 1) / 2].overallValueOfQuote;\n    const quotesMatchingMedianQuoteValue = quotes.filter(\n      (quote) => medianOverallValue === quote.overallValueOfQuote,\n    );\n    return meansOfQuotesFeesAndValue(quotesMatchingMedianQuoteValue);\n  }\n\n  // return mean of middle two values\n  const upperIndex = quotes.length / 2;\n  const lowerIndex = upperIndex - 1;\n\n  const overallValueAtUpperIndex = quotes[upperIndex].overallValueOfQuote;\n  const overallValueAtLowerIndex = quotes[lowerIndex].overallValueOfQuote;\n\n  const quotesMatchingUpperIndexValue = quotes.filter(\n    (quote) => overallValueAtUpperIndex === quote.overallValueOfQuote,\n  );\n  const quotesMatchingLowerIndexValue = quotes.filter(\n    (quote) => overallValueAtLowerIndex === quote.overallValueOfQuote,\n  );\n\n  const feesAndValueAtUpperIndex = meansOfQuotesFeesAndValue(\n    quotesMatchingUpperIndexValue,\n  );\n  const feesAndValueAtLowerIndex = meansOfQuotesFeesAndValue(\n    quotesMatchingLowerIndexValue,\n  );\n\n  return {\n    ethFee: new BigNumber(feesAndValueAtUpperIndex.ethFee, 10)\n      .plus(feesAndValueAtLowerIndex.ethFee, 10)\n      .dividedBy(2)\n      .toString(10),\n    metaMaskFeeInEth: new BigNumber(\n      feesAndValueAtUpperIndex.metaMaskFeeInEth,\n      10,\n    )\n      .plus(feesAndValueAtLowerIndex.metaMaskFeeInEth, 10)\n      .dividedBy(2)\n      .toString(10),\n    ethValueOfTokens: new BigNumber(\n      feesAndValueAtUpperIndex.ethValueOfTokens,\n      10,\n    )\n      .plus(feesAndValueAtLowerIndex.ethValueOfTokens, 10)\n      .dividedBy(2)\n      .toString(10),\n  };\n}\n\n/**\n * Calculates the arithmetic mean for each of three properties - ethFee, metaMaskFeeInEth and ethValueOfTokens - across\n * an array of objects containing those properties.\n *\n * @param {Array} quotes - A sample of quote objects with overallValueOfQuote, ethFee, metaMaskFeeInEth and\n * ethValueOfTokens properties\n * @returns {Object} An object with the arithmetic mean each of the ethFee, metaMaskFeeInEth and ethValueOfTokens of\n * the passed quote objects\n */\nfunction meansOfQuotesFeesAndValue(quotes) {\n  const feeAndValueSumsAsBigNumbers = quotes.reduce(\n    (feeAndValueSums, quote) => ({\n      ethFee: feeAndValueSums.ethFee.plus(quote.ethFee, 10),\n      metaMaskFeeInEth: feeAndValueSums.metaMaskFeeInEth.plus(\n        quote.metaMaskFeeInEth,\n        10,\n      ),\n      ethValueOfTokens: feeAndValueSums.ethValueOfTokens.plus(\n        quote.ethValueOfTokens,\n        10,\n      ),\n    }),\n    {\n      ethFee: new BigNumber(0, 10),\n      metaMaskFeeInEth: new BigNumber(0, 10),\n      ethValueOfTokens: new BigNumber(0, 10),\n    },\n  );\n\n  return {\n    ethFee: feeAndValueSumsAsBigNumbers.ethFee\n      .div(quotes.length, 10)\n      .toString(10),\n    metaMaskFeeInEth: feeAndValueSumsAsBigNumbers.metaMaskFeeInEth\n      .div(quotes.length, 10)\n      .toString(10),\n    ethValueOfTokens: feeAndValueSumsAsBigNumbers.ethValueOfTokens\n      .div(quotes.length, 10)\n      .toString(10),\n  };\n}\n\nexport const utils = {\n  getMedianEthValueQuote,\n  meansOfQuotesFeesAndValue,\n};\n","const { EventEmitter } = require('events')\nconst HDKey = require('hdkey')\nconst ethUtil = require('ethereumjs-util')\nconst sigUtil = require('eth-sig-util')\nconst { TransactionFactory } = require('@ethereumjs/tx')\n\nconst pathBase = 'm'\nconst hdPathString = `${pathBase}/44'/60'/0'`\nconst type = 'Ledger Hardware'\n\nconst BRIDGE_URL = 'https://metamask.github.io/eth-ledger-bridge-keyring'\n\nconst MAX_INDEX = 1000\nconst NETWORK_API_URLS = {\n  ropsten: 'http://api-ropsten.etherscan.io',\n  kovan: 'http://api-kovan.etherscan.io',\n  rinkeby: 'https://api-rinkeby.etherscan.io',\n  mainnet: 'https://api.etherscan.io',\n}\n\nclass LedgerBridgeKeyring extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n    this.accountDetails = {}\n    this.bridgeUrl = null\n    this.type = type\n    this.page = 0\n    this.perPage = 5\n    this.unlockedAccount = 0\n    this.hdk = new HDKey()\n    this.paths = {}\n    this.iframe = null\n    this.network = 'mainnet'\n    this.implementFullBIP44 = false\n    this.deserialize(opts)\n\n    this.iframeLoaded = false\n    this._setupIframe()\n  }\n\n  serialize () {\n    return Promise.resolve({\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      accountDetails: this.accountDetails,\n      bridgeUrl: this.bridgeUrl,\n      implementFullBIP44: false,\n    })\n  }\n\n  deserialize (opts = {}) {\n    this.hdPath = opts.hdPath || hdPathString\n    this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL\n    this.accounts = opts.accounts || []\n    this.accountDetails = opts.accountDetails || {}\n    if (!opts.accountDetails) {\n      this._migrateAccountDetails(opts)\n    }\n\n    this.implementFullBIP44 = opts.implementFullBIP44 || false\n\n    // Remove accounts that don't have corresponding account details\n    this.accounts = this.accounts\n      .filter((account) => Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))\n\n    return Promise.resolve()\n  }\n\n  _migrateAccountDetails (opts) {\n    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {\n      for (const account of Object.keys(opts.accountIndexes)) {\n        this.accountDetails[account] = {\n          bip44: true,\n          hdPath: this._getPathForIndex(opts.accountIndexes[account]),\n        }\n      }\n    }\n\n    // try to migrate non-LedgerLive accounts too\n    if (!this._isLedgerLiveHdPath()) {\n      this.accounts\n        .filter((account) => !Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))\n        .forEach((account) => {\n          try {\n            this.accountDetails[ethUtil.toChecksumAddress(account)] = {\n              bip44: false,\n              hdPath: this._pathFromAddress(account),\n            }\n          } catch (e) {\n            console.log(`failed to migrate account ${account}`)\n          }\n        })\n    }\n  }\n\n  isUnlocked () {\n    return Boolean(this.hdk && this.hdk.publicKey)\n  }\n\n  setAccountToUnlock (index) {\n    this.unlockedAccount = parseInt(index, 10)\n  }\n\n  setHdPath (hdPath) {\n    // Reset HDKey if the path changes\n    if (this.hdPath !== hdPath) {\n      this.hdk = new HDKey()\n    }\n    this.hdPath = hdPath\n  }\n\n  unlock (hdPath) {\n    if (this.isUnlocked() && !hdPath) {\n      return Promise.resolve('already unlocked')\n    }\n    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath\n    return new Promise((resolve, reject) => {\n      this._sendMessage({\n        action: 'ledger-unlock',\n        params: {\n          hdPath: path,\n        },\n      },\n      ({ success, payload }) => {\n        if (success) {\n          this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')\n          this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')\n          resolve(payload.address)\n        } else {\n          reject(payload.error || new Error('Unknown error'))\n        }\n      })\n    })\n  }\n\n  addAccounts (n = 1) {\n\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then(async (_) => {\n          const from = this.unlockedAccount\n          const to = from + n\n          for (let i = from; i < to; i++) {\n            const path = this._getPathForIndex(i)\n            let address\n            if (this._isLedgerLiveHdPath()) {\n              address = await this.unlock(path)\n            } else {\n              address = this._addressFromIndex(pathBase, i)\n            }\n            this.accountDetails[ethUtil.toChecksumAddress(address)] = {\n              // TODO: consider renaming this property, as the current name is misleading\n              // It's currently used to represent whether an account uses the Ledger Live path.\n              bip44: this._isLedgerLiveHdPath(),\n              hdPath: path,\n            }\n\n            if (!this.accounts.includes(address)) {\n              this.accounts.push(address)\n            }\n            this.page = 0\n          }\n          resolve(this.accounts)\n        })\n        .catch(reject)\n    })\n  }\n\n  getFirstPage () {\n    this.page = 0\n    return this.__getPage(1)\n  }\n\n  getNextPage () {\n    return this.__getPage(1)\n  }\n\n  getPreviousPage () {\n    return this.__getPage(-1)\n  }\n\n  getAccounts () {\n    return Promise.resolve(this.accounts.slice())\n  }\n\n  removeAccount (address) {\n    if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {\n      throw new Error(`Address ${address} not found in this keyring`)\n    }\n    this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase())\n    delete this.accountDetails[ethUtil.toChecksumAddress(address)]\n  }\n\n  attemptMakeApp () {\n    return new Promise((resolve, reject) => {\n      this._sendMessage({\n        action: 'ledger-make-app',\n      }, ({ success, error }) => {\n        if (success) {\n          resolve(true)\n        } else {\n          reject(error)\n        }\n      })\n    })\n  }\n\n  updateTransportMethod (transportType) {\n    return new Promise((resolve, reject) => {\n      // If the iframe isn't loaded yet, let's store the desired transportType value and\n      // optimistically return a successful promise\n      if (!this.iframeLoaded) {\n        this.delayedPromise = {\n          resolve,\n          reject,\n          transportType,\n        }\n        return\n      }\n\n      this._sendMessage({\n        action: 'ledger-update-transport',\n        params: { transportType },\n      }, ({ success }) => {\n        if (success) {\n          resolve(true)\n        } else {\n          reject(new Error('Ledger transport could not be updated'))\n        }\n      })\n    })\n  }\n\n  // tx is an instance of the ethereumjs-transaction class.\n  signTransaction (address, tx) {\n    let rawTxHex\n    // transactions built with older versions of ethereumjs-tx have a\n    // getChainId method that newer versions do not. Older versions are mutable\n    // while newer versions default to being immutable. Expected shape and type\n    // of data for v, r and s differ (Buffer (old) vs BN (new))\n    if (typeof tx.getChainId === 'function') {\n      // In this version of ethereumjs-tx we must add the chainId in hex format\n      // to the initial v value. The chainId must be included in the serialized\n      // transaction which is only communicated to ethereumjs-tx in this\n      // value. In newer versions the chainId is communicated via the 'Common'\n      // object.\n      tx.v = ethUtil.bufferToHex(tx.getChainId())\n      tx.r = '0x00'\n      tx.s = '0x00'\n\n      rawTxHex = tx.serialize().toString('hex')\n\n      return this._signTransaction(address, rawTxHex, (payload) => {\n        tx.v = Buffer.from(payload.v, 'hex')\n        tx.r = Buffer.from(payload.r, 'hex')\n        tx.s = Buffer.from(payload.s, 'hex')\n        return tx\n      })\n    }\n\n    // The below `encode` call is only necessary for legacy transactions, as `getMessageToSign`\n    // calls `rlp.encode` internally for non-legacy transactions. As per the \"Transaction Execution\"\n    // section of the ethereum yellow paper, transactions need to be \"well-formed RLP, with no additional\n    // trailing bytes\".\n\n    // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the\n    // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes\n    // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.\n    const messageToSign = tx.getMessageToSign(false)\n\n    rawTxHex = Buffer.isBuffer(messageToSign)\n      ? messageToSign.toString('hex')\n      : ethUtil.rlp.encode(messageToSign).toString('hex')\n\n    return this._signTransaction(address, rawTxHex, (payload) => {\n      // Because tx will be immutable, first get a plain javascript object that\n      // represents the transaction. Using txData here as it aligns with the\n      // nomenclature of ethereumjs/tx.\n      const txData = tx.toJSON()\n      // The fromTxData utility expects a type to support transactions with a type other than 0\n      txData.type = tx.type\n      // The fromTxData utility expects v,r and s to be hex prefixed\n      txData.v = ethUtil.addHexPrefix(payload.v)\n      txData.r = ethUtil.addHexPrefix(payload.r)\n      txData.s = ethUtil.addHexPrefix(payload.s)\n      // Adopt the 'common' option from the original transaction and set the\n      // returned object to be frozen if the original is frozen.\n      return TransactionFactory.fromTxData(txData, { common: tx.common, freeze: Object.isFrozen(tx) })\n    })\n  }\n\n  _signTransaction (address, rawTxHex, handleSigning) {\n    return new Promise((resolve, reject) => {\n      this.unlockAccountByAddress(address)\n        .then((hdPath) => {\n          this._sendMessage({\n            action: 'ledger-sign-transaction',\n            params: {\n              tx: rawTxHex,\n              hdPath,\n            },\n          },\n          ({ success, payload }) => {\n            if (success) {\n\n              const newOrMutatedTx = handleSigning(payload)\n              const valid = newOrMutatedTx.verifySignature()\n              if (valid) {\n                resolve(newOrMutatedTx)\n              } else {\n                reject(new Error('Ledger: The transaction signature is not valid'))\n              }\n            } else {\n              reject(payload.error || new Error('Ledger: Unknown error while signing transaction'))\n            }\n          })\n        })\n        .catch(reject)\n    })\n  }\n\n  signMessage (withAccount, data) {\n    return this.signPersonalMessage(withAccount, data)\n  }\n\n  // For personal_sign, we need to prefix the message:\n  signPersonalMessage (withAccount, message) {\n    return new Promise((resolve, reject) => {\n      this.unlockAccountByAddress(withAccount)\n        .then((hdPath) => {\n          this._sendMessage({\n            action: 'ledger-sign-personal-message',\n            params: {\n              hdPath,\n              message: ethUtil.stripHexPrefix(message),\n            },\n          },\n          ({ success, payload }) => {\n            if (success) {\n              let v = payload.v - 27\n              v = v.toString(16)\n              if (v.length < 2) {\n                v = `0${v}`\n              }\n              const signature = `0x${payload.r}${payload.s}${v}`\n              const addressSignedWith = sigUtil.recoverPersonalSignature({ data: message, sig: signature })\n              if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {\n                reject(new Error('Ledger: The signature doesnt match the right address'))\n              }\n              resolve(signature)\n            } else {\n              reject(payload.error || new Error('Ledger: Unknown error while signing message'))\n            }\n          })\n        })\n        .catch(reject)\n    })\n  }\n\n  async unlockAccountByAddress (address) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address)\n    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {\n      throw new Error(`Ledger: Account for address '${checksummedAddress}' not found`)\n    }\n    const { hdPath } = this.accountDetails[checksummedAddress]\n    const unlockedAddress = await this.unlock(hdPath)\n\n    // unlock resolves to the address for the given hdPath as reported by the ledger device\n    // if that address is not the requested address, then this account belongs to a different device or seed\n    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {\n      throw new Error(`Ledger: Account ${address} does not belong to the connected device`)\n    }\n    return hdPath\n  }\n\n  async signTypedData (withAccount, data, options = {}) {\n    const isV4 = options.version === 'V4'\n    if (!isV4) {\n      throw new Error('Ledger: Only version 4 of typed data signing is supported')\n    }\n\n    const {\n      domain,\n      types,\n      primaryType,\n      message,\n    } = sigUtil.TypedDataUtils.sanitizeData(data)\n    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, types, isV4).toString('hex')\n    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(primaryType, message, types, isV4).toString('hex')\n\n    const hdPath = await this.unlockAccountByAddress(withAccount)\n    const { success, payload } = await new Promise((resolve) => {\n      this._sendMessage({\n        action: 'ledger-sign-typed-data',\n        params: {\n          hdPath,\n          domainSeparatorHex,\n          hashStructMessageHex,\n        },\n      },\n      (result) => resolve(result))\n    })\n\n    if (success) {\n      let v = payload.v - 27\n      v = v.toString(16)\n      if (v.length < 2) {\n        v = `0${v}`\n      }\n      const signature = `0x${payload.r}${payload.s}${v}`\n      const addressSignedWith = sigUtil.recoverTypedSignature_v4({\n        data,\n        sig: signature,\n      })\n      if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {\n        throw new Error('Ledger: The signature doesnt match the right address')\n      }\n      return signature\n    }\n    throw payload.error || new Error('Ledger: Unknown error while signing message')\n  }\n\n  exportAccount () {\n    throw new Error('Not supported on this device')\n  }\n\n  forgetDevice () {\n    this.accounts = []\n    this.page = 0\n    this.unlockedAccount = 0\n    this.paths = {}\n    this.accountDetails = {}\n    this.hdk = new HDKey()\n  }\n\n  /* PRIVATE METHODS */\n\n  _setupIframe () {\n    this.iframe = document.createElement('iframe')\n    this.iframe.src = this.bridgeUrl\n    this.iframe.allow = `hid 'src'`\n    this.iframe.onload = async () => {\n      // If the ledger live preference was set before the iframe is loaded,\n      // set it after the iframe has loaded\n      this.iframeLoaded = true\n      if (this.delayedPromise) {\n        try {\n          const result = await this.updateTransportMethod(\n            this.delayedPromise.transportType,\n          )\n          this.delayedPromise.resolve(result)\n        } catch (e) {\n          this.delayedPromise.reject(e)\n        } finally {\n          delete this.delayedPromise\n        }\n      }\n    }\n    document.head.appendChild(this.iframe)\n  }\n\n  _getOrigin () {\n    const tmp = this.bridgeUrl.split('/')\n    tmp.splice(-1, 1)\n    return tmp.join('/')\n  }\n\n  _sendMessage (msg, cb) {\n    msg.target = 'LEDGER-IFRAME'\n    this.iframe.contentWindow.postMessage(msg, '*')\n    const eventListener = ({ origin, data }) => {\n      if (origin !== this._getOrigin()) {\n        return false\n      }\n\n      if (data && data.action && data.action === `${msg.action}-reply` && cb) {\n        cb(data)\n        return undefined\n      }\n\n      window.removeEventListener('message', eventListener)\n      return undefined\n    }\n    window.addEventListener('message', eventListener)\n  }\n\n  async __getPage (increment) {\n\n    this.page += increment\n\n    if (this.page <= 0) {\n      this.page = 1\n    }\n    const from = (this.page - 1) * this.perPage\n    const to = from + this.perPage\n\n    await this.unlock()\n    let accounts\n    if (this._isLedgerLiveHdPath()) {\n      accounts = await this._getAccountsBIP44(from, to)\n    } else {\n      accounts = this._getAccountsLegacy(from, to)\n    }\n    return accounts\n  }\n\n  async _getAccountsBIP44 (from, to) {\n    const accounts = []\n\n    for (let i = from; i < to; i++) {\n      const path = this._getPathForIndex(i)\n      const address = await this.unlock(path)\n      const valid = this.implementFullBIP44 ? await this._hasPreviousTransactions(address) : true\n      accounts.push({\n        address,\n        balance: null,\n        index: i,\n      })\n      // PER BIP44\n      // \"Software should prevent a creation of an account if\n      // a previous account does not have a transaction history\n      // (meaning none of its addresses have been used before).\"\n      if (!valid) {\n        break\n      }\n    }\n    return accounts\n  }\n\n  _getAccountsLegacy (from, to) {\n    const accounts = []\n\n    for (let i = from; i < to; i++) {\n      const address = this._addressFromIndex(pathBase, i)\n      accounts.push({\n        address,\n        balance: null,\n        index: i,\n      })\n      this.paths[ethUtil.toChecksumAddress(address)] = i\n    }\n    return accounts\n  }\n\n  _padLeftEven (hex) {\n    return hex.length % 2 === 0 ? hex : `0${hex}`\n  }\n\n  _normalize (buf) {\n    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())\n  }\n\n  // eslint-disable-next-line no-shadow\n  _addressFromIndex (pathBase, i) {\n    const dkey = this.hdk.derive(`${pathBase}/${i}`)\n    const address = ethUtil\n      .publicToAddress(dkey.publicKey, true)\n      .toString('hex')\n    return ethUtil.toChecksumAddress(`0x${address}`)\n  }\n\n  _pathFromAddress (address) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address)\n    let index = this.paths[checksummedAddress]\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n          index = i\n          break\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address')\n    }\n    return this._getPathForIndex(index)\n  }\n\n  _toAscii (hex) {\n    let str = ''\n    let i = 0\n    const l = hex.length\n    if (hex.substring(0, 2) === '0x') {\n      i = 2\n    }\n    for (; i < l; i += 2) {\n      const code = parseInt(hex.substr(i, 2), 16)\n      str += String.fromCharCode(code)\n    }\n\n    return str\n  }\n\n  _getPathForIndex (index) {\n    // Check if the path is BIP 44 (Ledger Live)\n    return this._isLedgerLiveHdPath() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}/${index}`\n  }\n\n  _isLedgerLiveHdPath () {\n    return this.hdPath === `m/44'/60'/0'/0/0`\n  }\n\n  _toLedgerPath (path) {\n    return path.toString().replace('m/', '')\n  }\n\n  async _hasPreviousTransactions (address) {\n    const apiUrl = this._getApiUrl()\n    const response = await window.fetch(`${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`)\n    const parsedResponse = await response.json()\n    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {\n      return true\n    }\n    return false\n  }\n\n  _getApiUrl () {\n    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet\n  }\n\n}\n\nLedgerBridgeKeyring.type = type\nmodule.exports = LedgerBridgeKeyring\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./block-cache\"), exports);\n__exportStar(require(\"./block-ref-rewrite\"), exports);\n__exportStar(require(\"./block-ref\"), exports);\n__exportStar(require(\"./block-tracker-inspector\"), exports);\n__exportStar(require(\"./fetch\"), exports);\n__exportStar(require(\"./inflight-cache\"), exports);\n__exportStar(require(\"./providerAsMiddleware\"), exports);\n__exportStar(require(\"./providerFromEngine\"), exports);\n__exportStar(require(\"./providerFromMiddleware\"), exports);\n__exportStar(require(\"./retryOnEmpty\"), exports);\n__exportStar(require(\"./wallet\"), exports);\n//# sourceMappingURL=index.js.map","const crypto = require('crypto');\nconst EventEmitter = require('events').EventEmitter;\nconst BN = require('bignumber.js');\nconst SDK = require('gridplus-sdk');\nconst EthTx = require('@ethereumjs/tx');\nconst Common = require('@ethereumjs/common').default;\nconst Util = require('ethereumjs-util');\nconst keyringType = 'Lattice Hardware';\nconst HARDENED_OFFSET = 0x80000000;\nconst PER_PAGE = 5;\nconst CLOSE_CODE = -1000;\nconst STANDARD_HD_PATH = `m/44'/60'/0'/0/x`;\nconst SDK_TIMEOUT = 120000;\nconst CONNECT_TIMEOUT = 20000;\n\nclass LatticeKeyring extends EventEmitter {\n  constructor (opts={}) {\n    super()\n    this.type = keyringType;\n    this._resetDefaults();\n    this.deserialize(opts);\n  }\n\n  //-------------------------------------------------------------------\n  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)\n  //-------------------------------------------------------------------\n  deserialize (opts = {}) {\n    if (opts.hdPath)\n      this.hdPath = opts.hdPath;\n    if (opts.creds)\n      this.creds = opts.creds;\n    if (opts.accounts)\n      this.accounts = opts.accounts;\n    if (opts.accountIndices)\n      this.accountIndices = opts.accountIndices;\n    if (opts.accountOpts)\n      this.accountOpts = opts.accountOpts;\n    if (opts.walletUID)\n      this.walletUID = opts.walletUID;\n    if (opts.name)  // Legacy; use is deprecated and appName is more descriptive\n      this.appName = opts.name;\n    if (opts.appName)\n      this.appName = opts.appName;\n    if (opts.network)\n      this.network = opts.network;\n    if (opts.page)\n      this.page = opts.page;\n    if (opts.sdkState)\n      this.sdkState = opts.sdkState;\n    return Promise.resolve()\n  }\n\n  setHdPath(hdPath) {\n    this.hdPath = hdPath;\n  }\n\n  serialize() {\n    return Promise.resolve({\n      creds: this.creds,\n      accounts: this.accounts,\n      accountIndices: this.accountIndices,\n      accountOpts: this.accountOpts,\n      walletUID: this.walletUID,\n      appName: this.appName,\n      name: this.name,  // Legacy; use is deprecated\n      network: this.network,\n      page: this.page,\n      hdPath: this.hdPath,\n      sdkState: this.sdkSession ? \n                this.sdkSession.getStateData() :\n                null\n    })\n  }\n\n  // Deterimine if we have a connection to the Lattice and an existing wallet UID\n  // against which to make requests.\n  isUnlocked () {\n    return !!this._getCurrentWalletUID() && !!this.sdkSession;\n  }\n\n  // Initialize a session with the Lattice1 device using the GridPlus SDK\n  // NOTE: `bypassOnStateData=true` allows us to rehydrate a new SDK session without\n  // reconnecting to the target Lattice. This is only currently used for signing \n  // because it eliminates the need for 2 connection requests and shaves off ~4-6sec.\n  // We avoid passing `bypassOnStateData=true` for other calls on `unlock` to avoid\n  // possible edge cases related to this new functionality (it's probably fine - just\n  // being cautious). In the future we may remove `bypassOnStateData` entirely.\n  unlock(bypassOnStateData=false) {\n    return new Promise((resolve, reject) => {\n      // Force compatability. `this.accountOpts` were added after other\n      // state params and must be synced in order for this keyring to function.\n      if ((!this.accountOpts) || \n          (this.accounts.length > 0 && this.accountOpts.length != this.accounts.length)) \n      {\n        this.forgetDevice();\n        return reject(new Error(\n          'You can now add multiple Lattice and SafeCard accounts at the same time! ' +\n          'Your accounts have been cleared. Please press Continue to add them back in.'\n        ));\n      }\n\n      if (this.isUnlocked() && !this.forceReconnect) {\n        return resolve('Unlocked');\n      }\n      \n      this._getCreds()\n      .then((creds) => {\n        if (creds) {\n          this.creds.deviceID = creds.deviceID;\n          this.creds.password = creds.password;\n          this.creds.endpoint = creds.endpoint || null;\n        }\n        return this._initSession();\n      })\n      .then((includedStateData) => {\n        // If state data was provided and if we are authorized to \n        // bypass reconnecting, we can exit here.\n        if (includedStateData && bypassOnStateData) {\n          return resolve('Unlocked');\n        }\n        return this._connect();\n      })\n      .then(() => {\n        return resolve('Unlocked');\n      })\n      .catch((err) => {\n        return reject(new Error(err));\n      })\n    })\n  }\n\n  // Add addresses to the local store and return the full result\n  addAccounts(n=1) {\n    return new Promise((resolve, reject) => {\n      if (n === CLOSE_CODE) {\n        // Special case: use a code to forget the device. \n        // (This function is overloaded due to constraints upstream)\n        this.forgetDevice();\n        return resolve([]);\n      } else if (n <= 0) {\n        // Avoid non-positive numbers.\n        return reject('Number of accounts to add must be a positive number.');\n      } else {\n        // Normal behavior: establish the connection and fetch addresses.\n        this.unlock()\n        .then(() => {\n          return this._fetchAddresses(n, this.unlockedAccount)\n        })\n        .then((addrs) => {\n          const walletUID = this._getCurrentWalletUID();\n          // Add these indices\n          addrs.forEach((addr, i) => {\n            let alreadySaved = false;\n            for (let j = 0; j < this.accounts.length; j++) {\n              if ((this.accounts[j] === addr) && \n                  (this.accountOpts[j].walletUID === walletUID) &&\n                  (this.accountOpts[j].hdPath === this.hdPath))\n                alreadySaved = true;\n            }\n            if (!alreadySaved) {\n              this.accounts.push(addr);\n              this.accountIndices.push(this.unlockedAccount+i);\n              this.accountOpts.push({\n                walletUID,\n                hdPath: this.hdPath,\n              })\n            }\n          })\n          return resolve(this.accounts);\n        })\n        .catch((err) => {\n          return reject(new Error(err));\n        })\n      }\n    })\n  }\n\n  // Return the local store of addresses. This gets called when the extension unlocks.\n  getAccounts() {\n    return Promise.resolve(this.accounts ? this.accounts.slice() : [].slice());\n  }\n\n  signTransaction (address, tx) {\n    return new Promise((resolve, reject) => {\n      this._findSignerIdx(address)\n      .then((accountIdx) => {\n        try {\n          // Build the Lattice request data and make request\n          // We expect `tx` to be an `ethereumjs-tx` object, meaning all fields are bufferized\n          // To ensure everything plays nicely with gridplus-sdk, we convert everything to hex strings\n          const addressIdx = this.accountIndices[accountIdx];\n          const addressParentPath = this.accountOpts[accountIdx].hdPath;\n          const txData = {\n            chainId: `0x${this._getEthereumJsChainId(tx).toString('hex')}` || 1,\n            nonce: `0x${tx.nonce.toString('hex')}` || 0,\n            gasLimit: `0x${tx.gasLimit.toString('hex')}`,\n            to: !!tx.to ? tx.to.toString('hex') : null, // null for contract deployments\n            value: `0x${tx.value.toString('hex')}`,\n            data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,\n            signerPath: this._getHDPathIndices(addressParentPath, addressIdx),\n          }\n          switch (tx._type) {\n            case 2: // eip1559\n              if ((tx.maxPriorityFeePerGas === null || tx.maxFeePerGas === null) ||\n                  (tx.maxPriorityFeePerGas === undefined || tx.maxFeePerGas === undefined))\n                throw new Error('`maxPriorityFeePerGas` and `maxFeePerGas` must be included for EIP1559 transactions.');\n              txData.maxPriorityFeePerGas = `0x${tx.maxPriorityFeePerGas.toString('hex')}`;\n              txData.maxFeePerGas = `0x${tx.maxFeePerGas.toString('hex')}`;\n              txData.accessList = tx.accessList || [];\n              txData.type = 2;\n              break;\n            case 1: // eip2930\n              txData.accessList = tx.accessList || [];\n              txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;\n              txData.type = 1;\n              break;\n            default: // legacy\n              txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;\n              txData.type = null;\n              break;\n          }\n          // Lattice firmware v0.11.0 implemented EIP1559 and EIP2930 so for previous verisons\n          // we need to overwrite relevant params and revert to legacy type.\n          // Note: `this.sdkSession.fwVersion is of format [fix, minor, major, reserved]\n          const forceLegacyTx = this.sdkSession.fwVersion[2] < 1 && \n                                this.sdkSession.fwVersion[1] < 11;\n          if (forceLegacyTx && txData.type === 2) {\n            txData.gasPrice = txData.maxFeePerGas;\n            txData.revertToLegacy = true;\n            delete txData.type;\n            delete txData.maxFeePerGas;\n            delete txData.maxPriorityFeePerGas;\n            delete txData.accessList;\n          } else if (forceLegacyTx && txData.type === 1) {\n            txData.revertToLegacy = true;\n            delete txData.type;\n            delete txData.accessList;\n          }\n          // Get the signature\n          return this._signTxData(txData)\n        } catch (err) {\n          throw new Error(`Failed to build transaction.`)\n        }\n      })\n      .then((signedTx) => {\n        // Add the sig params. `signedTx = { sig: { v, r, s }, tx, txHash}`\n        if (!signedTx.sig || !signedTx.sig.v || !signedTx.sig.r || !signedTx.sig.s)\n          return reject(new Error('No signature returned.'));\n        const txToReturn = tx.toJSON();\n        const v = signedTx.sig.v.length === 0 ? '0' : signedTx.sig.v.toString('hex')\n        txToReturn.r = Util.addHexPrefix(signedTx.sig.r.toString('hex'));\n        txToReturn.s = Util.addHexPrefix(signedTx.sig.s.toString('hex'));\n        txToReturn.v = Util.addHexPrefix(v);\n\n        if (signedTx.revertToLegacy === true) {\n          // If firmware does not support an EIP1559/2930 transaction we revert to legacy\n          txToReturn.type = 0;\n          txToReturn.gasPrice = signedTx.gasPrice;\n        } else {\n          // Otherwise relay the tx type\n          txToReturn.type = signedTx.type;\n        }\n\n        // Build the tx for export\n        let validatingTx;\n        const _chainId = `0x${this._getEthereumJsChainId(tx).toString('hex')}`;\n        const chainId = new BN(_chainId).toNumber();\n        const customNetwork = Common.forCustomChain('mainnet', {\n          name: 'notMainnet',\n          networkId: chainId,\n          chainId: chainId,\n        }, 'london')\n\n        validatingTx = EthTx.TransactionFactory.fromTxData(txToReturn, {\n          common: customNetwork, freeze: Object.isFrozen(tx)\n        })\n        return resolve(validatingTx);\n      })\n      .catch((err) => {\n        return reject(new Error(err));\n      })\n    })\n  }\n\n  signPersonalMessage(address, msg) {\n    return this.signMessage(address, { payload: msg, protocol: 'signPersonal' });\n  }\n\n  signTypedData(address, msg, opts) {\n    if (opts.version && (opts.version !== 'V4' && opts.version !== 'V3'))\n      throw new Error(`Only signTypedData V3 and V4 messages (EIP712) are supported. Got version ${opts.version}`);\n    return this.signMessage(address, { payload: msg, protocol: 'eip712' })\n  }\n\n  signMessage(address, msg) {\n    return new Promise((resolve, reject) => {\n      this._findSignerIdx(address)\n      .then((accountIdx) => {\n        let { payload, protocol } = msg;\n        // If the message is not an object we assume it is a legacy signPersonal request\n        if (!payload || !protocol) {\n          payload = msg;\n          protocol = 'signPersonal';\n        }\n        const addressIdx = this.accountIndices[accountIdx];\n        const addressParentPath = this.accountOpts[accountIdx].hdPath;\n        const req = {\n          currency: 'ETH_MSG',\n          data: {\n            protocol,\n            payload,\n            signerPath: this._getHDPathIndices(addressParentPath, addressIdx),\n          }\n        }\n        this.sdkSession.sign(req, (err, res) => {\n          if (err) {\n            return reject(new Error(err));\n          }\n          if (!this._syncCurrentWalletUID()) {\n            return reject('No active wallet.');\n          }\n          if (!res.sig) {\n            return reject(new Error('No signature returned'));\n          }\n          // Convert the `v` to a number. It should convert to 0 or 1\n          try {\n            let v = res.sig.v.toString('hex');\n            if (v.length < 2) {\n              v = `0${v}`;\n            }\n            return resolve(`0x${res.sig.r}${res.sig.s}${v}`);\n          } catch (err) {\n            return reject(new Error('Invalid signature format returned.'))\n          }\n        })\n      })\n      .catch((err) => {\n        return reject(new Error(err));\n      })\n    })\n  }\n\n  exportAccount(address) {\n    return Promise.reject(Error('exportAccount not supported by this device'))\n  }\n\n  removeAccount(address) {\n    this.accounts.forEach((account, i) => {\n      if (account.toLowerCase() === address.toLowerCase()) {\n        this.accounts.splice(i, 1);\n        this.accountIndices.splice(i, 1);\n        this.accountOpts.splice(i, 1);\n        return;\n      }\n    })\n  }\n\n  getFirstPage() {\n    // This function gets called after the user has connected to the Lattice.\n    // Update a state variable to force opening of the Lattice manager window.\n    // If we don't do this, MetaMask will automatically start requesting addresses,\n    // even if the device is not reachable.\n    // This way the user can close the window and connect accounts from other\n    // wallets instead of being forced into selecting Lattice accounts\n    this.forceReconnect = true;\n    this.page = 0;\n    return this._getPage(0);\n  }\n\n  getNextPage () {\n    return this._getPage(1);\n  }\n\n  getPreviousPage () {\n    return this._getPage(-1);\n  }\n\n  setAccountToUnlock (index) {\n    this.unlockedAccount = parseInt(index, 10)\n  }\n\n  forgetDevice () {\n    this._resetDefaults();\n  }\n\n  //-------------------------------------------------------------------\n  // Internal methods and interface to SDK\n  //-------------------------------------------------------------------\n  // Find the account index of the requested address.\n  // Note that this is the BIP39 path index, not the index in the address cache.\n  _findSignerIdx(address) {\n    return new Promise((resolve, reject) => {\n      // Unlock and get the wallet UID. We will bypass the reconnection\n      // step if we are able to rehydrate an SDK session with state data.\n      this.unlock(true)\n      .then(() => {\n        return this._ensureCurrentWalletUID();\n      })\n      .then(() => {\n        return this.getAccounts();\n      })\n      .then((addrs) => {\n        // Find the signer in our current set of accounts\n        // If we can't find it, return an error\n        let accountIdx = null;\n        addrs.forEach((addr, i) => {\n          if (address.toLowerCase() === addr.toLowerCase())\n            accountIdx = i;\n        })\n        if (accountIdx === null) {\n          return reject('Signer not present');\n        }\n        return resolve(accountIdx);\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n\n  _getHDPathIndices(hdPath, insertIdx=0) {\n    const path = hdPath.split('/').slice(1);\n    const indices = [];\n    let usedX = false;\n    path.forEach((_idx) => {\n      const isHardened = (_idx[_idx.length - 1] === \"'\");\n      let idx = isHardened ? HARDENED_OFFSET : 0;\n      // If there is an `x` in the path string, we will use it to insert our\n      // index. This is useful for e.g. Ledger Live path. Most paths have the\n      // changing index as the last one, so having an `x` in the path isn't\n      // usually necessary.\n      if (_idx.indexOf('x') > -1) {\n        idx += insertIdx;\n        usedX = true;\n      } else if (isHardened) {\n        idx += Number(_idx.slice(0, _idx.length - 1));\n      } else {\n        idx += Number(_idx);\n      }\n      indices.push(idx);\n    })\n    // If this path string does not include an `x`, we just append the index\n    // to the end of the extracted set\n    if (usedX === false) {\n      indices.push(insertIdx);\n    }\n    // Sanity check -- Lattice firmware will throw an error for large paths\n    if (indices.length > 5)\n      throw new Error('Only HD paths with up to 5 indices are allowed.')\n    return indices;\n  }\n\n  _resetDefaults() {\n    this.accounts = [];\n    this.accountIndices = [];\n    this.accountOpts = [];\n    this.isLocked = true;\n    this.creds = {\n      deviceID: null,\n      password: null,\n      endpoint: null,\n    };\n    this.walletUID = null;\n    this.sdkSession = null;\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.network = null;\n    this.hdPath = STANDARD_HD_PATH;\n  }\n\n  _openConnectorTab(url) {\n    return new Promise((resolve, reject) => {\n      const browserTab = window.open(url);\n      // Preferred option for Chromium browsers. This extension runs in a window\n      // for Chromium so we can do window-based communication very easily.\n      if (browserTab) {\n        return resolve({ chromium: browserTab });\n      } else if (browser && browser.tabs && browser.tabs.create) {\n        // FireFox extensions do not run in windows, so it will return `null` from\n        // `window.open`. Instead, we need to use the `browser` API to open a tab. \n        // We will surveille this tab to see if its URL parameters change, which \n        // will indicate that the user has logged in.\n        browser.tabs.create({url})\n        .then((tab) => {\n          return resolve({ firefox: tab });\n        })\n        .catch((err) => {\n          return reject(new Error('Failed to open Lattice connector.'))\n        })\n      } else {\n        return reject(new Error('Unknown browser context. Cannot open Lattice connector.'))\n      }\n\n    })\n  }\n\n  _findTabById(id) {\n    return new Promise((resolve, reject) => {\n      browser.tabs.query({})\n      .then((tabs) => {\n        tabs.forEach((tab) => {\n          if (tab.id === id) {\n            return resolve(tab);\n          }\n        })\n        return resolve(null);\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n  \n  _getCreds() {\n    return new Promise((resolve, reject) => {\n      // We only need to setup if we don't have a deviceID\n      if (this._hasCreds() && !this.forceReconnect)\n        return resolve();\n      // Cancel the force reconnect, if applicable\n      this.forceReconnect = false;\n      // If we are not aware of what Lattice we should be talking to,\n      // we need to open a window that lets the user go through the\n      // pairing or connection process.\n      const name = this.appName ? this.appName : 'Unknown'\n      const base = 'https://lattice.gridplus.io';\n      const url = `${base}?keyring=${name}&forceLogin=true`;\n      let listenInterval;\n\n      // PostMessage handler\n      function receiveMessage(event) {\n        // Ensure origin\n        if (event.origin !== base)\n          return;\n        try {\n          // Stop the listener\n          clearInterval(listenInterval);\n          // Parse and return creds\n          const creds = JSON.parse(event.data);\n          if (!creds.deviceID || !creds.password)\n            return reject(new Error('Invalid credentials returned from Lattice.'));\n          return resolve(creds);\n        } catch (err) {\n          return reject(err);\n        }\n      }\n\n      // Open the tab\n      this._openConnectorTab(url)\n      .then((conn) => {\n        if (conn.chromium) {\n          // On a Chromium browser we can just listen for a window message\n          window.addEventListener(\"message\", receiveMessage, false);\n          // Watch for the open window closing before creds are sent back\n          listenInterval = setInterval(() => {\n            if (conn.chromium.closed) {\n              clearInterval(listenInterval);\n              return reject(new Error('Lattice connector closed.'));\n            }\n          }, 500);\n        } else if (conn.firefox) {\n          // For Firefox we cannot use `window` in the extension and can't\n          // directly communicate with the tabs very easily so we use a\n          // workaround: listen for changes to the URL, which will contain\n          // the login info.\n          // NOTE: This will only work if have `https://lattice.gridplus.io/*`\n          // host permissions in your manifest file (and also `activeTab` permission)\n          const loginUrlParam = '&loginCache=';\n          listenInterval = setInterval(() => {\n            this._findTabById(conn.firefox.id)\n            .then((tab) => {\n              if (!tab || !tab.url) {\n                return reject(new Error('Lattice connector closed.'));\n              }\n              // If the tab we opened contains a new URL param\n              const paramLoc = tab.url.indexOf(loginUrlParam);\n              if (paramLoc < 0) \n                return;\n              const dataLoc = paramLoc + loginUrlParam.length;\n              // Stop this interval\n              clearInterval(listenInterval);\n              try {\n                // Parse the login data. It is a stringified JSON object \n                // encoded as a base64 string.\n                const _creds = Buffer.from(tab.url.slice(dataLoc), 'base64').toString();\n                // Close the tab and return the credentials\n                browser.tabs.remove(tab.id)\n                .then(() => {\n                  const creds = JSON.parse(_creds);\n                  if (!creds.deviceID || !creds.password)\n                    return reject(new Error('Invalid credentials returned from Lattice.'));\n                  return resolve(creds);\n                })\n              } catch (err) {\n                return reject('Failed to get login data from Lattice. Please try again.')\n              }\n            })\n          }, 500);\n        }\n      })\n    })\n  }\n\n  // [re]connect to the Lattice. This should be done frequently to ensure\n  // the expected wallet UID is still the one active in the Lattice.\n  // This will handle SafeCard insertion/removal events.\n  _connect() {\n    return new Promise((resolve, reject) => {\n      // Attempt to connect with a Lattice using a shorter timeout. If\n      // the device is unplugged it will time out and we don't need to wait\n      // 2 minutes for that to happen.\n      this.sdkSession.timeout = CONNECT_TIMEOUT;\n      this.sdkSession.connect(this.creds.deviceID, (err) => {\n        this.sdkSession.timeout = SDK_TIMEOUT;\n        if (err) {\n          return reject(err);\n        }\n        if (!this._syncCurrentWalletUID()) {\n          return reject('No active wallet.');\n        }\n        return resolve();\n      });\n    })\n  }\n\n  _initSession() {\n    return new Promise((resolve, reject) => {\n      if (this.isUnlocked()) {\n        return resolve();\n      }\n      try {\n        let url = 'https://signing.gridpl.us';\n        if (this.creds.endpoint)\n          url = this.creds.endpoint\n        let setupData;\n        if (this.sdkState) {\n          // If we have state data we can fully rehydrate the session.\n          setupData = {\n            stateData: this.sdkState\n          }\n        } else {\n          // If we have no state data, we need to create a session.\n          // Its state will be saved once the connection is established.\n          setupData = {\n            name: this.appName,\n            baseUrl: url,\n            timeout: SDK_TIMEOUT,\n            privKey: this._genSessionKey(),\n            network: this.network,\n          }\n        }\n        this.sdkSession = new SDK.Client(setupData);\n        // Return a boolean indicating whether we provided state data.\n        // If we have, we can skip `connect`.\n        return resolve(!!setupData.stateData);\n      } catch (err) {\n        return reject(err);\n      }\n    })\n  }\n\n  _fetchAddresses(n=1, i=0, recursedAddrs=[]) {\n    return new Promise((resolve, reject) => {\n      if (!this.isUnlocked()) {\n        return reject('No connection to Lattice. Cannot fetch addresses.')\n      }\n      this.__fetchAddresses(n, i, (err, addrs) => {\n        if (err) {\n          return reject(err);\n        }\n        return resolve(addrs);\n      })\n    })\n  }\n\n  __fetchAddresses(n=1, i=0, cb, recursedAddrs=[]) {\n     // Determine if we need to do a recursive call here. We prefer not to\n      // because they will be much slower, but Ledger paths require it since\n      // they are non-standard.\n      if (n === 0)\n        return cb(null, recursedAddrs);\n      const shouldRecurse = this._hdPathHasInternalVarIdx();\n\n      // Make the request to get the requested address\n      const addrData = { \n        currency: 'ETH', \n        startPath: this._getHDPathIndices(this.hdPath, i), \n        n: shouldRecurse ? 1 : n,\n        skipCache: true,\n      };\n      this.sdkSession.getAddresses(addrData, (err, addrs) => {\n        if (err)\n          return cb(err);\n        if (!this._syncCurrentWalletUID()) {\n          return cb(new Error('No active wallet.'));\n        }\n        // Sanity check -- if this returned 0 addresses, handle the error\n        if (addrs.length < 1) {\n          return cb(new Error('No addresses returned'));\n        }\n        // Return the addresses we fetched *without* updating state\n        if (shouldRecurse) {\n          return this.__fetchAddresses(n-1, i+1, cb, recursedAddrs.concat(addrs));\n        } else {\n          return cb(null, addrs);\n        }\n      })\n  }\n\n  _signTxData(txData) {\n    return new Promise((resolve, reject) => {\n      this.sdkSession.sign({ currency: 'ETH', data: txData }, (err, res) => {\n        if (err) {\n          return reject(err);\n        }\n        if (!this._syncCurrentWalletUID()) {\n          return reject('No active wallet.');\n        }\n        if (!res.tx) {\n          return reject(new Error('No transaction payload returned.'));\n        }\n        // Here we catch an edge case where the requester is asking for an EIP1559\n        // transaction but firmware is not updated to support it. We fallback to legacy.\n        res.type = txData.type;\n        if (txData.revertToLegacy) {\n          res.revertToLegacy = true;\n          res.gasPrice = txData.gasPrice;\n        }\n        // Return the signed tx\n        return resolve(res)\n      })\n    })\n  }\n\n  _getPage(increment=0) {\n    return new Promise((resolve, reject) => {\n      this.page += increment;\n      if (this.page < 0)\n        this.page = 0;\n      const start = PER_PAGE * this.page;\n      // Otherwise unlock the device and fetch more addresses\n      this.unlock()\n      .then(() => {\n        return this._fetchAddresses(PER_PAGE, start)\n      })\n      .then((addrs) => {\n        const accounts = []\n        addrs.forEach((address, i) => {\n          accounts.push({\n            address,\n            balance: null,\n            index: start + i,\n          })\n        })\n        return resolve(accounts)\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n\n  _hasCreds() {\n    return this.creds.deviceID !== null && this.creds.password !== null && this.appName;\n  }\n\n  _genSessionKey() {\n    if (this.name && !this.appName) // Migrate from legacy param if needed\n      this.appName = this.name;\n    if (!this._hasCreds())\n      throw new Error('No credentials -- cannot create session key!');\n    const buf = Buffer.concat([\n      Buffer.from(this.creds.password), \n      Buffer.from(this.creds.deviceID), \n      Buffer.from(this.appName)\n    ])\n    return crypto.createHash('sha256').update(buf).digest();\n  }\n\n  // Determine if an HD path has a variable index internal to it.\n  // e.g. m/44'/60'/x'/0/0 -> true, while m/44'/60'/0'/0/x -> false\n  // This is just a hacky helper to avoid having to recursively call for non-ledger\n  // derivation paths. Ledger is SO ANNOYING TO SUPPORT.\n  _hdPathHasInternalVarIdx() {\n    const path = this.hdPath.split('/').slice(1);\n    for (let i = 0; i < path.length -1; i++) {\n      if (path[i].indexOf('x') > -1)\n        return true;\n    }\n    return false;\n  }\n\n  // Get the chainId for whatever object this is.\n  // Returns a hex string without the 0x prefix\n  _getEthereumJsChainId(tx) {\n    if (typeof tx.getChainId === 'function')\n      return tx.getChainId();\n    else if (tx.common && typeof tx.common.chainIdBN === 'function')\n      return tx.common.chainIdBN().toString(16);\n    else if (typeof tx.chainId === 'number')\n      return tx.chainId.toString(16);\n    else if (typeof tx.chainId === 'string')\n      return tx.chainId;\n    return '1';\n  }\n\n  _getCurrentWalletUID() {\n    return this.walletUID || null;\n  }\n\n  // The SDK has an auto-retry mechanism for all requests if a \"wrong wallet\"\n  // error gets thrown. In such a case, the SDK will re-connect to the device to\n  // find the new wallet UID and will then save that UID to memory and will retry\n  // the original request with that new wallet UID.\n  // Therefore, we should sync the walletUID with `this.walletUID` after each\n  // SDK request. This is a synchronous and fast operation.\n  _syncCurrentWalletUID() {\n    if (!this.sdkSession) {\n      return null;\n    }\n    const activeWallet = this.sdkSession.getActiveWallet();\n    if (!activeWallet || !activeWallet.uid) {\n      return null;\n    }\n    const newUID = activeWallet.uid.toString('hex');\n    // If we fetched a walletUID that does not match our current one,\n    // reset accounts and update the known UID\n    if (newUID != this.walletUID) {\n      this.walletUID = newUID;\n    }\n    return this.walletUID;\n  }\n\n  // Make sure we have an SDK connection and, therefore, an active wallet UID.\n  // If we do not, force an unlock, which adds ~5 seconds to the request.\n  _ensureCurrentWalletUID() {\n    return new Promise((resolve, reject) => {\n      if (!!this._getCurrentWalletUID()) {\n        return resolve();\n      }\n      this.unlock()\n      .then(() => {\n        if (!!this._getCurrentWalletUID()) {\n          return resolve()\n        } else {\n          return reject('Could not access Lattice wallet. Please re-connect.')\n        }\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n\n}\n\nLatticeKeyring.type = keyringType\nmodule.exports = LatticeKeyring;","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// eslint-disable-next-line import/no-unassigned-import\nrequire(\"isomorphic-fetch\");\nconst SmartTransactionsController_1 = __importDefault(require(\"./SmartTransactionsController\"));\nexports.default = SmartTransactionsController_1.default;\n//# sourceMappingURL=index.js.map","import { strict as assert } from 'assert';\nimport { ObservableStore } from '@metamask/obs-store';\nimport { normalize as normalizeAddress } from 'eth-sig-util';\nimport { ethers } from 'ethers';\nimport log from 'loglevel';\nimport {\n  IPFS_DEFAULT_GATEWAY_URL,\n  NETWORK_TYPE_TO_ID_MAP,\n} from '../../../shared/constants/network';\nimport { isPrefixedFormattedHexString } from '../../../shared/modules/network.utils';\nimport { LEDGER_TRANSPORT_TYPES } from '../../../shared/constants/hardware-wallets';\nimport { NETWORK_EVENTS } from './network';\n\nexport default class PreferencesController {\n  /**\n   *\n   * @typedef {Object} PreferencesController\n   * @param {Object} opts - Overrides the defaults for the initial state of this.store\n   * @property {Object} store The stored object containing a users preferences, stored in local storage\n   * @property {Array} store.frequentRpcList A list of custom rpcs to provide the user\n   * @property {boolean} store.useBlockie The users preference for blockie identicons within the UI\n   * @property {boolean} store.useNonceField The users preference for nonce field within the UI\n   * @property {Object} store.featureFlags A key-boolean map, where keys refer to features and booleans to whether the\n   * user wishes to see that feature.\n   *\n   * Feature flags can be set by the global function `setPreference(feature, enabled)`, and so should not expose any sensitive behavior.\n   * @property {Object} store.knownMethodData Contains all data methods known by the user\n   * @property {string} store.currentLocale The preferred language locale key\n   * @property {string} store.selectedAddress A hex string that matches the currently selected address in the app\n   */\n  constructor(opts = {}) {\n    const initState = {\n      frequentRpcListDetail: [],\n      useBlockie: false,\n      useNonceField: false,\n      usePhishDetect: true,\n      dismissSeedBackUpReminder: false,\n\n      // set to true means the dynamic list from the API is being used\n      // set to false will be using the static list from contract-metadata\n      useTokenDetection: false,\n      useCollectibleDetection: false,\n      openSeaEnabled: false,\n      advancedGasFee: null,\n\n      // WARNING: Do not use feature flags for security-sensitive things.\n      // Feature flag toggling is available in the global namespace\n      // for convenient testing of pre-release features, and should never\n      // perform sensitive operations.\n      featureFlags: {\n        showIncomingTransactions: true,\n      },\n      knownMethodData: {},\n      currentLocale: opts.initLangCode,\n      identities: {},\n      lostIdentities: {},\n      forgottenPassword: false,\n      preferences: {\n        autoLockTimeLimit: undefined,\n        showFiatInTestnets: false,\n        showTestNetworks: false,\n        useNativeCurrencyAsPrimaryCurrency: true,\n        hideZeroBalanceTokens: false,\n      },\n      // ENS decentralized website resolution\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      infuraBlocked: null,\n      ledgerTransportType: window.navigator.hid\n        ? LEDGER_TRANSPORT_TYPES.WEBHID\n        : LEDGER_TRANSPORT_TYPES.U2F,\n      ...opts.initState,\n    };\n\n    this.network = opts.network;\n    this.ethersProvider = new ethers.providers.Web3Provider(opts.provider);\n    this.store = new ObservableStore(initState);\n    this.store.setMaxListeners(12);\n    this.openPopup = opts.openPopup;\n    this.migrateAddressBookState = opts.migrateAddressBookState;\n\n    this._subscribeToInfuraAvailability();\n\n    global.setPreference = (key, value) => {\n      return this.setFeatureFlag(key, value);\n    };\n  }\n  // PUBLIC METHODS\n\n  /**\n   * Sets the {@code forgottenPassword} state property\n   *\n   * @param {boolean} forgottenPassword - whether or not the user has forgotten their password\n   */\n  setPasswordForgotten(forgottenPassword) {\n    this.store.updateState({ forgottenPassword });\n  }\n\n  /**\n   * Setter for the `useBlockie` property\n   *\n   * @param {boolean} val - Whether or not the user prefers blockie indicators\n   */\n  setUseBlockie(val) {\n    this.store.updateState({ useBlockie: val });\n  }\n\n  /**\n   * Setter for the `useNonceField` property\n   *\n   * @param {boolean} val - Whether or not the user prefers to set nonce\n   */\n  setUseNonceField(val) {\n    this.store.updateState({ useNonceField: val });\n  }\n\n  /**\n   * Setter for the `usePhishDetect` property\n   *\n   * @param {boolean} val - Whether or not the user prefers phishing domain protection\n   */\n  setUsePhishDetect(val) {\n    this.store.updateState({ usePhishDetect: val });\n  }\n\n  /**\n   * Setter for the `useTokenDetection` property\n   *\n   * @param {boolean} val - Whether or not the user prefers to use the static token list or dynamic token list from the API\n   */\n  setUseTokenDetection(val) {\n    this.store.updateState({ useTokenDetection: val });\n  }\n\n  /**\n   * Setter for the `useCollectibleDetection` property\n   *\n   * @param {boolean} useCollectibleDetection - Whether or not the user prefers to autodetect collectibles.\n   */\n  setUseCollectibleDetection(useCollectibleDetection) {\n    this.store.updateState({ useCollectibleDetection });\n  }\n\n  /**\n   * Setter for the `openSeaEnabled` property\n   *\n   * @param {boolean} openSeaEnabled - Whether or not the user prefers to use the OpenSea API for collectibles data.\n   */\n  setOpenSeaEnabled(openSeaEnabled) {\n    this.store.updateState({\n      openSeaEnabled,\n    });\n  }\n\n  /**\n   * Setter for the `advancedGasFee` property\n   *\n   * @param {object} val - holds the maxBaseFee and PriorityFee that the user set as default advanced settings.\n   */\n  setAdvancedGasFee(val) {\n    this.store.updateState({ advancedGasFee: val });\n  }\n\n  /**\n   * Setter for the `eip1559V2Enabled` property\n   *\n   * @param {object} val - holds the eip1559V2Enabled that the user set as experimental settings.\n   */\n  setEIP1559V2Enabled(val) {\n    this.store.updateState({ eip1559V2Enabled: val });\n  }\n\n  /**\n   * Add new methodData to state, to avoid requesting this information again through Infura\n   *\n   * @param {string} fourBytePrefix - Four-byte method signature\n   * @param {string} methodData - Corresponding data method\n   */\n  addKnownMethodData(fourBytePrefix, methodData) {\n    const { knownMethodData } = this.store.getState();\n    knownMethodData[fourBytePrefix] = methodData;\n    this.store.updateState({ knownMethodData });\n  }\n\n  /**\n   * Setter for the `currentLocale` property\n   *\n   * @param {string} key - he preferred language locale key\n   */\n  setCurrentLocale(key) {\n    const textDirection = ['ar', 'dv', 'fa', 'he', 'ku'].includes(key)\n      ? 'rtl'\n      : 'auto';\n    this.store.updateState({\n      currentLocale: key,\n      textDirection,\n    });\n    return textDirection;\n  }\n\n  /**\n   * Updates identities to only include specified addresses. Removes identities\n   * not included in addresses array\n   *\n   * @param {string[]} addresses - An array of hex addresses\n   */\n  setAddresses(addresses) {\n    const oldIdentities = this.store.getState().identities;\n\n    const identities = addresses.reduce((ids, address, index) => {\n      const oldId = oldIdentities[address] || {};\n      ids[address] = { name: `Account ${index + 1}`, address, ...oldId };\n      return ids;\n    }, {});\n\n    this.store.updateState({ identities });\n  }\n\n  /**\n   * Removes an address from state\n   *\n   * @param {string} address - A hex address\n   * @returns {string} the address that was removed\n   */\n  removeAddress(address) {\n    const { identities } = this.store.getState();\n\n    if (!identities[address]) {\n      throw new Error(`${address} can't be deleted cause it was not found`);\n    }\n    delete identities[address];\n    this.store.updateState({ identities });\n\n    // If the selected account is no longer valid,\n    // select an arbitrary other account:\n    if (address === this.getSelectedAddress()) {\n      const selected = Object.keys(identities)[0];\n      this.setSelectedAddress(selected);\n    }\n    return address;\n  }\n\n  /**\n   * Adds addresses to the identities object without removing identities\n   *\n   * @param {string[]} addresses - An array of hex addresses\n   */\n  addAddresses(addresses) {\n    const { identities } = this.store.getState();\n    addresses.forEach((address) => {\n      // skip if already exists\n      if (identities[address]) {\n        return;\n      }\n      // add missing identity\n      const identityCount = Object.keys(identities).length;\n\n      identities[address] = { name: `Account ${identityCount + 1}`, address };\n    });\n    this.store.updateState({ identities });\n  }\n\n  /**\n   * Synchronizes identity entries with known accounts.\n   * Removes any unknown identities, and returns the resulting selected address.\n   *\n   * @param {Array<string>} addresses - known to the vault.\n   * @returns {Promise<string>} selectedAddress the selected address.\n   */\n  syncAddresses(addresses) {\n    if (!Array.isArray(addresses) || addresses.length === 0) {\n      throw new Error('Expected non-empty array of addresses. Error #11201');\n    }\n\n    const { identities, lostIdentities } = this.store.getState();\n\n    const newlyLost = {};\n    Object.keys(identities).forEach((identity) => {\n      if (!addresses.includes(identity)) {\n        newlyLost[identity] = identities[identity];\n        delete identities[identity];\n      }\n    });\n\n    // Identities are no longer present.\n    if (Object.keys(newlyLost).length > 0) {\n      // store lost accounts\n      Object.keys(newlyLost).forEach((key) => {\n        lostIdentities[key] = newlyLost[key];\n      });\n    }\n\n    this.store.updateState({ identities, lostIdentities });\n    this.addAddresses(addresses);\n\n    // If the selected account is no longer valid,\n    // select an arbitrary other account:\n    let selected = this.getSelectedAddress();\n    if (!addresses.includes(selected)) {\n      selected = addresses[0];\n      this.setSelectedAddress(selected);\n    }\n\n    return selected;\n  }\n\n  /**\n   * Setter for the `selectedAddress` property\n   *\n   * @param {string} _address - A new hex address for an account\n   */\n  setSelectedAddress(_address) {\n    const address = normalizeAddress(_address);\n\n    const { identities } = this.store.getState();\n    const selectedIdentity = identities[address];\n    if (!selectedIdentity) {\n      throw new Error(`Identity for '${address} not found`);\n    }\n\n    selectedIdentity.lastSelected = Date.now();\n    this.store.updateState({ identities, selectedAddress: address });\n  }\n\n  /**\n   * Getter for the `selectedAddress` property\n   *\n   * @returns {string} The hex address for the currently selected account\n   */\n  getSelectedAddress() {\n    return this.store.getState().selectedAddress;\n  }\n\n  /**\n   * Sets a custom label for an account\n   *\n   * @param {string} account - the account to set a label for\n   * @param {string} label - the custom label for the account\n   * @returns {Promise<string>}\n   */\n  setAccountLabel(account, label) {\n    if (!account) {\n      throw new Error(\n        `setAccountLabel requires a valid address, got ${String(account)}`,\n      );\n    }\n    const address = normalizeAddress(account);\n    const { identities } = this.store.getState();\n    identities[address] = identities[address] || {};\n    identities[address].name = label;\n    this.store.updateState({ identities });\n    return Promise.resolve(label);\n  }\n\n  /**\n   * updates custom RPC details\n   *\n   * @param {Object} newRpcDetails - Options bag.\n   * @param {string} newRpcDetails.rpcUrl - The RPC url to add to frequentRpcList.\n   * @param {string} newRpcDetails.chainId - The chainId of the selected network.\n   * @param {string} [newRpcDetails.ticker] - Optional ticker symbol of the selected network.\n   * @param {string} [newRpcDetails.nickname] - Optional nickname of the selected network.\n   * @param {Object} [newRpcDetails.rpcPrefs] - Optional RPC preferences, such as the block explorer URL\n   */\n  async updateRpc(newRpcDetails) {\n    const rpcList = this.getFrequentRpcListDetail();\n    const index = rpcList.findIndex((element) => {\n      return element.rpcUrl === newRpcDetails.rpcUrl;\n    });\n    if (index > -1) {\n      const rpcDetail = rpcList[index];\n      const updatedRpc = { ...rpcDetail, ...newRpcDetails };\n      if (rpcDetail.chainId !== updatedRpc.chainId) {\n        // When the chainId is changed, associated address book entries should\n        // also be migrated. The address book entries are keyed by the `network` state,\n        // which for custom networks is the chainId with a fallback to the networkId\n        // if the chainId is not set.\n\n        let addressBookKey = rpcDetail.chainId;\n        if (!addressBookKey) {\n          // We need to find the networkId to determine what these addresses were keyed by\n          try {\n            addressBookKey = await this.ethersProvider.send('net_version');\n            assert(typeof addressBookKey === 'string');\n          } catch (error) {\n            log.debug(error);\n            log.warn(\n              `Failed to get networkId from ${rpcDetail.rpcUrl}; skipping address book migration`,\n            );\n          }\n        }\n\n        // There is an edge case where two separate RPC endpoints are keyed by the same\n        // value. In this case, the contact book entries are duplicated so that they remain\n        // on both networks, since we don't know which network each contact is intended for.\n\n        let duplicate = false;\n        const builtInProviderNetworkIds = Object.values(\n          NETWORK_TYPE_TO_ID_MAP,\n        ).map((ids) => ids.networkId);\n        const otherRpcEntries = rpcList.filter(\n          (entry) => entry.rpcUrl !== newRpcDetails.rpcUrl,\n        );\n        if (\n          builtInProviderNetworkIds.includes(addressBookKey) ||\n          otherRpcEntries.some((entry) => entry.chainId === addressBookKey)\n        ) {\n          duplicate = true;\n        }\n\n        this.migrateAddressBookState(\n          addressBookKey,\n          updatedRpc.chainId,\n          duplicate,\n        );\n      }\n      rpcList[index] = updatedRpc;\n      this.store.updateState({ frequentRpcListDetail: rpcList });\n    } else {\n      const {\n        rpcUrl,\n        chainId,\n        ticker,\n        nickname,\n        rpcPrefs = {},\n      } = newRpcDetails;\n      this.addToFrequentRpcList(rpcUrl, chainId, ticker, nickname, rpcPrefs);\n    }\n  }\n\n  /**\n   * Adds custom RPC url to state.\n   *\n   * @param {string} rpcUrl - The RPC url to add to frequentRpcList.\n   * @param {string} chainId - The chainId of the selected network.\n   * @param {string} [ticker] - Ticker symbol of the selected network.\n   * @param {string} [nickname] - Nickname of the selected network.\n   * @param {Object} [rpcPrefs] - Optional RPC preferences, such as the block explorer URL\n   */\n  addToFrequentRpcList(\n    rpcUrl,\n    chainId,\n    ticker = 'ETH',\n    nickname = '',\n    rpcPrefs = {},\n  ) {\n    const rpcList = this.getFrequentRpcListDetail();\n\n    const index = rpcList.findIndex((element) => {\n      return element.rpcUrl === rpcUrl;\n    });\n    if (index !== -1) {\n      rpcList.splice(index, 1);\n    }\n\n    if (!isPrefixedFormattedHexString(chainId)) {\n      throw new Error(`Invalid chainId: \"${chainId}\"`);\n    }\n\n    rpcList.push({ rpcUrl, chainId, ticker, nickname, rpcPrefs });\n    this.store.updateState({ frequentRpcListDetail: rpcList });\n  }\n\n  /**\n   * Removes custom RPC url from state.\n   *\n   * @param {string} url - The RPC url to remove from frequentRpcList.\n   * @returns {Promise<Array>} Promise resolving to updated frequentRpcList.\n   */\n  removeFromFrequentRpcList(url) {\n    const rpcList = this.getFrequentRpcListDetail();\n    const index = rpcList.findIndex((element) => {\n      return element.rpcUrl === url;\n    });\n    if (index !== -1) {\n      rpcList.splice(index, 1);\n    }\n    this.store.updateState({ frequentRpcListDetail: rpcList });\n    return Promise.resolve(rpcList);\n  }\n\n  /**\n   * Getter for the `frequentRpcListDetail` property.\n   *\n   * @returns {Array<Array>} An array of rpc urls.\n   */\n  getFrequentRpcListDetail() {\n    return this.store.getState().frequentRpcListDetail;\n  }\n\n  /**\n   * Updates the `featureFlags` property, which is an object. One property within that object will be set to a boolean.\n   *\n   * @param {string} feature - A key that corresponds to a UI feature.\n   * @param {boolean} activated - Indicates whether or not the UI feature should be displayed\n   * @returns {Promise<object>} Promises a new object; the updated featureFlags object.\n   */\n  setFeatureFlag(feature, activated) {\n    const currentFeatureFlags = this.store.getState().featureFlags;\n    const updatedFeatureFlags = {\n      ...currentFeatureFlags,\n      [feature]: activated,\n    };\n\n    this.store.updateState({ featureFlags: updatedFeatureFlags });\n\n    return Promise.resolve(updatedFeatureFlags);\n  }\n\n  /**\n   * Updates the `preferences` property, which is an object. These are user-controlled features\n   * found in the settings page.\n   *\n   * @param {string} preference - The preference to enable or disable.\n   * @param {boolean} value - Indicates whether or not the preference should be enabled or disabled.\n   * @returns {Promise<object>} Promises a new object; the updated preferences object.\n   */\n  setPreference(preference, value) {\n    const currentPreferences = this.getPreferences();\n    const updatedPreferences = {\n      ...currentPreferences,\n      [preference]: value,\n    };\n\n    this.store.updateState({ preferences: updatedPreferences });\n    return Promise.resolve(updatedPreferences);\n  }\n\n  /**\n   * A getter for the `preferences` property\n   *\n   * @returns {Object} A key-boolean map of user-selected preferences.\n   */\n  getPreferences() {\n    return this.store.getState().preferences;\n  }\n\n  /**\n   * A getter for the `ipfsGateway` property\n   *\n   * @returns {string} The current IPFS gateway domain\n   */\n  getIpfsGateway() {\n    return this.store.getState().ipfsGateway;\n  }\n\n  /**\n   * A setter for the `ipfsGateway` property\n   *\n   * @param {string} domain - The new IPFS gateway domain\n   * @returns {Promise<string>} A promise of the update IPFS gateway domain\n   */\n  setIpfsGateway(domain) {\n    this.store.updateState({ ipfsGateway: domain });\n    return Promise.resolve(domain);\n  }\n\n  /**\n   * A setter for the `ledgerTransportType` property.\n   *\n   * @param {string} ledgerTransportType - Either 'ledgerLive', 'webhid' or 'u2f'\n   * @returns {string} The transport type that was set.\n   */\n  setLedgerTransportPreference(ledgerTransportType) {\n    this.store.updateState({ ledgerTransportType });\n    return ledgerTransportType;\n  }\n\n  /**\n   * A getter for the `ledgerTransportType` property.\n   *\n   * @returns {string} The current preferred Ledger transport type.\n   */\n  getLedgerTransportPreference() {\n    return this.store.getState().ledgerTransportType;\n  }\n\n  /**\n   * A setter for the user preference to dismiss the seed phrase backup reminder\n   *\n   * @param {bool} dismissSeedBackUpReminder - User preference for dismissing the back up reminder.\n   */\n  async setDismissSeedBackUpReminder(dismissSeedBackUpReminder) {\n    await this.store.updateState({\n      dismissSeedBackUpReminder,\n    });\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  _subscribeToInfuraAvailability() {\n    this.network.on(NETWORK_EVENTS.INFURA_IS_BLOCKED, () => {\n      this._setInfuraBlocked(true);\n    });\n    this.network.on(NETWORK_EVENTS.INFURA_IS_UNBLOCKED, () => {\n      this._setInfuraBlocked(false);\n    });\n  }\n\n  /**\n   *\n   * A setter for the `infuraBlocked` property\n   *\n   * @param {boolean} isBlocked - Bool indicating whether Infura is blocked\n   */\n  _setInfuraBlocked(isBlocked) {\n    const { infuraBlocked } = this.store.getState();\n\n    if (infuraBlocked === isBlocked) {\n      return;\n    }\n\n    this.store.updateState({ infuraBlocked: isBlocked });\n  }\n}\n","/* Account Tracker\n *\n * This module is responsible for tracking any number of accounts\n * and caching their current balances & transaction counts.\n *\n * It also tracks transaction hashes, and checks their inclusion status\n * on each new block.\n */\n\nimport EthQuery from 'eth-query';\n\nimport { ObservableStore } from '@metamask/obs-store';\nimport log from 'loglevel';\nimport pify from 'pify';\nimport Web3 from 'web3';\nimport SINGLE_CALL_BALANCES_ABI from 'single-call-balance-checker-abi';\nimport {\n  MAINNET_CHAIN_ID,\n  RINKEBY_CHAIN_ID,\n  ROPSTEN_CHAIN_ID,\n  KOVAN_CHAIN_ID,\n} from '../../../shared/constants/network';\n\nimport {\n  SINGLE_CALL_BALANCES_ADDRESS,\n  SINGLE_CALL_BALANCES_ADDRESS_RINKEBY,\n  SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN,\n  SINGLE_CALL_BALANCES_ADDRESS_KOVAN,\n} from '../constants/contracts';\nimport { bnToHex } from './util';\n\n/**\n * This module is responsible for tracking any number of accounts and caching their current balances & transaction\n * counts.\n *\n * It also tracks transaction hashes, and checks their inclusion status on each new block.\n *\n * @typedef {Object} AccountTracker\n * @property {Object} store The stored object containing all accounts to track, as well as the current block's gas limit.\n * @property {Object} store.accounts The accounts currently stored in this AccountTracker\n * @property {string} store.currentBlockGasLimit A hex string indicating the gas limit of the current block\n * @property {Object} _provider A provider needed to create the EthQuery instance used within this AccountTracker.\n * @property {EthQuery} _query An EthQuery instance used to access account information from the blockchain\n * @property {BlockTracker} _blockTracker A BlockTracker instance. Needed to ensure that accounts and their info updates\n * when a new block is created.\n * @property {Object} _currentBlockNumber Reference to a property on the _blockTracker: the number (i.e. an id) of the the current block\n */\nexport default class AccountTracker {\n  /**\n   * @param {Object} opts - Options for initializing the controller\n   * @param {Object} opts.provider - An EIP-1193 provider instance that uses the current global network\n   * @param {Object} opts.blockTracker - A block tracker, which emits events for each new block\n   * @param {Function} opts.getCurrentChainId - A function that returns the `chainId` for the current global network\n   */\n  constructor(opts = {}) {\n    const initState = {\n      accounts: {},\n      currentBlockGasLimit: '',\n    };\n    this.store = new ObservableStore(initState);\n\n    this._provider = opts.provider;\n    this._query = pify(new EthQuery(this._provider));\n    this._blockTracker = opts.blockTracker;\n    // blockTracker.currentBlock may be null\n    this._currentBlockNumber = this._blockTracker.getCurrentBlock();\n    this._blockTracker.once('latest', (blockNumber) => {\n      this._currentBlockNumber = blockNumber;\n    });\n    // bind function for easier listener syntax\n    this._updateForBlock = this._updateForBlock.bind(this);\n    this.getCurrentChainId = opts.getCurrentChainId;\n\n    this.web3 = new Web3(this._provider);\n  }\n\n  start() {\n    // remove first to avoid double add\n    this._blockTracker.removeListener('latest', this._updateForBlock);\n    // add listener\n    this._blockTracker.addListener('latest', this._updateForBlock);\n    // fetch account balances\n    this._updateAccounts();\n  }\n\n  stop() {\n    // remove listener\n    this._blockTracker.removeListener('latest', this._updateForBlock);\n  }\n\n  /**\n   * Ensures that the locally stored accounts are in sync with a set of accounts stored externally to this\n   * AccountTracker.\n   *\n   * Once this AccountTracker's accounts are up to date with those referenced by the passed addresses, each\n   * of these accounts are given an updated balance via EthQuery.\n   *\n   * @param {Array} addresses - The array of hex addresses for accounts with which this AccountTracker's accounts should be\n   * in sync\n   */\n  syncWithAddresses(addresses) {\n    const { accounts } = this.store.getState();\n    const locals = Object.keys(accounts);\n\n    const accountsToAdd = [];\n    addresses.forEach((upstream) => {\n      if (!locals.includes(upstream)) {\n        accountsToAdd.push(upstream);\n      }\n    });\n\n    const accountsToRemove = [];\n    locals.forEach((local) => {\n      if (!addresses.includes(local)) {\n        accountsToRemove.push(local);\n      }\n    });\n\n    this.addAccounts(accountsToAdd);\n    this.removeAccount(accountsToRemove);\n  }\n\n  /**\n   * Adds new addresses to track the balances of\n   * given a balance as long this._currentBlockNumber is defined.\n   *\n   * @param {Array} addresses - An array of hex addresses of new accounts to track\n   */\n  addAccounts(addresses) {\n    const { accounts } = this.store.getState();\n    // add initial state for addresses\n    addresses.forEach((address) => {\n      accounts[address] = {};\n    });\n    // save accounts state\n    this.store.updateState({ accounts });\n    // fetch balances for the accounts if there is block number ready\n    if (!this._currentBlockNumber) {\n      return;\n    }\n    this._updateAccounts();\n  }\n\n  /**\n   * Removes accounts from being tracked\n   *\n   * @param {Array} addresses - An array of hex addresses to stop tracking.\n   */\n  removeAccount(addresses) {\n    const { accounts } = this.store.getState();\n    // remove each state object\n    addresses.forEach((address) => {\n      delete accounts[address];\n    });\n    // save accounts state\n    this.store.updateState({ accounts });\n  }\n\n  /**\n   * Removes all addresses and associated balances\n   */\n\n  clearAccounts() {\n    this.store.updateState({ accounts: {} });\n  }\n\n  /**\n   * Given a block, updates this AccountTracker's currentBlockGasLimit, and then updates each local account's balance\n   * via EthQuery\n   *\n   * @private\n   * @param {number} blockNumber - the block number to update to.\n   * @fires 'block' The updated state, if all account updates are successful\n   */\n  async _updateForBlock(blockNumber) {\n    this._currentBlockNumber = blockNumber;\n\n    // block gasLimit polling shouldn't be in account-tracker shouldn't be here...\n    const currentBlock = await this._query.getBlockByNumber(blockNumber, false);\n    if (!currentBlock) {\n      return;\n    }\n    const currentBlockGasLimit = currentBlock.gasLimit;\n    this.store.updateState({ currentBlockGasLimit });\n\n    try {\n      await this._updateAccounts();\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n  /**\n   * balanceChecker is deployed on main eth (test)nets and requires a single call\n   * for all other networks, calls this._updateAccount for each account in this.store\n   *\n   * @returns {Promise} after all account balances updated\n   */\n  async _updateAccounts() {\n    const { accounts } = this.store.getState();\n    const addresses = Object.keys(accounts);\n    const chainId = this.getCurrentChainId();\n\n    switch (chainId) {\n      case MAINNET_CHAIN_ID:\n        await this._updateAccountsViaBalanceChecker(\n          addresses,\n          SINGLE_CALL_BALANCES_ADDRESS,\n        );\n        break;\n\n      case RINKEBY_CHAIN_ID:\n        await this._updateAccountsViaBalanceChecker(\n          addresses,\n          SINGLE_CALL_BALANCES_ADDRESS_RINKEBY,\n        );\n        break;\n\n      case ROPSTEN_CHAIN_ID:\n        await this._updateAccountsViaBalanceChecker(\n          addresses,\n          SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN,\n        );\n        break;\n\n      case KOVAN_CHAIN_ID:\n        await this._updateAccountsViaBalanceChecker(\n          addresses,\n          SINGLE_CALL_BALANCES_ADDRESS_KOVAN,\n        );\n        break;\n\n      default:\n        await Promise.all(addresses.map(this._updateAccount.bind(this)));\n    }\n  }\n\n  /**\n   * Updates the current balance of an account.\n   *\n   * @private\n   * @param {string} address - A hex address of a the account to be updated\n   * @returns {Promise} after the account balance is updated\n   */\n  async _updateAccount(address) {\n    // query balance\n    const balance = await this._query.getBalance(address);\n    const result = { address, balance };\n    // update accounts state\n    const { accounts } = this.store.getState();\n    // only populate if the entry is still present\n    if (!accounts[address]) {\n      return;\n    }\n    accounts[address] = result;\n    this.store.updateState({ accounts });\n  }\n\n  /**\n   * Updates current address balances from balanceChecker deployed contract instance\n   *\n   * @param {*} addresses\n   * @param {*} deployedContractAddress\n   */\n  async _updateAccountsViaBalanceChecker(addresses, deployedContractAddress) {\n    const { accounts } = this.store.getState();\n    this.web3.setProvider(this._provider);\n    const ethContract = this.web3.eth\n      .contract(SINGLE_CALL_BALANCES_ABI)\n      .at(deployedContractAddress);\n    const ethBalance = ['0x0'];\n\n    ethContract.balances(addresses, ethBalance, (error, result) => {\n      if (error) {\n        log.warn(\n          `MetaMask - Account Tracker single call balance fetch failed`,\n          error,\n        );\n        Promise.all(addresses.map(this._updateAccount.bind(this)));\n        return;\n      }\n      addresses.forEach((address, index) => {\n        const balance = result[index] ? bnToHex(result[index]) : '0x0';\n        accounts[address] = { address, balance };\n      });\n      this.store.updateState({ accounts });\n    });\n  }\n}\n","const { EventEmitter } = require('events');\nconst ethUtil = require('ethereumjs-util');\nconst HDKey = require('hdkey');\nconst TrezorConnect = require('trezor-connect').default;\nconst { TransactionFactory } = require('@ethereumjs/tx');\nconst transformTypedData = require('trezor-connect/lib/plugins/ethereum/typedData');\n\nconst hdPathString = `m/44'/60'/0'/0`;\nconst SLIP0044TestnetPath = `m/44'/1'/0'/0`;\n\nconst ALLOWED_HD_PATHS = {\n  [hdPathString]: true,\n  [SLIP0044TestnetPath]: true,\n};\n\nconst keyringType = 'Trezor Hardware';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\nconst DELAY_BETWEEN_POPUPS = 1000;\nconst TREZOR_CONNECT_MANIFEST = {\n  email: 'support@metamask.io',\n  appUrl: 'https://metamask.io',\n};\n\nfunction wait(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * @typedef {__import__('@ethereumjs/tx').TypedTransaction} TypedTransaction\n * @typedef {InstanceType<__import__(\"ethereumjs-tx\")>} OldEthJsTransaction\n */\n\n/**\n * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx\n *\n * Transactions built with older versions of ethereumjs-tx have a\n * getChainId method that newer versions do not.\n * Older versions are mutable\n * while newer versions default to being immutable.\n * Expected shape and type\n * of data for v, r and s differ (Buffer (old) vs BN (new)).\n *\n * @param {TypedTransaction | OldEthJsTransaction} tx\n * @returns {tx is OldEthJsTransaction} Returns `true` if tx is an old-style ethereumjs-tx transaction.\n */\nfunction isOldStyleEthereumjsTx(tx) {\n  return typeof tx.getChainId === 'function';\n}\n\nclass TrezorKeyring extends EventEmitter {\n  constructor(opts = {}) {\n    super();\n    this.type = keyringType;\n    this.accounts = [];\n    this.hdk = new HDKey();\n    this.page = 0;\n    this.perPage = 5;\n    this.unlockedAccount = 0;\n    this.paths = {};\n    this.deserialize(opts);\n\n    TrezorConnect.on('DEVICE_EVENT', (event) => {\n      if (event && event.payload && event.payload.features) {\n        this.model = event.payload.features.model;\n      }\n    });\n    TrezorConnect.init({ manifest: TREZOR_CONNECT_MANIFEST });\n  }\n\n  /**\n   * Gets the model, if known.\n   * This may be `undefined` if the model hasn't been loaded yet.\n   *\n   * @returns {\"T\" | \"1\" | undefined}\n   */\n  getModel() {\n    return this.model;\n  }\n\n  dispose() {\n    // This removes the Trezor Connect iframe from the DOM\n    // This method is not well documented, but the code it calls can be seen\n    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181\n    TrezorConnect.dispose();\n  }\n\n  serialize() {\n    return Promise.resolve({\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      page: this.page,\n      paths: this.paths,\n      perPage: this.perPage,\n      unlockedAccount: this.unlockedAccount,\n    });\n  }\n\n  deserialize(opts = {}) {\n    this.hdPath = opts.hdPath || hdPathString;\n    this.accounts = opts.accounts || [];\n    this.page = opts.page || 0;\n    this.perPage = opts.perPage || 5;\n    return Promise.resolve();\n  }\n\n  isUnlocked() {\n    return Boolean(this.hdk && this.hdk.publicKey);\n  }\n\n  unlock() {\n    if (this.isUnlocked()) {\n      return Promise.resolve('already unlocked');\n    }\n    return new Promise((resolve, reject) => {\n      TrezorConnect.getPublicKey({\n        path: this.hdPath,\n        coin: 'ETH',\n      })\n        .then((response) => {\n          if (response.success) {\n            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');\n            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');\n            resolve('just unlocked');\n          } else {\n            reject(\n              new Error(\n                (response.payload && response.payload.error) || 'Unknown error',\n              ),\n            );\n          }\n        })\n        .catch((e) => {\n          reject(new Error((e && e.toString()) || 'Unknown error'));\n        });\n    });\n  }\n\n  setAccountToUnlock(index) {\n    this.unlockedAccount = parseInt(index, 10);\n  }\n\n  addAccounts(n = 1) {\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then((_) => {\n          const from = this.unlockedAccount;\n          const to = from + n;\n\n          for (let i = from; i < to; i++) {\n            const address = this._addressFromIndex(pathBase, i);\n            if (!this.accounts.includes(address)) {\n              this.accounts.push(address);\n            }\n            this.page = 0;\n          }\n          resolve(this.accounts);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this.__getPage(1);\n  }\n\n  getNextPage() {\n    return this.__getPage(1);\n  }\n\n  getPreviousPage() {\n    return this.__getPage(-1);\n  }\n\n  __getPage(increment) {\n    this.page += increment;\n\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then((_) => {\n          const from = (this.page - 1) * this.perPage;\n          const to = from + this.perPage;\n\n          const accounts = [];\n\n          for (let i = from; i < to; i++) {\n            const address = this._addressFromIndex(pathBase, i);\n            accounts.push({\n              address,\n              balance: null,\n              index: i,\n            });\n            this.paths[ethUtil.toChecksumAddress(address)] = i;\n          }\n          resolve(accounts);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  getAccounts() {\n    return Promise.resolve(this.accounts.slice());\n  }\n\n  removeAccount(address) {\n    if (\n      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())\n    ) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n\n    this.accounts = this.accounts.filter(\n      (a) => a.toLowerCase() !== address.toLowerCase(),\n    );\n  }\n\n  /**\n   * Signs a transaction using Trezor.\n   *\n   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns\n   * the same type.\n   *\n   * @template {TypedTransaction | OldEthJsTransaction} Transaction\n   * @param {string} address - Hex string address.\n   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.\n   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style\n   * ethereumjs transaction.\n   */\n  signTransaction(address, tx) {\n    if (isOldStyleEthereumjsTx(tx)) {\n      // In this version of ethereumjs-tx we must add the chainId in hex format\n      // to the initial v value. The chainId must be included in the serialized\n      // transaction which is only communicated to ethereumjs-tx in this\n      // value. In newer versions the chainId is communicated via the 'Common'\n      // object.\n      return this._signTransaction(address, tx.getChainId(), tx, (payload) => {\n        tx.v = Buffer.from(payload.v, 'hex');\n        tx.r = Buffer.from(payload.r, 'hex');\n        tx.s = Buffer.from(payload.s, 'hex');\n        return tx;\n      });\n    }\n    return this._signTransaction(\n      address,\n      tx.common.chainIdBN().toNumber(),\n      tx,\n      (payload) => {\n        // Because tx will be immutable, first get a plain javascript object that\n        // represents the transaction. Using txData here as it aligns with the\n        // nomenclature of ethereumjs/tx.\n        const txData = tx.toJSON();\n        // The fromTxData utility expects a type to support transactions with a type other than 0\n        txData.type = tx.type;\n        // The fromTxData utility expects v,r and s to be hex prefixed\n        txData.v = ethUtil.addHexPrefix(payload.v);\n        txData.r = ethUtil.addHexPrefix(payload.r);\n        txData.s = ethUtil.addHexPrefix(payload.s);\n        // Adopt the 'common' option from the original transaction and set the\n        // returned object to be frozen if the original is frozen.\n        return TransactionFactory.fromTxData(txData, {\n          common: tx.common,\n          freeze: Object.isFrozen(tx),\n        });\n      },\n    );\n  }\n\n  /**\n   *\n   * @template {TypedTransaction | OldEthJsTransaction} Transaction\n   * @param {string} address - Hex string address.\n   * @param {number} chainId - Chain ID\n   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.\n   * @param {(__import__('trezor-connect').EthereumSignedTx) => Transaction} handleSigning - Converts signed transaction\n   * to the same new-style or old-style ethereumjs-tx.\n   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style\n   * ethereumjs transaction.\n   */\n  async _signTransaction(address, chainId, tx, handleSigning) {\n    let transaction;\n    if (isOldStyleEthereumjsTx(tx)) {\n      // legacy transaction from ethereumjs-tx package has no .toJSON() function,\n      // so we need to convert to hex-strings manually manually\n      transaction = {\n        to: this._normalize(tx.to),\n        value: this._normalize(tx.value),\n        data: this._normalize(tx.data),\n        chainId,\n        nonce: this._normalize(tx.nonce),\n        gasLimit: this._normalize(tx.gasLimit),\n        gasPrice: this._normalize(tx.gasPrice),\n      };\n    } else {\n      // new-style transaction from @ethereumjs/tx package\n      // we can just copy tx.toJSON() for everything except chainId, which must be a number\n      transaction = {\n        ...tx.toJSON(),\n        chainId,\n        to: this._normalize(tx.to),\n      };\n    }\n\n    try {\n      const status = await this.unlock();\n      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);\n      const response = await TrezorConnect.ethereumSignTransaction({\n        path: this._pathFromAddress(address),\n        transaction,\n      });\n      if (response.success) {\n        const newOrMutatedTx = handleSigning(response.payload);\n\n        const addressSignedWith = ethUtil.toChecksumAddress(\n          ethUtil.addHexPrefix(\n            newOrMutatedTx.getSenderAddress().toString('hex'),\n          ),\n        );\n        const correctAddress = ethUtil.toChecksumAddress(address);\n        if (addressSignedWith !== correctAddress) {\n          throw new Error(\"signature doesn't match the right address\");\n        }\n\n        return newOrMutatedTx;\n      }\n      throw new Error(\n        (response.payload && response.payload.error) || 'Unknown error',\n      );\n    } catch (e) {\n      throw new Error((e && e.toString()) || 'Unknown error');\n    }\n  }\n\n  signMessage(withAccount, data) {\n    return this.signPersonalMessage(withAccount, data);\n  }\n\n  // For personal_sign, we need to prefix the message:\n  signPersonalMessage(withAccount, message) {\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then((status) => {\n          setTimeout(\n            (_) => {\n              TrezorConnect.ethereumSignMessage({\n                path: this._pathFromAddress(withAccount),\n                message: ethUtil.stripHexPrefix(message),\n                hex: true,\n              })\n                .then((response) => {\n                  if (response.success) {\n                    if (\n                      response.payload.address !==\n                      ethUtil.toChecksumAddress(withAccount)\n                    ) {\n                      reject(\n                        new Error('signature doesnt match the right address'),\n                      );\n                    }\n                    const signature = `0x${response.payload.signature}`;\n                    resolve(signature);\n                  } else {\n                    reject(\n                      new Error(\n                        (response.payload && response.payload.error) ||\n                          'Unknown error',\n                      ),\n                    );\n                  }\n                })\n                .catch((e) => {\n                  reject(new Error((e && e.toString()) || 'Unknown error'));\n                });\n              // This is necessary to avoid popup collision\n              // between the unlock & sign trezor popups\n            },\n            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,\n          );\n        })\n        .catch((e) => {\n          reject(new Error((e && e.toString()) || 'Unknown error'));\n        });\n    });\n  }\n\n  /**\n   * EIP-712 Sign Typed Data\n   */\n  async signTypedData(address, data, { version }) {\n    const dataWithHashes = transformTypedData(data, version === 'V4');\n\n    // set default values for signTypedData\n    // Trezor is stricter than @metamask/eth-sig-util in what it accepts\n    const {\n      types: { EIP712Domain = [], ...otherTypes } = {},\n      message = {},\n      domain = {},\n      primaryType,\n      // snake_case since Trezor uses Protobuf naming conventions here\n      domain_separator_hash, // eslint-disable-line camelcase\n      message_hash, // eslint-disable-line camelcase\n    } = dataWithHashes;\n\n    // This is necessary to avoid popup collision\n    // between the unlock & sign trezor popups\n    const status = await this.unlock();\n    await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);\n\n    const response = await TrezorConnect.ethereumSignTypedData({\n      path: this._pathFromAddress(address),\n      data: {\n        types: { EIP712Domain, ...otherTypes },\n        message,\n        domain,\n        primaryType,\n      },\n      metamask_v4_compat: true,\n      // Trezor 1 only supports blindly signing hashes\n      domain_separator_hash,\n      message_hash,\n    });\n\n    if (response.success) {\n      if (ethUtil.toChecksumAddress(address) !== response.payload.address) {\n        throw new Error('signature doesnt match the right address');\n      }\n      return response.payload.signature;\n    }\n\n    throw new Error(\n      (response.payload && response.payload.error) || 'Unknown error',\n    );\n  }\n\n  exportAccount() {\n    return Promise.reject(new Error('Not supported on this device'));\n  }\n\n  forgetDevice() {\n    this.accounts = [];\n    this.hdk = new HDKey();\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.paths = {};\n  }\n\n  /**\n   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.\n   *\n   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD\n   * path is set, and the wallet state is completely reset.\n   *\n   * @throws {Error] Throws if the HD path is not supported.\n   *\n   * @param {string} hdPath - The HD path to set.\n   */\n  setHdPath(hdPath) {\n    if (!ALLOWED_HD_PATHS[hdPath]) {\n      throw new Error(\n        `The setHdPath method does not support setting HD Path to ${hdPath}`,\n      );\n    }\n\n    // Reset HDKey if the path changes\n    if (this.hdPath !== hdPath) {\n      this.hdk = new HDKey();\n      this.accounts = [];\n      this.page = 0;\n      this.perPage = 5;\n      this.unlockedAccount = 0;\n      this.paths = {};\n    }\n    this.hdPath = hdPath;\n  }\n\n  /* PRIVATE METHODS */\n\n  _normalize(buf) {\n    return ethUtil.bufferToHex(buf).toString();\n  }\n\n  // eslint-disable-next-line no-shadow\n  _addressFromIndex(pathBase, i) {\n    const dkey = this.hdk.derive(`${pathBase}/${i}`);\n    const address = ethUtil\n      .publicToAddress(dkey.publicKey, true)\n      .toString('hex');\n    return ethUtil.toChecksumAddress(`0x${address}`);\n  }\n\n  _pathFromAddress(address) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address);\n    let index = this.paths[checksummedAddress];\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address');\n    }\n    return `${this.hdPath}/${index}`;\n  }\n}\n\nTrezorKeyring.type = keyringType;\nmodule.exports = TrezorKeyring;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./permissions\"), exports);\n__exportStar(require(\"./resource\"), exports);\n__exportStar(require(\"./services\"), exports);\n__exportStar(require(\"./snaps\"), exports);\n__exportStar(require(\"./subject-metadata\"), exports);\n//# sourceMappingURL=index.js.map","export * from './createMethodMiddleware';\n","\n'use strict'\n\nif (\"production\" === 'production') {\n  module.exports = require('./metamask-airgapped-keyring.cjs.production.min.js')\n} else {\n  module.exports = require('./metamask-airgapped-keyring.cjs.development.js')\n}\n","import { ObservableStore } from '@metamask/obs-store';\n\n/* eslint-disable import/first,import/order */\nconst Box = process.env.IN_TEST\n  ? require('../../../development/mock-3box')\n  : require('3box');\n/* eslint-enable import/order */\n\nimport log from 'loglevel';\nimport { JsonRpcEngine } from 'json-rpc-engine';\nimport { providerFromEngine } from 'eth-json-rpc-middleware';\nimport Migrator from '../lib/migrator';\nimport migrations from '../migrations';\nimport createOriginMiddleware from '../lib/createOriginMiddleware';\nimport createMetamaskMiddleware from './network/createMetamaskMiddleware';\n/* eslint-enable import/first */\n\nconst SYNC_TIMEOUT = 60 * 1000; // one minute\n\nexport default class ThreeBoxController {\n  constructor(opts = {}) {\n    const {\n      preferencesController,\n      keyringController,\n      addressBookController,\n      version,\n      getKeyringControllerState,\n      trackMetaMetricsEvent,\n    } = opts;\n\n    this.preferencesController = preferencesController;\n    this.addressBookController = addressBookController;\n    this.keyringController = keyringController;\n    this.provider = this._createProvider({\n      version,\n      getAccounts: async ({ origin }) => {\n        if (origin !== '3Box') {\n          return [];\n        }\n        const { isUnlocked } = getKeyringControllerState();\n\n        const accounts = await this.keyringController.getAccounts();\n\n        if (isUnlocked && accounts[0]) {\n          const appKeyAddress = await this.keyringController.getAppKeyAddress(\n            accounts[0],\n            'wallet://3box.metamask.io',\n          );\n          return [appKeyAddress];\n        }\n        return [];\n      },\n      processPersonalMessage: async (msgParams) => {\n        const accounts = await this.keyringController.getAccounts();\n        return keyringController.signPersonalMessage(\n          { ...msgParams, from: accounts[0] },\n          {\n            withAppKeyOrigin: 'wallet://3box.metamask.io',\n          },\n        );\n      },\n    });\n    this._trackMetaMetricsEvent = trackMetaMetricsEvent;\n\n    const initState = {\n      threeBoxSyncingAllowed: false,\n      showRestorePrompt: true,\n      threeBoxLastUpdated: 0,\n      ...opts.initState,\n      threeBoxAddress: null,\n      threeBoxSynced: false,\n      threeBoxDisabled: false,\n    };\n    this.store = new ObservableStore(initState);\n    this.registeringUpdates = false;\n    this.lastMigration = migrations\n      .sort((a, b) => a.version - b.version)\n      .slice(-1)[0];\n\n    if (initState.threeBoxSyncingAllowed) {\n      this.init();\n    }\n  }\n\n  async init() {\n    const accounts = await this.keyringController.getAccounts();\n    this.address = accounts[0];\n\n    this._trackMetaMetricsEvent({\n      event: '3Box Initiated',\n      category: '3Box',\n    });\n\n    if (this.address && !(this.box && this.store.getState().threeBoxSynced)) {\n      await this.new3Box();\n    }\n  }\n\n  async _update3Box() {\n    try {\n      const { threeBoxSyncingAllowed, threeBoxSynced } = this.store.getState();\n      if (threeBoxSyncingAllowed && threeBoxSynced) {\n        const newState = {\n          preferences: this.preferencesController.store.getState(),\n          addressBook: this.addressBookController.state,\n          lastUpdated: Date.now(),\n          lastMigration: this.lastMigration,\n        };\n\n        await this.space.private.set(\n          'metamaskBackup',\n          JSON.stringify(newState),\n        );\n        await this.setShowRestorePromptToFalse();\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  _createProvider(providerOpts) {\n    const metamaskMiddleware = createMetamaskMiddleware(providerOpts);\n    const engine = new JsonRpcEngine();\n    engine.push(createOriginMiddleware({ origin: '3Box' }));\n    engine.push(metamaskMiddleware);\n    const provider = providerFromEngine(engine);\n    return provider;\n  }\n\n  _waitForOnSyncDone() {\n    return new Promise((resolve) => {\n      this.box.onSyncDone(() => {\n        log.debug('3Box box sync done');\n        return resolve();\n      });\n    });\n  }\n\n  async new3Box() {\n    const accounts = await this.keyringController.getAccounts();\n    this.address = await this.keyringController.getAppKeyAddress(\n      accounts[0],\n      'wallet://3box.metamask.io',\n    );\n    let backupExists;\n    try {\n      const threeBoxConfig = await Box.getConfig(this.address);\n      backupExists = threeBoxConfig.spaces && threeBoxConfig.spaces.metamask;\n    } catch (e) {\n      if (e.message.match(/^Error: Invalid response \\(404\\)/u)) {\n        this._trackMetaMetricsEvent({\n          event: '3Box Backup does not exist',\n          category: '3Box',\n        });\n\n        backupExists = false;\n      } else {\n        this._trackMetaMetricsEvent({\n          event: '3Box Config Error',\n          category: '3Box',\n        });\n\n        throw e;\n      }\n    }\n    if (this.getThreeBoxSyncingState() || backupExists) {\n      this.store.updateState({ threeBoxSynced: false });\n\n      let timedOut = false;\n      const syncTimeout = setTimeout(() => {\n        log.error(`3Box sync timed out after ${SYNC_TIMEOUT} ms`);\n        timedOut = true;\n        this.store.updateState({\n          threeBoxDisabled: true,\n          threeBoxSyncingAllowed: false,\n        });\n      }, SYNC_TIMEOUT);\n      try {\n        this.box = await Box.openBox(this.address, this.provider);\n        await this._waitForOnSyncDone();\n        this.space = await this.box.openSpace('metamask', {\n          onSyncDone: async () => {\n            const stateUpdate = {\n              threeBoxSynced: true,\n              threeBoxAddress: this.address,\n            };\n            if (timedOut) {\n              log.info(`3Box sync completed after timeout; no longer disabled`);\n              stateUpdate.threeBoxDisabled = false;\n            }\n\n            clearTimeout(syncTimeout);\n            this.store.updateState(stateUpdate);\n\n            log.debug('3Box space sync done');\n\n            this._trackMetaMetricsEvent({\n              event: '3Box Synced',\n              category: '3Box',\n            });\n          },\n        });\n      } catch (e) {\n        this._trackMetaMetricsEvent({\n          event: '3Box Initiation Error',\n          category: '3Box',\n        });\n\n        console.error(e);\n        throw e;\n      }\n    }\n  }\n\n  async getLastUpdated() {\n    const res = await this.space.private.get('metamaskBackup');\n    const parsedRes = JSON.parse(res || '{}');\n    return parsedRes.lastUpdated;\n  }\n\n  async migrateBackedUpState(backedUpState) {\n    const migrator = new Migrator({ migrations });\n    const { preferences, addressBook } = JSON.parse(backedUpState);\n    const formattedStateBackup = {\n      PreferencesController: preferences,\n      AddressBookController: addressBook,\n    };\n    const initialMigrationState = migrator.generateInitialState(\n      formattedStateBackup,\n    );\n    const migratedState = await migrator.migrateData(initialMigrationState);\n    return {\n      preferences: migratedState.data.PreferencesController,\n      addressBook: migratedState.data.AddressBookController,\n    };\n  }\n\n  async restoreFromThreeBox() {\n    const backedUpState = await this.space.private.get('metamaskBackup');\n    const { preferences, addressBook } = await this.migrateBackedUpState(\n      backedUpState,\n    );\n    this.store.updateState({ threeBoxLastUpdated: backedUpState.lastUpdated });\n    preferences && this.preferencesController.store.updateState(preferences);\n    addressBook && this.addressBookController.update(addressBook, true);\n    this.setShowRestorePromptToFalse();\n\n    this._trackMetaMetricsEvent({\n      event: '3Box Restored Data',\n      category: '3Box',\n    });\n  }\n\n  turnThreeBoxSyncingOn() {\n    this._trackMetaMetricsEvent({\n      event: '3Box Sync Turned On',\n      category: '3Box',\n    });\n\n    this._registerUpdates();\n  }\n\n  turnThreeBoxSyncingOff() {\n    this._trackMetaMetricsEvent({\n      event: '3Box Sync Turned Off',\n      category: '3Box',\n    });\n\n    this.box.logout();\n  }\n\n  setShowRestorePromptToFalse() {\n    this.store.updateState({ showRestorePrompt: false });\n  }\n\n  setThreeBoxSyncingPermission(newThreeboxSyncingState) {\n    if (this.store.getState().threeBoxDisabled) {\n      return;\n    }\n    this.store.updateState({\n      threeBoxSyncingAllowed: newThreeboxSyncingState,\n    });\n\n    if (newThreeboxSyncingState && this.box) {\n      this.turnThreeBoxSyncingOn();\n    }\n\n    if (!newThreeboxSyncingState && this.box) {\n      this.turnThreeBoxSyncingOff();\n    }\n  }\n\n  getThreeBoxSyncingState() {\n    return this.store.getState().threeBoxSyncingAllowed;\n  }\n\n  _registerUpdates() {\n    if (!this.registeringUpdates) {\n      const updatePreferences = this._update3Box.bind(this);\n      this.preferencesController.store.subscribe(updatePreferences);\n      const updateAddressBook = this._update3Box.bind(this);\n      this.addressBookController.subscribe(updateAddressBook);\n      this.registeringUpdates = true;\n    }\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    }\n    catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(() => {\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for (let i = 0; i < n; i += 1) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n    emit(type, ...args) {\n        let doError = type === 'error';\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        }\n        else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === 'function') {\n            safeApply(handler, this, args);\n        }\n        else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for (let i = 0; i < len; i += 1) {\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nexports.default = SafeEventEmitter;\n//# sourceMappingURL=index.js.map","var Transform = require('readable-stream').Transform\n  , inherits  = require('util').inherits\n  , xtend     = require('xtend')\n\nfunction DestroyableTransform(opts) {\n  Transform.call(this, opts)\n  this._destroyed = false\n}\n\ninherits(DestroyableTransform, Transform)\n\nDestroyableTransform.prototype.destroy = function(err) {\n  if (this._destroyed) return\n  this._destroyed = true\n  \n  var self = this\n  process.nextTick(function() {\n    if (err)\n      self.emit('error', err)\n    self.emit('close')\n  })\n}\n\n// a noop _transform function\nfunction noop (chunk, enc, callback) {\n  callback(null, chunk)\n}\n\n\n// create a new export function, used by both the main export and\n// the .ctor export, contains common logic for dealing with arguments\nfunction through2 (construct) {\n  return function (options, transform, flush) {\n    if (typeof options == 'function') {\n      flush     = transform\n      transform = options\n      options   = {}\n    }\n\n    if (typeof transform != 'function')\n      transform = noop\n\n    if (typeof flush != 'function')\n      flush = null\n\n    return construct(options, transform, flush)\n  }\n}\n\n\n// main export, just make me a transform stream!\nmodule.exports = through2(function (options, transform, flush) {\n  var t2 = new DestroyableTransform(options)\n\n  t2._transform = transform\n\n  if (flush)\n    t2._flush = flush\n\n  return t2\n})\n\n\n// make me a reusable prototype that I can `new`, or implicitly `new`\n// with a constructor call\nmodule.exports.ctor = through2(function (options, transform, flush) {\n  function Through2 (override) {\n    if (!(this instanceof Through2))\n      return new Through2(override)\n\n    this.options = xtend(options, override)\n\n    DestroyableTransform.call(this, this.options)\n  }\n\n  inherits(Through2, DestroyableTransform)\n\n  Through2.prototype._transform = transform\n\n  if (flush)\n    Through2.prototype._flush = flush\n\n  return Through2\n})\n\n\nmodule.exports.obj = through2(function (options, transform, flush) {\n  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))\n\n  t2._transform = transform\n\n  if (flush)\n    t2._flush = flush\n\n  return t2\n})\n","import { cloneDeep } from 'lodash';\nimport { TRANSACTION_STATUSES } from '../../../shared/constants/transaction';\n\nexport default function failTxsThat(version, reason, condition) {\n  return function (originalVersionedData) {\n    const versionedData = cloneDeep(originalVersionedData);\n    versionedData.meta.version = version;\n    try {\n      const state = versionedData.data;\n      const newState = transformState(state, condition, reason);\n      versionedData.data = newState;\n    } catch (err) {\n      console.warn(`MetaMask Migration #${version}${err.stack}`);\n    }\n    return Promise.resolve(versionedData);\n  };\n}\n\nfunction transformState(state, condition, reason) {\n  const newState = state;\n  const { TransactionController } = newState;\n  if (TransactionController && TransactionController.transactions) {\n    const { transactions } = TransactionController;\n\n    newState.TransactionController.transactions = transactions.map((txMeta) => {\n      if (!condition(txMeta)) {\n        return txMeta;\n      }\n\n      txMeta.status = TRANSACTION_STATUSES.FAILED;\n      txMeta.err = {\n        message: reason,\n        note: `Tx automatically failed by migration because ${reason}`,\n      };\n\n      return txMeta;\n    });\n  }\n  return newState;\n}\n","import jsonDiffer from 'fast-json-patch';\nimport { cloneDeep } from 'lodash';\n\n/**\n * converts non-initial history entries into diffs\n *\n * @param {Array} longHistory\n * @returns {Array}\n */\nexport function migrateFromSnapshotsToDiffs(longHistory) {\n  return (\n    longHistory\n      // convert non-initial history entries into diffs\n      .map((entry, index) => {\n        if (index === 0) {\n          return entry;\n        }\n        return generateHistoryEntry(longHistory[index - 1], entry);\n      })\n  );\n}\n\n/**\n * Generates an array of history objects sense the previous state.\n * The object has the keys\n * op (the operation performed),\n * path (the key and if a nested object then each key will be separated with a `/`)\n * value\n * with the first entry having the note and a timestamp when the change took place\n *\n * @param {Object} previousState - the previous state of the object\n * @param {Object} newState - the update object\n * @param {string} [note] - a optional note for the state change\n * @returns {Array}\n */\nexport function generateHistoryEntry(previousState, newState, note) {\n  const entry = jsonDiffer.compare(previousState, newState);\n  // Add a note to the first op, since it breaks if we append it to the entry\n  if (entry[0]) {\n    if (note) {\n      entry[0].note = note;\n    }\n    entry[0].timestamp = Date.now();\n  }\n  return entry;\n}\n\n/**\n * Recovers previous txMeta state obj\n *\n * @param _shortHistory\n * @returns {Object}\n */\nexport function replayHistory(_shortHistory) {\n  const shortHistory = cloneDeep(_shortHistory);\n  return shortHistory.reduce(\n    (val, entry) => jsonDiffer.applyPatch(val, entry).newDocument,\n  );\n}\n\n/**\n * Snapshot {@code txMeta}\n *\n * @param {Object} txMeta - the tx metadata object\n * @returns {Object} a deep clone without history\n */\nexport function snapshotFromTxMeta(txMeta) {\n  const shallow = { ...txMeta };\n  delete shallow.history;\n  return cloneDeep(shallow);\n}\n","module.exports = function toDataView (data) {\n  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n    return new DataView(data.buffer, data.byteOffset, data.byteLength)\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data)\n  }\n\n  throw new TypeError('Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray')\n}\n"]}